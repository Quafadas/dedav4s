package viz.vega.dsl.vegaLite

import scala.util.Try
import io.circe.syntax._
import io.circe._
import cats.syntax.functor._

// For serialising string unions

// If a union has a null in, then we'll need this too... 
type NullValue = None.type

/**
 * A Vega-Lite top-level specification. This is the root class for all Vega-Lite
 * specifications. (The json schema is generated from this type.)
 */
case class VegaLiteDSL (
    /**
     * URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you
     * have a reason to change this, use `https://vega.github.io/schema/vega-lite/v5.json`.
     * Setting the `$schema` property allows automatic validation and autocomplete in editors
     * that support JSON schema.
     */
    val `$schema` : Option[String] = None,

    /**
     * The alignment to apply to grid rows and columns. The supported string values are `"all"`,
     * `"each"`, and `"none"`.
     *
     * - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed
     * one after the other.
     * - For `"each"`, subviews will be aligned into a clean grid structure, but each row or
     * column may be of variable size.
     * - For `"all"`, subviews will be aligned and each row or column will be sized identically
     * based on the maximum observed size. String values for this property will be applied to
     * both grid rows and columns.
     *
     * Alternatively, an object value of the form `{"row": string, "column": string}` can be
     * used to supply different alignments for rows and columns.
     *
     * __Default value:__ `"all"`.
     */
    val align : Option[VegaLiteDSLAlign] = None,

    /**
     * How the visualization size should be determined. If a string, should be one of `"pad"`,
     * `"fit"` or `"none"`. Object values can additionally specify parameters for content sizing
     * and automatic resizing.
     *
     * __Default value__: `pad`
     */
    val autosize : Option[Autosize] = None,

    /**
     * CSS color property to use as the background of the entire view.
     *
     * __Default value:__ `"white"`
     */
    val background : Option[BackgroundUnion] = None,

    /**
     * The bounds calculation method to use for determining the extent of a sub-plot. One of
     * `full` (the default) or `flush`.
     *
     * - If set to `full`, the entire calculated bounds (including axes, title, and legend) will
     * be used.
     * - If set to `flush`, only the specified width and height values for the sub-view will be
     * used. The `flush` setting can be useful when attempting to place sub-plots without axes
     * or legends into a uniform grid structure.
     *
     * __Default value:__ `"full"`
     */
    val bounds : Option[Bounds] = None,

    /**
     * Boolean flag indicating if subviews should be centered relative to their respective rows
     * or columns.
     *
     * An object value of the form `{"row": boolean, "column": boolean}` can be used to supply
     * different centering values for rows and columns.
     *
     * __Default value:__ `false`
     *
     * Boolean flag indicating if subviews should be centered relative to their respective rows
     * or columns.
     *
     * __Default value:__ `false`
     */
    val center : Option[Center] = None,

    /**
     * Vega-Lite configuration object. This property can only be defined at the top-level of a
     * specification.
     */
    val config : Option[ConfigClass] = None,

    /**
     * An object describing the data source. Set to `null` to ignore the parent's data source.
     * If no data is set, it is derived from the parent.
     */
    val data : Option[URLData] = None,

    /**
     * A global data store for named datasets. This is a mapping from names to inline datasets.
     * This can be an array of objects or primitive values or a string. Arrays of primitive
     * values are ingested as objects with a `data` property.
     */
    val datasets : Option[Map[String, InlineDataset]] = None,

    /**
     * Description of this mark for commenting purpose.
     */
    val description : Option[String] = None,

    /**
     * A key-value mapping between encoding channels and definition of fields.
     *
     * A shared key-value mapping between encoding channels and definition of fields in the
     * underlying layers.
     */
    val encoding : Option[EdEncoding] = None,

    /**
     * The height of a visualization.
     *
     * - For a plot with a continuous y-field, height should be a number.
     * - For a plot with either a discrete y-field or no y-field, height can be either a number
     * indicating a fixed height or an object in the form of `{step: number}` defining the
     * height per discrete step. (No y-field is equivalent to having one discrete step.)
     * - To enable responsive sizing on height, it should be set to `"container"`.
     *
     * __Default value:__ Based on `config.view.continuousHeight` for a plot with a continuous
     * y-field and `config.view.discreteHeight` otherwise.
     *
     * __Note:__ For plots with [`row` and `column`
     * channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the
     * height of a single view and the `"container"` option cannot be used.
     *
     * __See also:__ [`height`](https://vega.github.io/vega-lite/docs/size.html) documentation.
     */
    val height : Option[SpecHeight] = None,

    /**
     * A string describing the mark type (one of `"bar"`, `"circle"`, `"square"`, `"tick"`,
     * `"line"`, `"area"`, `"point"`, `"rule"`, `"geoshape"`, and `"text"`) or a [mark
     * definition object](https://vega.github.io/vega-lite/docs/mark.html#mark-def).
     */
    val mark : Option[AnyMark] = None,

    /**
     * Name of the visualization for later reference.
     */
    val name : Option[String] = None,

    /**
     * The default visualization padding, in pixels, from the edge of the visualization canvas
     * to the data rectangle. If a number, specifies padding for all sides. If an object, the
     * value should have the format `{"left": 5, "top": 5, "right": 5, "bottom": 5}` to specify
     * padding for each side of the visualization.
     *
     * __Default value__: `5`
     */
    val padding : Option[Padding] = None,

    /**
     * An array of parameters that may either be simple variables, or more complex selections
     * that map user input to data queries.
     *
     * Dynamic variables or selections that parameterize a visualization.
     */
    val params : Option[Seq[TopLevelParameter]] = None,

    /**
     * An object defining properties of geographic projection, which will be applied to `shape`
     * path for `"geoshape"` marks and to `latitude` and `"longitude"` channels for other
     * marks.
     *
     * An object defining properties of the geographic projection shared by underlying layers.
     */
    val projection : Option[Projection] = None,

    /**
     * Scale, axis, and legend resolutions for view composition specifications.
     */
    val resolve : Option[Resolve] = None,

    /**
     * The spacing in pixels between sub-views of the composition operator. An object of the
     * form `{"row": number, "column": number}` can be used to set different spacing values for
     * rows and columns.
     *
     * __Default value__: Depends on `"spacing"` property of [the view composition
     * configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by
     * default)
     *
     * The spacing in pixels between sub-views of the concat operator.
     *
     * __Default value__: `10`
     */
    val spacing : Option[Spacing] = None,

    /**
     * Title for the plot.
     */
    val title : Option[LayerTitle] = None,

    /**
     * An array of data transformations such as filter and new field calculation.
     */
    val transform : Option[Seq[Transform]] = None,

    /**
     * Optional metadata that will be passed to Vega. This object is completely ignored by Vega
     * and Vega-Lite and can be used for custom metadata.
     */
    val usermeta : Option[Map[String, Option[Json]]] = None,

    /**
     * An object defining the view background's fill and stroke.
     *
     * __Default value:__ none (transparent)
     */
    val view : Option[ViewBackground] = None,

    /**
     * The width of a visualization.
     *
     * - For a plot with a continuous x-field, width should be a number.
     * - For a plot with either a discrete x-field or no x-field, width can be either a number
     * indicating a fixed width or an object in the form of `{step: number}` defining the width
     * per discrete step. (No x-field is equivalent to having one discrete step.)
     * - To enable responsive sizing on width, it should be set to `"container"`.
     *
     * __Default value:__ Based on `config.view.continuousWidth` for a plot with a continuous
     * x-field and `config.view.discreteWidth` otherwise.
     *
     * __Note:__ For plots with [`row` and `column`
     * channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the
     * width of a single view and the `"container"` option cannot be used.
     *
     * __See also:__ [`width`](https://vega.github.io/vega-lite/docs/size.html) documentation.
     */
    val width : Option[SpecHeight] = None,

    /**
     * The number of columns to include in the view composition layout.
     *
     * __Default value__: `undefined` -- An infinite number of columns (a single row) will be
     * assumed. This is equivalent to `hconcat` (for `concat`) and to using the `column` channel
     * (for `facet` and `repeat`).
     *
     * __Note__:
     *
     * 1) This property is only for:
     * - the general (wrappable) `concat` operator (not `hconcat`/`vconcat`)
     * - the `facet` and `repeat` operator with one field/repetition definition (without
     * row/column nesting)
     *
     * 2) Setting the `columns` to `1` is equivalent to `vconcat` (for `concat`) and to using
     * the `row` channel (for `facet` and `repeat`).
     */
    val columns : Option[Double] = None,

    /**
     * Definition for how to facet the data. One of: 1) [a field definition for faceting the
     * plot by one field](https://vega.github.io/vega-lite/docs/facet.html#field-def) 2) [An
     * object that maps `row` and `column` channels to their field
     * definitions](https://vega.github.io/vega-lite/docs/facet.html#mapping)
     */
    val facet : Option[Facet] = None,

    /**
     * A specification of the view that gets faceted.
     *
     * A specification of the view that gets repeated.
     */
    val spec : Option[VegaLiteDSLSpec] = None,

    /**
     * Layer or single view specifications to be layered.
     *
     * __Note__: Specifications inside `layer` cannot use `row` and `column` channels as
     * layering facet specifications is not allowed. Instead, use the [facet
     * operator](https://vega.github.io/vega-lite/docs/facet.html) and place a layer inside a
     * facet.
     */
    val layer : Option[Seq[LayerSpec]] = None,

    /**
     * Definition for fields to be repeated. One of: 1) An array of fields to be repeated. If
     * `"repeat"` is an array, the field can be referred to as `{"repeat": "repeat"}`. The
     * repeated views are laid out in a wrapped row. You can set the number of columns to
     * control the wrapping. 2) An object that maps `"row"` and/or `"column"` to the listed
     * fields to be repeated along the particular orientations. The objects `{"repeat": "row"}`
     * and `{"repeat": "column"}` can be used to refer to the repeated field respectively.
     */
    val repeat : Option[RepeatUnion] = None,

    /**
     * A list of views to be concatenated.
     */
    val concat : Option[Seq[Spec]] = None,

    /**
     * A list of views to be concatenated and put into a column.
     */
    val vconcat : Option[Seq[Spec]] = None,

    /**
     * A list of views to be concatenated and put into a row.
     */
    val hconcat : Option[Seq[Spec]] = None
) derives Encoder.AsObject, Decoder

/**
 * The alignment to apply to grid rows and columns. The supported string values are `"all"`,
 * `"each"`, and `"none"`.
 *
 * - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed
 * one after the other.
 * - For `"each"`, subviews will be aligned into a clean grid structure, but each row or
 * column may be of variable size.
 * - For `"all"`, subviews will be aligned and each row or column will be sized identically
 * based on the maximum observed size. String values for this property will be applied to
 * both grid rows and columns.
 *
 * Alternatively, an object value of the form `{"row": string, "column": string}` can be
 * used to supply different alignments for rows and columns.
 *
 * __Default value:__ `"all"`.
 */
type VegaLiteDSLAlign = LayoutAlign | RowColLayoutAlign
given Decoder[VegaLiteDSLAlign] = {
    List[Decoder[VegaLiteDSLAlign]](
        Decoder[LayoutAlign].widen,
        Decoder[RowColLayoutAlign].widen,
    ).reduceLeft(_ or _)
}

given Encoder[VegaLiteDSLAlign] = Encoder.instance {
    case enc0 : LayoutAlign => summon[Encoder[LayoutAlign]].apply(enc0)
    case enc1 : RowColLayoutAlign => Encoder.AsObject[RowColLayoutAlign].apply(enc1)
}

case class RowColLayoutAlign (
    val column : Option[LayoutAlign] = None,
    val row : Option[LayoutAlign] = None
) derives Encoder.AsObject, Decoder

/**
 * The alignment to apply to symbol legends rows and columns. The supported string values
 * are `"all"`, `"each"` (the default), and `none`. For more information, see the [grid
 * layout documentation](https://vega.github.io/vega/docs/layout).
 *
 * __Default value:__ `"each"`.
 *
 * The alignment to apply to row/column facet's subplot. The supported string values are
 * `"all"`, `"each"`, and `"none"`.
 *
 * - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed
 * one after the other.
 * - For `"each"`, subviews will be aligned into a clean grid structure, but each row or
 * column may be of variable size.
 * - For `"all"`, subviews will be aligned and each row or column will be sized identically
 * based on the maximum observed size. String values for this property will be applied to
 * both grid rows and columns.
 *
 * __Default value:__ `"all"`.
 */

enum LayoutAlign : 
    case all
    case each
    case none
given Decoder[LayoutAlign] = Decoder.decodeString.emapTry(x => Try(LayoutAlign.valueOf(x) )) 
given Encoder[LayoutAlign] = Encoder.encodeString.contramap(_.toString())

/**
 * How the visualization size should be determined. If a string, should be one of `"pad"`,
 * `"fit"` or `"none"`. Object values can additionally specify parameters for content sizing
 * and automatic resizing.
 *
 * __Default value__: `pad`
 */
type Autosize = AutoSizeParams | AutosizeType
given Decoder[Autosize] = {
    List[Decoder[Autosize]](
        Decoder[AutoSizeParams].widen,
        Decoder[AutosizeType].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Autosize] = Encoder.instance {
    case enc0 : AutoSizeParams => Encoder.AsObject[AutoSizeParams].apply(enc0)
    case enc1 : AutosizeType => summon[Encoder[AutosizeType]].apply(enc1)
}

case class AutoSizeParams (
    /**
     * Determines how size calculation should be performed, one of `"content"` or `"padding"`.
     * The default setting (`"content"`) interprets the width and height settings as the data
     * rectangle (plotting) dimensions, to which padding is then added. In contrast, the
     * `"padding"` setting includes the padding within the view size calculations, such that the
     * width and height settings indicate the **total** intended size of the view.
     *
     * __Default value__: `"content"`
     */
    val contains : Option[Contains] = None,

    /**
     * A boolean flag indicating if autosize layout should be re-calculated on every view
     * update.
     *
     * __Default value__: `false`
     */
    val resize : Option[Boolean] = None,

    /**
     * The sizing format type. One of `"pad"`, `"fit"`, `"fit-x"`, `"fit-y"`,  or `"none"`. See
     * the [autosize type](https://vega.github.io/vega-lite/docs/size.html#autosize)
     * documentation for descriptions of each.
     *
     * __Default value__: `"pad"`
     */
    val `type` : Option[AutosizeType] = None
) derives Encoder.AsObject, Decoder

/**
 * The sizing format type. One of `"pad"`, `"fit"`, `"fit-x"`, `"fit-y"`,  or `"none"`. See
 * the [autosize type](https://vega.github.io/vega-lite/docs/size.html#autosize)
 * documentation for descriptions of each.
 *
 * __Default value__: `"pad"`
 */

enum AutosizeType : 
    case fit
    case `fit-x`
    case `fit-y`
    case none
    case pad
given Decoder[AutosizeType] = Decoder.decodeString.emapTry(x => Try(AutosizeType.valueOf(x) )) 
given Encoder[AutosizeType] = Encoder.encodeString.contramap(_.toString())

/**
 * Determines how size calculation should be performed, one of `"content"` or `"padding"`.
 * The default setting (`"content"`) interprets the width and height settings as the data
 * rectangle (plotting) dimensions, to which padding is then added. In contrast, the
 * `"padding"` setting includes the padding within the view size calculations, such that the
 * width and height settings indicate the **total** intended size of the view.
 *
 * __Default value__: `"content"`
 */

enum Contains : 
    case content
    case padding
given Decoder[Contains] = Decoder.decodeString.emapTry(x => Try(Contains.valueOf(x) )) 
given Encoder[Contains] = Encoder.encodeString.contramap(_.toString())

/**
 * CSS color property to use as the background of the entire view.
 *
 * __Default value:__ `"white"`
 *
 * The color of the header label, can be in hex color code or regular color name.
 *
 * Color of the header title, can be in hex color code or regular color name.
 *
 * For text marks, the vertical text baseline. One of `"alphabetic"` (default), `"top"`,
 * `"middle"`, `"bottom"`, `"line-top"`, `"line-bottom"`, or an expression reference that
 * provides one of the valid values. The `"line-top"` and `"line-bottom"` values operate
 * similarly to `"top"` and `"bottom"`, but are calculated relative to the `lineHeight`
 * rather than `fontSize` alone.
 *
 * For range marks, the vertical alignment of the marks. One of `"top"`, `"middle"`,
 * `"bottom"`.
 *
 * __Note:__ Expression reference is *not* supported for range marks.
 *
 * The vertical text baseline for the header labels. One of `"alphabetic"` (default),
 * `"top"`, `"middle"`, `"bottom"`, `"line-top"`, or `"line-bottom"`. The `"line-top"` and
 * `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated
 * relative to the `titleLineHeight` rather than `titleFontSize` alone.
 *
 * The vertical text baseline for the header title. One of `"alphabetic"` (default),
 * `"top"`, `"middle"`, `"bottom"`, `"line-top"`, or `"line-bottom"`. The `"line-top"` and
 * `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated
 * relative to the `titleLineHeight` rather than `titleFontSize` alone.
 *
 * __Default value:__ `"middle"`
 */
type BackgroundUnion = BackgroundExprRef | String
given Decoder[BackgroundUnion] = {
    List[Decoder[BackgroundUnion]](
        Decoder[BackgroundExprRef].widen,
        Decoder[String].widen,
    ).reduceLeft(_ or _)
}

given Encoder[BackgroundUnion] = Encoder.instance {
    case enc0 : BackgroundExprRef => Encoder.AsObject[BackgroundExprRef].apply(enc0)
    case enc1 : String => Encoder.encodeString(enc1)
}

case class BackgroundExprRef (
    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : String
) derives Encoder.AsObject, Decoder

/**
 * The bounds calculation method to use for determining the extent of a sub-plot. One of
 * `full` (the default) or `flush`.
 *
 * - If set to `full`, the entire calculated bounds (including axes, title, and legend) will
 * be used.
 * - If set to `flush`, only the specified width and height values for the sub-view will be
 * used. The `flush` setting can be useful when attempting to place sub-plots without axes
 * or legends into a uniform grid structure.
 *
 * __Default value:__ `"full"`
 */

enum Bounds : 
    case flush
    case full
given Decoder[Bounds] = Decoder.decodeString.emapTry(x => Try(Bounds.valueOf(x) )) 
given Encoder[Bounds] = Encoder.encodeString.contramap(_.toString())

type Center = Boolean | RowColBoolean
given Decoder[Center] = {
    List[Decoder[Center]](
        Decoder[Boolean].widen,
        Decoder[RowColBoolean].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Center] = Encoder.instance {
    case enc0 : Boolean => Encoder.encodeBoolean(enc0)
    case enc1 : RowColBoolean => Encoder.AsObject[RowColBoolean].apply(enc1)
}

case class RowColBoolean (
    val column : Option[Boolean] = None,
    val row : Option[Boolean] = None
) derives Encoder.AsObject, Decoder

/**
 * A specification of the view that gets repeated.
 *
 * Any specification in Vega-Lite.
 *
 * Unit spec that can have a composite mark and row or column channels (shorthand for a
 * facet spec).
 *
 * A full layered plot specification, which may contains `encoding` and `projection`
 * properties that will be applied to underlying unit (single-view) specifications.
 *
 * Base interface for a repeat specification.
 *
 * Base interface for a facet specification.
 *
 * Base interface for a generalized concatenation specification.
 *
 * Base interface for a vertical concatenation specification.
 *
 * Base interface for a horizontal concatenation specification.
 *
 * A specification of the view that gets faceted.
 */
case class SpecSpec (
    /**
     * The alignment to apply to grid rows and columns. The supported string values are `"all"`,
     * `"each"`, and `"none"`.
     *
     * - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed
     * one after the other.
     * - For `"each"`, subviews will be aligned into a clean grid structure, but each row or
     * column may be of variable size.
     * - For `"all"`, subviews will be aligned and each row or column will be sized identically
     * based on the maximum observed size. String values for this property will be applied to
     * both grid rows and columns.
     *
     * Alternatively, an object value of the form `{"row": string, "column": string}` can be
     * used to supply different alignments for rows and columns.
     *
     * __Default value:__ `"all"`.
     */
    val align : Option[VegaLiteDSLAlign] = None,

    /**
     * The bounds calculation method to use for determining the extent of a sub-plot. One of
     * `full` (the default) or `flush`.
     *
     * - If set to `full`, the entire calculated bounds (including axes, title, and legend) will
     * be used.
     * - If set to `flush`, only the specified width and height values for the sub-view will be
     * used. The `flush` setting can be useful when attempting to place sub-plots without axes
     * or legends into a uniform grid structure.
     *
     * __Default value:__ `"full"`
     */
    val bounds : Option[Bounds] = None,

    /**
     * Boolean flag indicating if subviews should be centered relative to their respective rows
     * or columns.
     *
     * An object value of the form `{"row": boolean, "column": boolean}` can be used to supply
     * different centering values for rows and columns.
     *
     * __Default value:__ `false`
     *
     * Boolean flag indicating if subviews should be centered relative to their respective rows
     * or columns.
     *
     * __Default value:__ `false`
     */
    val center : Option[Center] = None,

    /**
     * An object describing the data source. Set to `null` to ignore the parent's data source.
     * If no data is set, it is derived from the parent.
     */
    val data : Option[URLData] = None,

    /**
     * Description of this mark for commenting purpose.
     */
    val description : Option[String] = None,

    /**
     * A key-value mapping between encoding channels and definition of fields.
     *
     * A shared key-value mapping between encoding channels and definition of fields in the
     * underlying layers.
     */
    val encoding : Option[SpecEncoding] = None,

    /**
     * The height of a visualization.
     *
     * - For a plot with a continuous y-field, height should be a number.
     * - For a plot with either a discrete y-field or no y-field, height can be either a number
     * indicating a fixed height or an object in the form of `{step: number}` defining the
     * height per discrete step. (No y-field is equivalent to having one discrete step.)
     * - To enable responsive sizing on height, it should be set to `"container"`.
     *
     * __Default value:__ Based on `config.view.continuousHeight` for a plot with a continuous
     * y-field and `config.view.discreteHeight` otherwise.
     *
     * __Note:__ For plots with [`row` and `column`
     * channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the
     * height of a single view and the `"container"` option cannot be used.
     *
     * __See also:__ [`height`](https://vega.github.io/vega-lite/docs/size.html) documentation.
     */
    val height : Option[SpecHeight] = None,

    /**
     * A string describing the mark type (one of `"bar"`, `"circle"`, `"square"`, `"tick"`,
     * `"line"`, `"area"`, `"point"`, `"rule"`, `"geoshape"`, and `"text"`) or a [mark
     * definition object](https://vega.github.io/vega-lite/docs/mark.html#mark-def).
     */
    val mark : Option[AnyMark] = None,

    /**
     * Name of the visualization for later reference.
     */
    val name : Option[String] = None,

    /**
     * An array of parameters that may either be simple variables, or more complex selections
     * that map user input to data queries.
     */
    val params : Option[Seq[SelectionParameter]] = None,

    /**
     * An object defining properties of geographic projection, which will be applied to `shape`
     * path for `"geoshape"` marks and to `latitude` and `"longitude"` channels for other
     * marks.
     *
     * An object defining properties of the geographic projection shared by underlying layers.
     */
    val projection : Option[Projection] = None,

    /**
     * Scale, axis, and legend resolutions for view composition specifications.
     */
    val resolve : Option[Resolve] = None,

    /**
     * The spacing in pixels between sub-views of the composition operator. An object of the
     * form `{"row": number, "column": number}` can be used to set different spacing values for
     * rows and columns.
     *
     * __Default value__: Depends on `"spacing"` property of [the view composition
     * configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by
     * default)
     *
     * The spacing in pixels between sub-views of the concat operator.
     *
     * __Default value__: `10`
     */
    val spacing : Option[Spacing] = None,

    /**
     * Title for the plot.
     */
    val title : Option[LayerTitle] = None,

    /**
     * An array of data transformations such as filter and new field calculation.
     */
    val transform : Option[Seq[Transform]] = None,

    /**
     * An object defining the view background's fill and stroke.
     *
     * __Default value:__ none (transparent)
     */
    val view : Option[ViewBackground] = None,

    /**
     * The width of a visualization.
     *
     * - For a plot with a continuous x-field, width should be a number.
     * - For a plot with either a discrete x-field or no x-field, width can be either a number
     * indicating a fixed width or an object in the form of `{step: number}` defining the width
     * per discrete step. (No x-field is equivalent to having one discrete step.)
     * - To enable responsive sizing on width, it should be set to `"container"`.
     *
     * __Default value:__ Based on `config.view.continuousWidth` for a plot with a continuous
     * x-field and `config.view.discreteWidth` otherwise.
     *
     * __Note:__ For plots with [`row` and `column`
     * channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the
     * width of a single view and the `"container"` option cannot be used.
     *
     * __See also:__ [`width`](https://vega.github.io/vega-lite/docs/size.html) documentation.
     */
    val width : Option[SpecHeight] = None,

    /**
     * Layer or single view specifications to be layered.
     *
     * __Note__: Specifications inside `layer` cannot use `row` and `column` channels as
     * layering facet specifications is not allowed. Instead, use the [facet
     * operator](https://vega.github.io/vega-lite/docs/facet.html) and place a layer inside a
     * facet.
     */
    val layer : Option[Seq[LayerSpec]] = None,

    /**
     * The number of columns to include in the view composition layout.
     *
     * __Default value__: `undefined` -- An infinite number of columns (a single row) will be
     * assumed. This is equivalent to `hconcat` (for `concat`) and to using the `column` channel
     * (for `facet` and `repeat`).
     *
     * __Note__:
     *
     * 1) This property is only for:
     * - the general (wrappable) `concat` operator (not `hconcat`/`vconcat`)
     * - the `facet` and `repeat` operator with one field/repetition definition (without
     * row/column nesting)
     *
     * 2) Setting the `columns` to `1` is equivalent to `vconcat` (for `concat`) and to using
     * the `row` channel (for `facet` and `repeat`).
     */
    val columns : Option[Double] = None,

    /**
     * Definition for fields to be repeated. One of: 1) An array of fields to be repeated. If
     * `"repeat"` is an array, the field can be referred to as `{"repeat": "repeat"}`. The
     * repeated views are laid out in a wrapped row. You can set the number of columns to
     * control the wrapping. 2) An object that maps `"row"` and/or `"column"` to the listed
     * fields to be repeated along the particular orientations. The objects `{"repeat": "row"}`
     * and `{"repeat": "column"}` can be used to refer to the repeated field respectively.
     */
    val repeat : Option[RepeatUnion] = None,

    /**
     * A specification of the view that gets repeated.
     *
     * A specification of the view that gets faceted.
     */
    val spec : Option[SpecSpec] = None,

    /**
     * Definition for how to facet the data. One of: 1) [a field definition for faceting the
     * plot by one field](https://vega.github.io/vega-lite/docs/facet.html#field-def) 2) [An
     * object that maps `row` and `column` channels to their field
     * definitions](https://vega.github.io/vega-lite/docs/facet.html#mapping)
     */
    val facet : Option[Facet] = None,

    /**
     * A list of views to be concatenated.
     */
    val concat : Option[Seq[Spec]] = None,

    /**
     * A list of views to be concatenated and put into a column.
     */
    val vconcat : Option[Seq[Spec]] = None,

    /**
     * A list of views to be concatenated and put into a row.
     */
    val hconcat : Option[Seq[Spec]] = None
) derives Encoder.AsObject, Decoder

/**
 * A specification of the view that gets repeated.
 *
 * Any specification in Vega-Lite.
 *
 * Unit spec that can have a composite mark and row or column channels (shorthand for a
 * facet spec).
 *
 * A full layered plot specification, which may contains `encoding` and `projection`
 * properties that will be applied to underlying unit (single-view) specifications.
 *
 * Base interface for a repeat specification.
 *
 * Base interface for a facet specification.
 *
 * Base interface for a generalized concatenation specification.
 *
 * Base interface for a vertical concatenation specification.
 *
 * Base interface for a horizontal concatenation specification.
 */
case class Spec (
    /**
     * The alignment to apply to grid rows and columns. The supported string values are `"all"`,
     * `"each"`, and `"none"`.
     *
     * - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed
     * one after the other.
     * - For `"each"`, subviews will be aligned into a clean grid structure, but each row or
     * column may be of variable size.
     * - For `"all"`, subviews will be aligned and each row or column will be sized identically
     * based on the maximum observed size. String values for this property will be applied to
     * both grid rows and columns.
     *
     * Alternatively, an object value of the form `{"row": string, "column": string}` can be
     * used to supply different alignments for rows and columns.
     *
     * __Default value:__ `"all"`.
     */
    val align : Option[VegaLiteDSLAlign] = None,

    /**
     * The bounds calculation method to use for determining the extent of a sub-plot. One of
     * `full` (the default) or `flush`.
     *
     * - If set to `full`, the entire calculated bounds (including axes, title, and legend) will
     * be used.
     * - If set to `flush`, only the specified width and height values for the sub-view will be
     * used. The `flush` setting can be useful when attempting to place sub-plots without axes
     * or legends into a uniform grid structure.
     *
     * __Default value:__ `"full"`
     */
    val bounds : Option[Bounds] = None,

    /**
     * Boolean flag indicating if subviews should be centered relative to their respective rows
     * or columns.
     *
     * An object value of the form `{"row": boolean, "column": boolean}` can be used to supply
     * different centering values for rows and columns.
     *
     * __Default value:__ `false`
     *
     * Boolean flag indicating if subviews should be centered relative to their respective rows
     * or columns.
     *
     * __Default value:__ `false`
     */
    val center : Option[Center] = None,

    /**
     * An object describing the data source. Set to `null` to ignore the parent's data source.
     * If no data is set, it is derived from the parent.
     */
    val data : Option[URLData] = None,

    /**
     * Description of this mark for commenting purpose.
     */
    val description : Option[String] = None,

    /**
     * A key-value mapping between encoding channels and definition of fields.
     *
     * A shared key-value mapping between encoding channels and definition of fields in the
     * underlying layers.
     */
    val encoding : Option[EdEncoding] = None,

    /**
     * The height of a visualization.
     *
     * - For a plot with a continuous y-field, height should be a number.
     * - For a plot with either a discrete y-field or no y-field, height can be either a number
     * indicating a fixed height or an object in the form of `{step: number}` defining the
     * height per discrete step. (No y-field is equivalent to having one discrete step.)
     * - To enable responsive sizing on height, it should be set to `"container"`.
     *
     * __Default value:__ Based on `config.view.continuousHeight` for a plot with a continuous
     * y-field and `config.view.discreteHeight` otherwise.
     *
     * __Note:__ For plots with [`row` and `column`
     * channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the
     * height of a single view and the `"container"` option cannot be used.
     *
     * __See also:__ [`height`](https://vega.github.io/vega-lite/docs/size.html) documentation.
     */
    val height : Option[SpecHeight] = None,

    /**
     * A string describing the mark type (one of `"bar"`, `"circle"`, `"square"`, `"tick"`,
     * `"line"`, `"area"`, `"point"`, `"rule"`, `"geoshape"`, and `"text"`) or a [mark
     * definition object](https://vega.github.io/vega-lite/docs/mark.html#mark-def).
     */
    val mark : Option[AnyMark] = None,

    /**
     * Name of the visualization for later reference.
     */
    val name : Option[String] = None,

    /**
     * An array of parameters that may either be simple variables, or more complex selections
     * that map user input to data queries.
     */
    val params : Option[Seq[SelectionParameter]] = None,

    /**
     * An object defining properties of geographic projection, which will be applied to `shape`
     * path for `"geoshape"` marks and to `latitude` and `"longitude"` channels for other
     * marks.
     *
     * An object defining properties of the geographic projection shared by underlying layers.
     */
    val projection : Option[Projection] = None,

    /**
     * Scale, axis, and legend resolutions for view composition specifications.
     */
    val resolve : Option[Resolve] = None,

    /**
     * The spacing in pixels between sub-views of the composition operator. An object of the
     * form `{"row": number, "column": number}` can be used to set different spacing values for
     * rows and columns.
     *
     * __Default value__: Depends on `"spacing"` property of [the view composition
     * configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by
     * default)
     *
     * The spacing in pixels between sub-views of the concat operator.
     *
     * __Default value__: `10`
     */
    val spacing : Option[Spacing] = None,

    /**
     * Title for the plot.
     */
    val title : Option[LayerTitle] = None,

    /**
     * An array of data transformations such as filter and new field calculation.
     */
    val transform : Option[Seq[Transform]] = None,

    /**
     * An object defining the view background's fill and stroke.
     *
     * __Default value:__ none (transparent)
     */
    val view : Option[ViewBackground] = None,

    /**
     * The width of a visualization.
     *
     * - For a plot with a continuous x-field, width should be a number.
     * - For a plot with either a discrete x-field or no x-field, width can be either a number
     * indicating a fixed width or an object in the form of `{step: number}` defining the width
     * per discrete step. (No x-field is equivalent to having one discrete step.)
     * - To enable responsive sizing on width, it should be set to `"container"`.
     *
     * __Default value:__ Based on `config.view.continuousWidth` for a plot with a continuous
     * x-field and `config.view.discreteWidth` otherwise.
     *
     * __Note:__ For plots with [`row` and `column`
     * channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the
     * width of a single view and the `"container"` option cannot be used.
     *
     * __See also:__ [`width`](https://vega.github.io/vega-lite/docs/size.html) documentation.
     */
    val width : Option[SpecHeight] = None,

    /**
     * Layer or single view specifications to be layered.
     *
     * __Note__: Specifications inside `layer` cannot use `row` and `column` channels as
     * layering facet specifications is not allowed. Instead, use the [facet
     * operator](https://vega.github.io/vega-lite/docs/facet.html) and place a layer inside a
     * facet.
     */
    val layer : Option[Seq[LayerSpec]] = None,

    /**
     * The number of columns to include in the view composition layout.
     *
     * __Default value__: `undefined` -- An infinite number of columns (a single row) will be
     * assumed. This is equivalent to `hconcat` (for `concat`) and to using the `column` channel
     * (for `facet` and `repeat`).
     *
     * __Note__:
     *
     * 1) This property is only for:
     * - the general (wrappable) `concat` operator (not `hconcat`/`vconcat`)
     * - the `facet` and `repeat` operator with one field/repetition definition (without
     * row/column nesting)
     *
     * 2) Setting the `columns` to `1` is equivalent to `vconcat` (for `concat`) and to using
     * the `row` channel (for `facet` and `repeat`).
     */
    val columns : Option[Double] = None,

    /**
     * Definition for fields to be repeated. One of: 1) An array of fields to be repeated. If
     * `"repeat"` is an array, the field can be referred to as `{"repeat": "repeat"}`. The
     * repeated views are laid out in a wrapped row. You can set the number of columns to
     * control the wrapping. 2) An object that maps `"row"` and/or `"column"` to the listed
     * fields to be repeated along the particular orientations. The objects `{"repeat": "row"}`
     * and `{"repeat": "column"}` can be used to refer to the repeated field respectively.
     */
    val repeat : Option[RepeatUnion] = None,

    /**
     * A specification of the view that gets repeated.
     *
     * A specification of the view that gets faceted.
     */
    val spec : Option[SpecSpec] = None,

    /**
     * Definition for how to facet the data. One of: 1) [a field definition for faceting the
     * plot by one field](https://vega.github.io/vega-lite/docs/facet.html#field-def) 2) [An
     * object that maps `row` and `column` channels to their field
     * definitions](https://vega.github.io/vega-lite/docs/facet.html#mapping)
     */
    val facet : Option[Facet] = None,

    /**
     * A list of views to be concatenated.
     */
    val concat : Option[Seq[Spec]] = None,

    /**
     * A list of views to be concatenated and put into a column.
     */
    val vconcat : Option[Seq[Spec]] = None,

    /**
     * A list of views to be concatenated and put into a row.
     */
    val hconcat : Option[Seq[Spec]] = None
) derives Encoder.AsObject, Decoder

case class URLData (
    /**
     * An object that specifies the format for parsing the data.
     */
    val format : Option[DataFormat] = None,

    /**
     * Provide a placeholder name and bind data at runtime.
     *
     * Provide a placeholder name and bind data at runtime.
     *
     * New data may change the layout but Vega does not always resize the chart. To update the
     * layout when the data updates, set
     * [autosize](https://vega.github.io/vega-lite/docs/size.html#autosize) or explicitly use
     * [view.resize](https://vega.github.io/vega/docs/api/view/#view_resize).
     */
    val name : Option[String] = None,

    /**
     * An URL from which to load the data set. Use the `format.type` property to ensure the
     * loaded data is correctly parsed.
     */
    val url : Option[String] = None,

    /**
     * The full data set, included inline. This can be an array of objects or primitive values,
     * an object, or a string. Arrays of primitive values are ingested as objects with a `data`
     * property. Strings are parsed according to the specified format type.
     */
    val values : Option[InlineDataset] = None,

    /**
     * Generate a sequence of numbers.
     */
    val sequence : Option[SequenceParams] = None,

    /**
     * Generate sphere GeoJSON data for the full globe.
     */
    val sphere : Option[SphereUnion] = None,

    /**
     * Generate graticule GeoJSON data for geographic reference lines.
     */
    val graticule : Option[Graticule] = None
) derives Encoder.AsObject, Decoder

/**
 * An object that specifies the format for parsing the data.
 */
case class DataFormat (
    /**
     * If set to `null`, disable type inference based on the spec and only use type inference
     * based on the data. Alternatively, a parsing directive object can be provided for explicit
     * data types. Each property of the object corresponds to a field name, and the value to the
     * desired data type (one of `"number"`, `"boolean"`, `"date"`, or null (do not parse the
     * field)). For example, `"parse": {"modified_on": "date"}` parses the `modified_on` field
     * in each input record a Date value.
     *
     * For `"date"`, we parse data based using JavaScript's
     * [`Date.parse()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse).
     * For Specific date formats can be provided (e.g., `{foo: "date:'%m%d%Y'"}`), using the
     * [d3-time-format syntax](https://github.com/d3/d3-time-format#locale_format). UTC date
     * format parsing is supported similarly (e.g., `{foo: "utc:'%m%d%Y'"}`). See more about
     * [UTC time](https://vega.github.io/vega-lite/docs/timeunit.html#utc)
     */
    val parse : Option[Map[String, Option[String]]] = None,

    /**
     * Type of input data: `"json"`, `"csv"`, `"tsv"`, `"dsv"`.
     *
     * __Default value:__  The default format type is determined by the extension of the file
     * URL. If no extension is detected, `"json"` will be used by default.
     */
    val `type` : Option[String] = None,

    /**
     * The delimiter between records. The delimiter must be a single character (i.e., a single
     * 16-bit code unit); so, ASCII delimiters are fine, but emoji delimiters are not.
     */
    val delimiter : Option[String] = None,

    /**
     * The JSON property containing the desired data. This parameter can be used when the loaded
     * JSON file may have surrounding structure or meta-data. For example `"property":
     * "values.features"` is equivalent to retrieving `json.values.features` from the loaded
     * JSON object.
     */
    val property : Option[String] = None,

    /**
     * The name of the TopoJSON object set to convert to a GeoJSON feature collection. For
     * example, in a map of the world, there may be an object set named `"countries"`. Using the
     * feature property, we can extract this set and generate a GeoJSON feature object for each
     * country.
     */
    val feature : Option[String] = None,

    /**
     * The name of the TopoJSON object set to convert to mesh. Similar to the `feature` option,
     * `mesh` extracts a named TopoJSON object set.  Unlike the `feature` option, the
     * corresponding geo data is returned as a single, unified mesh instance, not as individual
     * GeoJSON features. Extracting a mesh is useful for more efficiently drawing borders or
     * other geographic elements that you do not need to associate with specific regions such as
     * individual countries, states or counties.
     */
    val mesh : Option[String] = None
) derives Encoder.AsObject, Decoder

/**
 * Generate graticule GeoJSON data for geographic reference lines.
 */
type Graticule = Boolean | GraticuleParams
given Decoder[Graticule] = {
    List[Decoder[Graticule]](
        Decoder[Boolean].widen,
        Decoder[GraticuleParams].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Graticule] = Encoder.instance {
    case enc0 : Boolean => Encoder.encodeBoolean(enc0)
    case enc1 : GraticuleParams => Encoder.AsObject[GraticuleParams].apply(enc1)
}

case class GraticuleParams (
    /**
     * Sets both the major and minor extents to the same values.
     */
    val extent : Option[Seq[Seq[Double]]] = None,

    /**
     * The major extent of the graticule as a two-element array of coordinates.
     */
    val extentMajor : Option[Seq[Seq[Double]]] = None,

    /**
     * The minor extent of the graticule as a two-element array of coordinates.
     */
    val extentMinor : Option[Seq[Seq[Double]]] = None,

    /**
     * The precision of the graticule in degrees.
     *
     * __Default value:__ `2.5`
     */
    val precision : Option[Double] = None,

    /**
     * Sets both the major and minor step angles to the same values.
     */
    val step : Option[Seq[Double]] = None,

    /**
     * The major step angles of the graticule.
     *
     *
     * __Default value:__ `[90, 360]`
     */
    val stepMajor : Option[Seq[Double]] = None,

    /**
     * The minor step angles of the graticule.
     *
     * __Default value:__ `[10, 10]`
     */
    val stepMinor : Option[Seq[Double]] = None
) derives Encoder.AsObject, Decoder

/**
 * Generate a sequence of numbers.
 */
case class SequenceParams (
    /**
     * The name of the generated sequence field.
     *
     * __Default value:__ `"data"`
     */
    val as : Option[String] = None,

    /**
     * The starting value of the sequence (inclusive).
     */
    val start : Double,

    /**
     * The step value between sequence entries.
     *
     * __Default value:__ `1`
     */
    val step : Option[Double] = None,

    /**
     * The ending value of the sequence (exclusive).
     */
    val stop : Double
) derives Encoder.AsObject, Decoder

/**
 * Generate sphere GeoJSON data for the full globe.
 */
type SphereUnion = Boolean | SphereClass
given Decoder[SphereUnion] = {
    List[Decoder[SphereUnion]](
        Decoder[Boolean].widen,
        Decoder[SphereClass].widen,
    ).reduceLeft(_ or _)
}

given Encoder[SphereUnion] = Encoder.instance {
    case enc0 : Boolean => Encoder.encodeBoolean(enc0)
    case enc1 : SphereClass => Encoder.AsObject[SphereClass].apply(enc1)
}

case class SphereClass()  derives Encoder.AsObject, Decoder

/**
 * The full data set, included inline. This can be an array of objects or primitive values,
 * an object, or a string. Arrays of primitive values are ingested as objects with a `data`
 * property. Strings are parsed according to the specified format type.
 */
type InlineDataset = Map[String, Option[Json]] | String | Seq[InlineDatasetElement]
given Decoder[InlineDataset] = {
    List[Decoder[InlineDataset]](
        Decoder[Map[String, Option[Json]]].widen,
        Decoder[String].widen,
        Decoder[Seq[InlineDatasetElement]].widen,
    ).reduceLeft(_ or _)
}

given Encoder[InlineDataset] = Encoder.instance {
    case enc0 : Map[String, Option[Json]] => Encoder.encodeMap[String,Option[Json]].apply(enc0)
    case enc1 : String => Encoder.encodeString(enc1)
    case enc2 : Seq[InlineDatasetElement] => Encoder.encodeSeq[InlineDatasetElement].apply(enc2)
}

type InlineDatasetElement = Map[String, Option[Json]] | Boolean | Double | String
given Decoder[InlineDatasetElement] = {
    List[Decoder[InlineDatasetElement]](
        Decoder[Map[String, Option[Json]]].widen,
        Decoder[Boolean].widen,
        Decoder[Double].widen,
        Decoder[String].widen,
    ).reduceLeft(_ or _)
}

given Encoder[InlineDatasetElement] = Encoder.instance {
    case enc0 : Map[String, Option[Json]] => Encoder.encodeMap[String,Option[Json]].apply(enc0)
    case enc1 : Boolean => Encoder.encodeBoolean(enc1)
    case enc2 : Double => Encoder.encodeDouble(enc2)
    case enc3 : String => Encoder.encodeString(enc3)
}

/**
 * A key-value mapping between encoding channels and definition of fields.
 *
 * A shared key-value mapping between encoding channels and definition of fields in the
 * underlying layers.
 */
case class SpecEncoding (
    /**
     * Rotation angle of point and text marks.
     */
    val angle : Option[AngleClass] = None,

    /**
     * Color of the marks – either fill or stroke color based on  the `filled` property of mark
     * definition. By default, `color` represents fill color for `"area"`, `"bar"`, `"tick"`,
     * `"text"`, `"trail"`, `"circle"`, and `"square"` / stroke color for `"line"` and
     * `"point"`.
     *
     * __Default value:__ If undefined, the default color depends on [mark
     * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color`
     * property.
     *
     * _Note:_ 1) For fine-grained control over both fill and stroke colors of the marks, please
     * use the `fill` and `stroke` channels. The `fill` or `stroke` encodings have higher
     * precedence than `color`, thus may override the `color` encoding if conflicting encodings
     * are specified. 2) See the scale documentation for more information about customizing
     * [color scheme](https://vega.github.io/vega-lite/docs/scale.html#scheme).
     */
    val color : Option[ColorClass] = None,

    /**
     * A field definition for the horizontal facet of trellis plots.
     */
    val column : Option[RowColumnEncodingFieldDef] = None,

    /**
     * A text description of this mark for ARIA accessibility (SVG output only). For SVG output
     * the `"aria-label"` attribute will be set to this description.
     */
    val description : Option[DescriptionClass] = None,

    /**
     * Additional levels of detail for grouping data in aggregate views and in line, trail, and
     * area marks without mapping data to a specific visual channel.
     */
    val detail : Option[Detail] = None,

    /**
     * A field definition for the (flexible) facet of trellis plots.
     *
     * If either `row` or `column` is specified, this channel will be ignored.
     */
    val facet : Option[FacetEncodingFieldDef] = None,

    /**
     * Fill color of the marks. __Default value:__ If undefined, the default color depends on
     * [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color`
     * property.
     *
     * _Note:_ The `fill` encoding has higher precedence than `color`, thus may override the
     * `color` encoding if conflicting encodings are specified.
     */
    val fill : Option[FillClass] = None,

    /**
     * Fill opacity of the marks.
     *
     * __Default value:__ If undefined, the default opacity depends on [mark
     * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `fillOpacity`
     * property.
     */
    val fillOpacity : Option[FillOpacityClass] = None,

    /**
     * A URL to load upon mouse click.
     */
    val href : Option[HrefClass] = None,

    /**
     * A data field to use as a unique key for data binding. When a visualization’s data is
     * updated, the key value will be used to match data elements to existing mark instances.
     * Use a key channel to enable object constancy for transitions over dynamic data.
     */
    val key : Option[KeyClass] = None,

    /**
     * Latitude position of geographically projected marks.
     */
    val latitude : Option[LatitudeClass] = None,

    /**
     * Latitude-2 position for geographically projected ranged `"area"`, `"bar"`, `"rect"`, and
     * `"rule"`.
     */
    val latitude2 : Option[Latitude2Class] = None,

    /**
     * Longitude position of geographically projected marks.
     */
    val longitude : Option[LongitudeClass] = None,

    /**
     * Longitude-2 position for geographically projected ranged `"area"`, `"bar"`, `"rect"`,
     * and  `"rule"`.
     */
    val longitude2 : Option[Longitude2Class] = None,

    /**
     * Opacity of the marks.
     *
     * __Default value:__ If undefined, the default opacity depends on [mark
     * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `opacity`
     * property.
     */
    val opacity : Option[OpacityClass] = None,

    /**
     * Order of the marks.
     * - For stacked marks, this `order` channel encodes [stack
     * order](https://vega.github.io/vega-lite/docs/stack.html#order).
     * - For line and trail marks, this `order` channel encodes order of data points in the
     * lines. This can be useful for creating [a connected
     * scatterplot](https://vega.github.io/vega-lite/examples/connected_scatterplot.html).
     * Setting `order` to `{"value": null}` makes the line marks use the original order in the
     * data sources.
     * - Otherwise, this `order` channel encodes layer order of the marks.
     *
     * __Note__: In aggregate plots, `order` field should be `aggregate`d to avoid creating
     * additional aggregation grouping.
     */
    val order : Option[Order] = None,

    /**
     * The outer radius in pixels of arc marks.
     */
    val radius : Option[RadiusClass] = None,

    /**
     * The inner radius in pixels of arc marks.
     */
    val radius2 : Option[Radius2Class] = None,

    /**
     * A field definition for the vertical facet of trellis plots.
     */
    val row : Option[RowColumnEncodingFieldDef] = None,

    /**
     * Shape of the mark.
     *
     * 1. For `point` marks the supported values include:   - plotting shapes: `"circle"`,
     * `"square"`, `"cross"`, `"diamond"`, `"triangle-up"`, `"triangle-down"`,
     * `"triangle-right"`, or `"triangle-left"`.   - the line symbol `"stroke"`   - centered
     * directional shapes `"arrow"`, `"wedge"`, or `"triangle"`   - a custom [SVG path
     * string](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths) (For correct
     * sizing, custom shape paths should be defined within a square bounding box with
     * coordinates ranging from -1 to 1 along both the x and y dimensions.)
     *
     * 2. For `geoshape` marks it should be a field definition of the geojson data
     *
     * __Default value:__ If undefined, the default shape depends on [mark
     * config](https://vega.github.io/vega-lite/docs/config.html#point-config)'s `shape`
     * property. (`"circle"` if unset.)
     */
    val shape : Option[MarkPropDefStringNullTypeForShape] = None,

    /**
     * Size of the mark.
     * - For `"point"`, `"square"` and `"circle"`, – the symbol size, or pixel area of the mark.
     * - For `"bar"` and `"tick"` – the bar and tick's size.
     * - For `"text"` – the text's font size.
     * - Size is unsupported for `"line"`, `"area"`, and `"rect"`. (Use `"trail"` instead of
     * line with varying size)
     */
    val size : Option[SizeClass] = None,

    /**
     * Stroke color of the marks. __Default value:__ If undefined, the default color depends on
     * [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color`
     * property.
     *
     * _Note:_ The `stroke` encoding has higher precedence than `color`, thus may override the
     * `color` encoding if conflicting encodings are specified.
     */
    val stroke : Option[StrokeClass] = None,

    /**
     * Stroke dash of the marks.
     *
     * __Default value:__ `[1,0]` (No dash).
     */
    val strokeDash : Option[MarkPropDefNumber] = None,

    /**
     * Stroke opacity of the marks.
     *
     * __Default value:__ If undefined, the default opacity depends on [mark
     * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `strokeOpacity`
     * property.
     */
    val strokeOpacity : Option[StrokeOpacityClass] = None,

    /**
     * Stroke width of the marks.
     *
     * __Default value:__ If undefined, the default stroke width depends on [mark
     * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `strokeWidth`
     * property.
     */
    val strokeWidth : Option[StrokeWidthClass] = None,

    /**
     * Text of the `text` mark.
     */
    val text : Option[TextDef] = None,

    /**
     * - For arc marks, the arc length in radians if theta2 is not specified, otherwise the
     * start arc angle. (A value of 0 indicates up or “north”, increasing values proceed
     * clockwise.)
     *
     * - For text marks, polar coordinate angle in radians.
     */
    val theta : Option[ThetaClass] = None,

    /**
     * The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing
     * values proceed clockwise.
     */
    val theta2 : Option[Theta2Class] = None,

    /**
     * The tooltip text to show upon mouse hover. Specifying `tooltip` encoding overrides [the
     * `tooltip` property in the mark
     * definition](https://vega.github.io/vega-lite/docs/mark.html#mark-def).
     *
     * See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for
     * a detailed discussion about tooltip in Vega-Lite.
     */
    val tooltip : Option[EncodingTooltip] = None,

    /**
     * The URL of an image mark.
     */
    val url : Option[URLClass] = None,

    /**
     * X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified
     * `x2` or `width`.
     *
     * The `value` of this channel can be a number or a string `"width"` for the width of the
     * plot.
     */
    val x : Option[XClass] = None,

    /**
     * X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
     *
     * The `value` of this channel can be a number or a string `"width"` for the width of the
     * plot.
     */
    val x2 : Option[X2Class] = None,

    /**
     * Error value of x coordinates for error specified `"errorbar"` and `"errorband"`.
     */
    val xError : Option[XErrorClass] = None,

    /**
     * Secondary error value of x coordinates for error specified `"errorbar"` and `"errorband"`.
     */
    val xError2 : Option[XError2Class] = None,

    /**
     * Offset of x-position of the marks
     */
    val xOffset : Option[XOffsetClass] = None,

    /**
     * Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified
     * `y2` or `height`.
     *
     * The `value` of this channel can be a number or a string `"height"` for the height of the
     * plot.
     */
    val y : Option[YClass] = None,

    /**
     * Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
     *
     * The `value` of this channel can be a number or a string `"height"` for the height of the
     * plot.
     */
    val y2 : Option[Y2Class] = None,

    /**
     * Error value of y coordinates for error specified `"errorbar"` and `"errorband"`.
     */
    val yError : Option[YErrorClass] = None,

    /**
     * Secondary error value of y coordinates for error specified `"errorbar"` and `"errorband"`.
     */
    val yError2 : Option[YError2Class] = None,

    /**
     * Offset of y-position of the marks
     */
    val yOffset : Option[YOffsetClass] = None
) derives Encoder.AsObject, Decoder

/**
 * Rotation angle of point and text marks.
 *
 * Fill opacity of the marks.
 *
 * __Default value:__ If undefined, the default opacity depends on [mark
 * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `fillOpacity`
 * property.
 *
 * Opacity of the marks.
 *
 * __Default value:__ If undefined, the default opacity depends on [mark
 * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `opacity`
 * property.
 *
 * Size of the mark.
 * - For `"point"`, `"square"` and `"circle"`, – the symbol size, or pixel area of the mark.
 * - For `"bar"` and `"tick"` – the bar and tick's size.
 * - For `"text"` – the text's font size.
 * - Size is unsupported for `"line"`, `"area"`, and `"rect"`. (Use `"trail"` instead of
 * line with varying size)
 *
 * Stroke opacity of the marks.
 *
 * __Default value:__ If undefined, the default opacity depends on [mark
 * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `strokeOpacity`
 * property.
 *
 * Stroke width of the marks.
 *
 * __Default value:__ If undefined, the default stroke width depends on [mark
 * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `strokeWidth`
 * property.
 *
 * A FieldDef with Condition<ValueDef> {   condition: {value: ...},   field: ...,   ... }
 */
case class AngleClass (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[AngleBin] = None,

    /**
     * One or more value definition(s) with [a parameter or a test
     * predicate](https://vega.github.io/vega-lite/docs/condition.html).
     *
     * __Note:__ A field definition's `condition` property can only contain [conditional value
     * definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite
     * only allows at most one encoded field per encoding channel.
     *
     * A field definition or one or more value definition(s) with a parameter predicate.
     */
    val condition : Option[AngleCondition] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * An object defining properties of the legend. If `null`, the legend for the encoding
     * channel will be removed.
     *
     * __Default value:__ If undefined, default [legend
     * properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
     *
     * __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
     */
    val legend : Option[Legend] = None,

    /**
     * An object defining properties of the channel's scale, which is the function that
     * transforms values in the data domain (numbers, dates, strings, etc) to visual values
     * (pixels, colors, sizes) of the encoding channels.
     *
     * If `null`, the scale will be [disabled and the data value will be directly
     * encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
     *
     * __Default value:__ If undefined, default [scale
     * properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
     *
     * __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
     */
    val scale : Option[Scale] = None,

    /**
     * Sort order for the encoded field.
     *
     * For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
     * `"descending"`.
     *
     * For discrete fields, `sort` can be one of the following:
     * - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
     * JavaScript.
     * - [A string indicating an encoding channel name to sort
     * by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or
     * `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by
     * x-field, descending). This channel string is short-form of [a sort-by-encoding
     * definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For
     * example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order":
     * "descending"}`.
     * - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
     * for sorting by another field.
     * - [An array specifying the field values in preferred
     * order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
     * sort order will obey the values in the array, followed by any unspecified values in their
     * original order. For discrete time field, values in the sort array can be [date-time
     * definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
     * the values can be the month or day names (case insensitive) or their 3-letter initials
     * (e.g., `"Mon"`, `"Tue"`).
     * - `null` indicating no sort.
     *
     * __Default value:__ `"ascending"`
     *
     * __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
     *
     * __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
     */
    val sort : Option[SortUnion] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[Type] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[CornerRadius] = None
) derives Encoder.AsObject, Decoder

/**
 * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
 * `"max"`, `"count"`).
 *
 * __Default value:__ `undefined` (None)
 *
 * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
 * documentation.
 */
type Aggregate = ArgmDef | NonArgAggregateOp
given Decoder[Aggregate] = {
    List[Decoder[Aggregate]](
        Decoder[ArgmDef].widen,
        Decoder[NonArgAggregateOp].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Aggregate] = Encoder.instance {
    case enc0 : ArgmDef => Encoder.AsObject[ArgmDef].apply(enc0)
    case enc1 : NonArgAggregateOp => summon[Encoder[NonArgAggregateOp]].apply(enc1)
}

case class ArgmDef (
    val argmax : Option[String] = None,
    val argmin : Option[String] = None
) derives Encoder.AsObject, Decoder

/**
 * An [aggregate operation](https://vega.github.io/vega-lite/docs/aggregate.html#ops) to
 * perform on the field prior to sorting (e.g., `"count"`, `"mean"` and `"median"`). An
 * aggregation is required when there are multiple values of the sort field for each encoded
 * data field. The input data objects will be aggregated, grouped by the encoded data
 * field.
 *
 * For a full list of operations, please see the documentation for
 * [aggregate](https://vega.github.io/vega-lite/docs/aggregate.html#ops).
 *
 * __Default value:__ `"sum"` for stacked plots. Otherwise, `"min"`.
 */

enum NonArgAggregateOp : 
    case average
    case ci0
    case ci1
    case count
    case distinct
    case max
    case mean
    case median
    case min
    case missing
    case product
    case q1
    case q3
    case stderr
    case stdev
    case stdevp
    case sum
    case valid
    //case `values`
    case variance
    case variancep
given Decoder[NonArgAggregateOp] = Decoder.decodeString.emapTry(x => Try(NonArgAggregateOp.valueOf(x) )) 
given Encoder[NonArgAggregateOp] = Encoder.encodeString.contramap(_.toString())

type AngleBin = BinParams | Boolean | NullValue
given Decoder[AngleBin] = {
    List[Decoder[AngleBin]](
        Decoder[BinParams].widen,
        Decoder[Boolean].widen,
        Decoder[NullValue].widen,
    ).reduceLeft(_ or _)
}

given Encoder[AngleBin] = Encoder.instance {
    case enc0 : BinParams => Encoder.AsObject[BinParams].apply(enc0)
    case enc1 : Boolean => Encoder.encodeBoolean(enc1)
    case enc2 : NullValue => Encoder.encodeNone(enc2)
}

/**
 * Binning properties or boolean flag for determining whether to bin data or not.
 */
case class BinParams (
    /**
     * A value in the binned domain at which to anchor the bins, shifting the bin boundaries if
     * necessary to ensure that a boundary aligns with the anchor value.
     *
     * __Default value:__ the minimum bin extent value
     */
    val anchor : Option[Double] = None,

    /**
     * The number base to use for automatic bin determination (default is base 10).
     *
     * __Default value:__ `10`
     */
    val base : Option[Double] = None,

    /**
     * When set to `true`, Vega-Lite treats the input data as already binned.
     */
    val binned : Option[Boolean] = None,

    /**
     * Scale factors indicating allowable subdivisions. The default value is [5, 2], which
     * indicates that for base 10 numbers (the default base), the method may consider dividing
     * bin sizes by 5 and/or 2. For example, for an initial step size of 10, the method can
     * check if bin sizes of 2 (= 10/5), 5 (= 10/2), or 1 (= 10/(5*2)) might also satisfy the
     * given constraints.
     *
     * __Default value:__ `[5, 2]`
     */
    val divide : Option[Seq[Double]] = None,

    /**
     * A two-element (`[min, max]`) array indicating the range of desired bin values.
     */
    val extent : Option[BinExtent] = None,

    /**
     * Maximum number of bins.
     *
     * __Default value:__ `6` for `row`, `column` and `shape` channels; `10` for other channels
     */
    val maxbins : Option[Double] = None,

    /**
     * A minimum allowable step size (particularly useful for integer values).
     */
    val minstep : Option[Double] = None,

    /**
     * If true, attempts to make the bin boundaries use human-friendly boundaries, such as
     * multiples of ten.
     *
     * __Default value:__ `true`
     */
    val nice : Option[Boolean] = None,

    /**
     * An exact step size to use between bins.
     *
     * __Note:__ If provided, options such as maxbins will be ignored.
     */
    val step : Option[Double] = None,

    /**
     * An array of allowable step sizes to choose from.
     */
    val steps : Option[Seq[Double]] = None
) derives Encoder.AsObject, Decoder

/**
 * A two-element (`[min, max]`) array indicating the range of desired bin values.
 */
type BinExtent = BinExtentClass | Seq[Double]
given Decoder[BinExtent] = {
    List[Decoder[BinExtent]](
        Decoder[BinExtentClass].widen,
        Decoder[Seq[Double]].widen,
    ).reduceLeft(_ or _)
}

given Encoder[BinExtent] = Encoder.instance {
    case enc0 : BinExtentClass => Encoder.AsObject[BinExtentClass].apply(enc0)
    case enc1 : Seq[Double] => Encoder.encodeSeq[Double].apply(enc1)
}

case class BinExtentClass (
    /**
     * If a selection parameter is specified, the field name to extract selected values for when
     * the selection is
     * [projected](https://vega.github.io/vega-lite/docs/selection.html#project) over multiple
     * fields or encodings.
     */
    val field : Option[String] = None,

    /**
     * The name of a parameter.
     */
    val param : String,

    /**
     * If a selection parameter is specified, the encoding channel to extract selected values
     * for when a selection is
     * [projected](https://vega.github.io/vega-lite/docs/selection.html#project) over multiple
     * fields or encodings.
     */
    val encoding : Option[SingleDefUnitChannel] = None
) derives Encoder.AsObject, Decoder

/**
 * If a selection parameter is specified, the encoding channel to extract selected values
 * for when a selection is
 * [projected](https://vega.github.io/vega-lite/docs/selection.html#project) over multiple
 * fields or encodings.
 */

enum SingleDefUnitChannel : 
    case angle
    case color
    case description
    case fill
    case fillOpacity
    case href
    case key
    case latitude
    case latitude2
    case longitude
    case longitude2
    case opacity
    case radius
    case radius2
    case shape
    case size
    case stroke
    case strokeDash
    case strokeOpacity
    case strokeWidth
    case text
    case theta
    case theta2
    case url
    case x
    case x2
    case xOffset
    case y
    case y2
    case yOffset
given Decoder[SingleDefUnitChannel] = Decoder.decodeString.emapTry(x => Try(SingleDefUnitChannel.valueOf(x) )) 
given Encoder[SingleDefUnitChannel] = Encoder.encodeString.contramap(_.toString())

type AngleCondition = ConditionalPredicateValueDefNumberExprRefClass | Seq[ConditionalValueDefNumberExprRef]
given Decoder[AngleCondition] = {
    List[Decoder[AngleCondition]](
        Decoder[ConditionalPredicateValueDefNumberExprRefClass].widen,
        Decoder[Seq[ConditionalValueDefNumberExprRef]].widen,
    ).reduceLeft(_ or _)
}

given Encoder[AngleCondition] = Encoder.instance {
    case enc0 : ConditionalPredicateValueDefNumberExprRefClass => Encoder.AsObject[ConditionalPredicateValueDefNumberExprRefClass].apply(enc0)
    case enc1 : Seq[ConditionalValueDefNumberExprRef] => Encoder.encodeSeq[ConditionalValueDefNumberExprRef].apply(enc1)
}

case class ConditionalValueDefNumberExprRef (
    /**
     * Predicate for triggering the condition
     */
    val test : Option[PredicateComposition] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : CornerRadius,

    /**
     * For selection parameters, the predicate of empty selections returns true by default.
     * Override this behavior, by setting this property `empty: false`.
     */
    val empty : Option[Boolean] = None,

    /**
     * Filter using a parameter name.
     */
    val param : Option[String] = None
) derives Encoder.AsObject, Decoder

case class Predicate (
    val not : Option[PredicateComposition] = None,
    val and : Option[Seq[PredicateComposition]] = None,
    val or : Option[Seq[PredicateComposition]] = None,

    /**
     * The value that the field should be equal to.
     */
    val equal : Option[Equal] = None,

    /**
     * Field to be tested.
     */
    val field : Option[String] = None,

    /**
     * Time unit for the field to be tested.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * An array of inclusive minimum and maximum values for a field value of a data item to be
     * included in the filtered data.
     */
    val range : Option[LogicalNotPredicateRange] = None,

    /**
     * A set of values that the `field`'s value should be a member of, for a data item included
     * in the filtered data.
     */
    val oneOf : Option[Seq[SelectionInitInterval]] = None,

    /**
     * The value that the field should be less than.
     */
    val lt : Option[Lt] = None,

    /**
     * The value that the field should be greater than.
     */
    val gt : Option[Lt] = None,

    /**
     * The value that the field should be less than or equals to.
     */
    val lte : Option[Lt] = None,

    /**
     * The value that the field should be greater than or equals to.
     */
    val gte : Option[Lt] = None,

    /**
     * If set to true the field's value has to be valid, meaning both not `null` and not
     * [`NaN`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN).
     */
    val valid : Option[Boolean] = None,

    /**
     * For selection parameters, the predicate of empty selections returns true by default.
     * Override this behavior, by setting this property `empty: false`.
     */
    val empty : Option[Boolean] = None,

    /**
     * Filter using a parameter name.
     */
    val param : Option[String] = None
) derives Encoder.AsObject, Decoder

/**
 * Predicate for triggering the condition
 *
 * The `filter` property must be a predication definition, which can take one of the
 * following forms:
 *
 * 1) an [expression](https://vega.github.io/vega-lite/docs/types.html#expression) string,
 * where `datum` can be used to refer to the current data object. For example, `{filter:
 * "datum.b2 > 60"}` would make the output data includes only items that have values in the
 * field `b2` over 60.
 *
 * 2) one of the [field
 * predicates](https://vega.github.io/vega-lite/docs/predicate.html#field-predicate):
 * [`equal`](https://vega.github.io/vega-lite/docs/predicate.html#field-equal-predicate),
 * [`lt`](https://vega.github.io/vega-lite/docs/predicate.html#lt-predicate),
 * [`lte`](https://vega.github.io/vega-lite/docs/predicate.html#lte-predicate),
 * [`gt`](https://vega.github.io/vega-lite/docs/predicate.html#gt-predicate),
 * [`gte`](https://vega.github.io/vega-lite/docs/predicate.html#gte-predicate),
 * [`range`](https://vega.github.io/vega-lite/docs/predicate.html#range-predicate),
 * [`oneOf`](https://vega.github.io/vega-lite/docs/predicate.html#one-of-predicate), or
 * [`valid`](https://vega.github.io/vega-lite/docs/predicate.html#valid-predicate),
 *
 * 3) a [selection
 * predicate](https://vega.github.io/vega-lite/docs/predicate.html#selection-predicate),
 * which define the names of a selection that the data point should belong to (or a logical
 * composition of selections).
 *
 * 4) a [logical
 * composition](https://vega.github.io/vega-lite/docs/predicate.html#composition) of (1),
 * (2), or (3).
 */
type PredicateComposition = Predicate | String
given Decoder[PredicateComposition] = {
    List[Decoder[PredicateComposition]](
        Decoder[Predicate].widen,
        Decoder[String].widen,
    ).reduceLeft(_ or _)
}

given Encoder[PredicateComposition] = Encoder.instance {
    case enc0 : Predicate => Encoder.AsObject[Predicate].apply(enc0)
    case enc1 : String => Encoder.encodeString(enc1)
}

/**
 * The value that the field should be equal to.
 */
type Equal = Boolean | Double | EqualDateTime | String
given Decoder[Equal] = {
    List[Decoder[Equal]](
        Decoder[Boolean].widen,
        Decoder[Double].widen,
        Decoder[EqualDateTime].widen,
        Decoder[String].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Equal] = Encoder.instance {
    case enc0 : Boolean => Encoder.encodeBoolean(enc0)
    case enc1 : Double => Encoder.encodeDouble(enc1)
    case enc2 : EqualDateTime => Encoder.AsObject[EqualDateTime].apply(enc2)
    case enc3 : String => Encoder.encodeString(enc3)
}

/**
 * Object for defining datetime in Vega-Lite Filter. If both month and quarter are provided,
 * month has higher precedence. `day` cannot be combined with other date. We accept string
 * for month and day names.
 */
case class EqualDateTime (
    /**
     * Integer value representing the date (day of the month) from 1-31.
     */
    val date : Option[Double] = None,

    /**
     * Value representing the day of a week. This can be one of: (1) integer value -- `1`
     * represents Monday; (2) case-insensitive day name (e.g., `"Monday"`); (3)
     * case-insensitive, 3-character short day name (e.g., `"Mon"`).
     *
     * **Warning:** A DateTime definition object with `day`** should not be combined with
     * `year`, `quarter`, `month`, or `date`.
     */
    val day : Option[DayUnion] = None,

    /**
     * Integer value representing the hour of a day from 0-23.
     */
    val hours : Option[Double] = None,

    /**
     * Integer value representing the millisecond segment of time.
     */
    val milliseconds : Option[Double] = None,

    /**
     * Integer value representing the minute segment of time from 0-59.
     */
    val minutes : Option[Double] = None,

    /**
     * One of: (1) integer value representing the month from `1`-`12`. `1` represents January;
     * (2) case-insensitive month name (e.g., `"January"`); (3) case-insensitive, 3-character
     * short month name (e.g., `"Jan"`).
     */
    val month : Option[Month] = None,

    /**
     * Integer value representing the quarter of the year (from 1-4).
     */
    val quarter : Option[Double] = None,

    /**
     * Integer value representing the second segment (0-59) of a time value
     */
    val seconds : Option[Double] = None,

    /**
     * A boolean flag indicating if date time is in utc time. If false, the date time is in
     * local time
     */
    val utc : Option[Boolean] = None,

    /**
     * Integer value representing the year.
     */
    val year : Option[Double] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None
) derives Encoder.AsObject, Decoder

/**
 * Value representing the day of a week. This can be one of: (1) integer value -- `1`
 * represents Monday; (2) case-insensitive day name (e.g., `"Monday"`); (3)
 * case-insensitive, 3-character short day name (e.g., `"Mon"`).
 *
 * **Warning:** A DateTime definition object with `day`** should not be combined with
 * `year`, `quarter`, `month`, or `date`.
 */
type DayUnion = Double | String
given Decoder[DayUnion] = {
    List[Decoder[DayUnion]](
        Decoder[Double].widen,
        Decoder[String].widen,
    ).reduceLeft(_ or _)
}

given Encoder[DayUnion] = Encoder.instance {
    case enc0 : Double => Encoder.encodeDouble(enc0)
    case enc1 : String => Encoder.encodeString(enc1)
}

/**
 * One of: (1) integer value representing the month from `1`-`12`. `1` represents January;
 * (2) case-insensitive month name (e.g., `"January"`); (3) case-insensitive, 3-character
 * short month name (e.g., `"Jan"`).
 */
type Month = Double | String
type Lt = Double | GtDateTime | String
given Decoder[Lt] = {
    List[Decoder[Lt]](
        Decoder[Double].widen,
        Decoder[GtDateTime].widen,
        Decoder[String].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Lt] = Encoder.instance {
    case enc0 : Double => Encoder.encodeDouble(enc0)
    case enc1 : GtDateTime => Encoder.AsObject[GtDateTime].apply(enc1)
    case enc2 : String => Encoder.encodeString(enc2)
}

/**
 * Object for defining datetime in Vega-Lite Filter. If both month and quarter are provided,
 * month has higher precedence. `day` cannot be combined with other date. We accept string
 * for month and day names.
 */
case class GtDateTime (
    /**
     * Integer value representing the date (day of the month) from 1-31.
     */
    val date : Option[Double] = None,

    /**
     * Value representing the day of a week. This can be one of: (1) integer value -- `1`
     * represents Monday; (2) case-insensitive day name (e.g., `"Monday"`); (3)
     * case-insensitive, 3-character short day name (e.g., `"Mon"`).
     *
     * **Warning:** A DateTime definition object with `day`** should not be combined with
     * `year`, `quarter`, `month`, or `date`.
     */
    val day : Option[DayUnion] = None,

    /**
     * Integer value representing the hour of a day from 0-23.
     */
    val hours : Option[Double] = None,

    /**
     * Integer value representing the millisecond segment of time.
     */
    val milliseconds : Option[Double] = None,

    /**
     * Integer value representing the minute segment of time from 0-59.
     */
    val minutes : Option[Double] = None,

    /**
     * One of: (1) integer value representing the month from `1`-`12`. `1` represents January;
     * (2) case-insensitive month name (e.g., `"January"`); (3) case-insensitive, 3-character
     * short month name (e.g., `"Jan"`).
     */
    val month : Option[Month] = None,

    /**
     * Integer value representing the quarter of the year (from 1-4).
     */
    val quarter : Option[Double] = None,

    /**
     * Integer value representing the second segment (0-59) of a time value
     */
    val seconds : Option[Double] = None,

    /**
     * A boolean flag indicating if date time is in utc time. If false, the date time is in
     * local time
     */
    val utc : Option[Boolean] = None,

    /**
     * Integer value representing the year.
     */
    val year : Option[Double] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None
) derives Encoder.AsObject, Decoder

type SelectionInitInterval = Boolean | DateTime | Double | String
given Decoder[SelectionInitInterval] = {
    List[Decoder[SelectionInitInterval]](
        Decoder[Boolean].widen,
        Decoder[DateTime].widen,
        Decoder[Double].widen,
        Decoder[String].widen,
    ).reduceLeft(_ or _)
}

given Encoder[SelectionInitInterval] = Encoder.instance {
    case enc0 : Boolean => Encoder.encodeBoolean(enc0)
    case enc1 : DateTime => Encoder.AsObject[DateTime].apply(enc1)
    case enc2 : Double => Encoder.encodeDouble(enc2)
    case enc3 : String => Encoder.encodeString(enc3)
}

/**
 * Object for defining datetime in Vega-Lite Filter. If both month and quarter are provided,
 * month has higher precedence. `day` cannot be combined with other date. We accept string
 * for month and day names.
 */
case class DateTime (
    /**
     * Integer value representing the date (day of the month) from 1-31.
     */
    val date : Option[Double] = None,

    /**
     * Value representing the day of a week. This can be one of: (1) integer value -- `1`
     * represents Monday; (2) case-insensitive day name (e.g., `"Monday"`); (3)
     * case-insensitive, 3-character short day name (e.g., `"Mon"`).
     *
     * **Warning:** A DateTime definition object with `day`** should not be combined with
     * `year`, `quarter`, `month`, or `date`.
     */
    val day : Option[DayUnion] = None,

    /**
     * Integer value representing the hour of a day from 0-23.
     */
    val hours : Option[Double] = None,

    /**
     * Integer value representing the millisecond segment of time.
     */
    val milliseconds : Option[Double] = None,

    /**
     * Integer value representing the minute segment of time from 0-59.
     */
    val minutes : Option[Double] = None,

    /**
     * One of: (1) integer value representing the month from `1`-`12`. `1` represents January;
     * (2) case-insensitive month name (e.g., `"January"`); (3) case-insensitive, 3-character
     * short month name (e.g., `"Jan"`).
     */
    val month : Option[Month] = None,

    /**
     * Integer value representing the quarter of the year (from 1-4).
     */
    val quarter : Option[Double] = None,

    /**
     * Integer value representing the second segment (0-59) of a time value
     */
    val seconds : Option[Double] = None,

    /**
     * A boolean flag indicating if date time is in utc time. If false, the date time is in
     * local time
     */
    val utc : Option[Boolean] = None,

    /**
     * Integer value representing the year.
     */
    val year : Option[Double] = None
) derives Encoder.AsObject, Decoder

/**
 * An array of inclusive minimum and maximum values for a field value of a data item to be
 * included in the filtered data.
 */
type LogicalNotPredicateRange = BackgroundExprRef | Seq[PurpleRange]
given Decoder[LogicalNotPredicateRange] = {
    List[Decoder[LogicalNotPredicateRange]](
        Decoder[BackgroundExprRef].widen,
        Decoder[Seq[PurpleRange]].widen,
    ).reduceLeft(_ or _)
}

given Encoder[LogicalNotPredicateRange] = Encoder.instance {
    case enc0 : BackgroundExprRef => Encoder.AsObject[BackgroundExprRef].apply(enc0)
    case enc1 : Seq[PurpleRange] => Encoder.encodeSeq[PurpleRange].apply(enc1)
}

type PurpleRange = Double | RangeDateTime | NullValue
given Decoder[PurpleRange] = {
    List[Decoder[PurpleRange]](
        Decoder[Double].widen,
        Decoder[RangeDateTime].widen,
        Decoder[NullValue].widen,
    ).reduceLeft(_ or _)
}

given Encoder[PurpleRange] = Encoder.instance {
    case enc0 : Double => Encoder.encodeDouble(enc0)
    case enc1 : RangeDateTime => Encoder.AsObject[RangeDateTime].apply(enc1)
    case enc2 : NullValue => Encoder.encodeNone(enc2)
}

/**
 * Object for defining datetime in Vega-Lite Filter. If both month and quarter are provided,
 * month has higher precedence. `day` cannot be combined with other date. We accept string
 * for month and day names.
 */
case class RangeDateTime (
    /**
     * Integer value representing the date (day of the month) from 1-31.
     */
    val date : Option[Double] = None,

    /**
     * Value representing the day of a week. This can be one of: (1) integer value -- `1`
     * represents Monday; (2) case-insensitive day name (e.g., `"Monday"`); (3)
     * case-insensitive, 3-character short day name (e.g., `"Mon"`).
     *
     * **Warning:** A DateTime definition object with `day`** should not be combined with
     * `year`, `quarter`, `month`, or `date`.
     */
    val day : Option[DayUnion] = None,

    /**
     * Integer value representing the hour of a day from 0-23.
     */
    val hours : Option[Double] = None,

    /**
     * Integer value representing the millisecond segment of time.
     */
    val milliseconds : Option[Double] = None,

    /**
     * Integer value representing the minute segment of time from 0-59.
     */
    val minutes : Option[Double] = None,

    /**
     * One of: (1) integer value representing the month from `1`-`12`. `1` represents January;
     * (2) case-insensitive month name (e.g., `"January"`); (3) case-insensitive, 3-character
     * short month name (e.g., `"Jan"`).
     */
    val month : Option[Month] = None,

    /**
     * Integer value representing the quarter of the year (from 1-4).
     */
    val quarter : Option[Double] = None,

    /**
     * Integer value representing the second segment (0-59) of a time value
     */
    val seconds : Option[Double] = None,

    /**
     * A boolean flag indicating if date time is in utc time. If false, the date time is in
     * local time
     */
    val utc : Option[Boolean] = None,

    /**
     * Integer value representing the year.
     */
    val year : Option[Double] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None
) derives Encoder.AsObject, Decoder

/**
 * Time unit for the field to be tested.
 *
 * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
 * temporal field that gets casted as
 * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
 *
 * __Default value:__ `undefined` (None)
 *
 * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
 * documentation.
 *
 * The timeUnit.
 */
type TimeUnitUnion = TimeUnit | TimeUnitParams
given Decoder[TimeUnitUnion] = {
    List[Decoder[TimeUnitUnion]](
        Decoder[TimeUnit].widen,
        Decoder[TimeUnitParams].widen,
    ).reduceLeft(_ or _)
}

given Encoder[TimeUnitUnion] = Encoder.instance {
    case enc0 : TimeUnit => summon[Encoder[TimeUnit]].apply(enc0)
    case enc1 : TimeUnitParams => Encoder.AsObject[TimeUnitParams].apply(enc1)
}

case class TimeUnitParams (
    /**
     * If no `unit` is specified, maxbins is used to infer time units.
     */
    val maxbins : Option[Double] = None,

    /**
     * The number of steps between bins, in terms of the least significant unit provided.
     */
    val step : Option[Double] = None,

    /**
     * Defines how date-time values should be binned.
     */
    val unit : Option[TimeUnit] = None,

    /**
     * True to use UTC timezone. Equivalent to using a `utc` prefixed `TimeUnit`.
     */
    val utc : Option[Boolean] = None
) derives Encoder.AsObject, Decoder

/**
 * Defines how date-time values should be binned.
 */

enum TimeUnit : 
    case date
    case day
    case dayhours
    case dayhoursminutes
    case dayhoursminutesseconds
    case dayofyear
    case hours
    case hoursminutes
    case hoursminutesseconds
    case milliseconds
    case minutes
    case minutesseconds
    case month
    case monthdate
    case monthdatehours
    case monthdatehoursminutes
    case monthdatehoursminutesseconds
    case quarter
    case quartermonth
    case seconds
    case secondsmilliseconds
    case utcdate
    case utcday
    case utcdayhours
    case utcdayhoursminutes
    case utcdayhoursminutesseconds
    case utcdayofyear
    case utchours
    case utchoursminutes
    case utchoursminutesseconds
    case utcmilliseconds
    case utcminutes
    case utcminutesseconds
    case utcmonth
    case utcmonthdate
    case utcmonthdatehours
    case utcmonthdatehoursminutes
    case utcmonthdatehoursminutesseconds
    case utcquarter
    case utcquartermonth
    case utcseconds
    case utcsecondsmilliseconds
    case utcweek
    case utcweekday
    case utcweekdayhoursminutes
    case utcweekdayhoursminutesseconds
    case utcweeksdayhours
    case utcyear
    case utcyeardayofyear
    case utcyearmonth
    case utcyearmonthdate
    case utcyearmonthdatehours
    case utcyearmonthdatehoursminutes
    case utcyearmonthdatehoursminutesseconds
    case utcyearquarter
    case utcyearquartermonth
    case utcyearweek
    case utcyearweekday
    case utcyearweekdayhours
    case utcyearweekdayhoursminutes
    case utcyearweekdayhoursminutesseconds
    case week
    case weekday
    case weekdayhoursminutes
    case weekdayhoursminutesseconds
    case weeksdayhours
    case year
    case yeardayofyear
    case yearmonth
    case yearmonthdate
    case yearmonthdatehours
    case yearmonthdatehoursminutes
    case yearmonthdatehoursminutesseconds
    case yearquarter
    case yearquartermonth
    case yearweek
    case yearweekday
    case yearweekdayhours
    case yearweekdayhoursminutes
    case yearweekdayhoursminutesseconds
given Decoder[TimeUnit] = Decoder.decodeString.emapTry(x => Try(TimeUnit.valueOf(x) )) 
given Encoder[TimeUnit] = Encoder.encodeString.contramap(_.toString())

type CornerRadius = BackgroundExprRef | Double
given Decoder[CornerRadius] = {
    List[Decoder[CornerRadius]](
        Decoder[BackgroundExprRef].widen,
        Decoder[Double].widen,
    ).reduceLeft(_ or _)
}

given Encoder[CornerRadius] = Encoder.instance {
    case enc0 : BackgroundExprRef => Encoder.AsObject[BackgroundExprRef].apply(enc0)
    case enc1 : Double => Encoder.encodeDouble(enc1)
}

case class ConditionalPredicateValueDefNumberExprRefClass (
    /**
     * Predicate for triggering the condition
     */
    val test : Option[PredicateComposition] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[CornerRadius] = None,

    /**
     * For selection parameters, the predicate of empty selections returns true by default.
     * Override this behavior, by setting this property `empty: false`.
     */
    val empty : Option[Boolean] = None,

    /**
     * Filter using a parameter name.
     */
    val param : Option[String] = None,

    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[AngleBin] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * An object defining properties of the legend. If `null`, the legend for the encoding
     * channel will be removed.
     *
     * __Default value:__ If undefined, default [legend
     * properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
     *
     * __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
     */
    val legend : Option[Legend] = None,

    /**
     * An object defining properties of the channel's scale, which is the function that
     * transforms values in the data domain (numbers, dates, strings, etc) to visual values
     * (pixels, colors, sizes) of the encoding channels.
     *
     * If `null`, the scale will be [disabled and the data value will be directly
     * encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
     *
     * __Default value:__ If undefined, default [scale
     * properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
     *
     * __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
     */
    val scale : Option[Scale] = None,

    /**
     * Sort order for the encoded field.
     *
     * For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
     * `"descending"`.
     *
     * For discrete fields, `sort` can be one of the following:
     * - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
     * JavaScript.
     * - [A string indicating an encoding channel name to sort
     * by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or
     * `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by
     * x-field, descending). This channel string is short-form of [a sort-by-encoding
     * definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For
     * example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order":
     * "descending"}`.
     * - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
     * for sorting by another field.
     * - [An array specifying the field values in preferred
     * order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
     * sort order will obey the values in the array, followed by any unspecified values in their
     * original order. For discrete time field, values in the sort array can be [date-time
     * definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
     * the values can be the month or day names (case insensitive) or their 3-letter initials
     * (e.g., `"Mon"`, `"Tue"`).
     * - `null` indicating no sort.
     *
     * __Default value:__ `"ascending"`
     *
     * __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
     *
     * __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
     */
    val sort : Option[SortUnion] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[Type] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None
) derives Encoder.AsObject, Decoder

/**
 * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
 * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
 * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
 *
 * Vega-Lite automatically infers data types in many cases as discussed below. However, type
 * is required for a field if: (1) the field is not nominal and the field encoding has no
 * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
 * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
 * or `timeUnit`.
 *
 * __Default value:__
 *
 * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
 * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
 * following criteria:
 * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
 * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
 * `longitude` channel or (3) if the specified scale type is [a quantitative
 * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
 * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
 * the specified scale type is a time or utc scale
 * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
 * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
 * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
 * `order`.
 *
 * 2) For a constant value in data domain (`datum`):
 * - `"quantitative"` if the datum is a number
 * - `"nominal"` if the datum is a string
 * - `"temporal"` if the datum is [a date time
 * object](https://vega.github.io/vega-lite/docs/datetime.html)
 *
 * __Note:__
 * - Data `type` describes the semantics of the data rather than the primitive data types
 * (number, string, etc.). The same primitive data type can have different types of
 * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
 * data.
 * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
 * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
 * `1552199579097`).
 * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
 * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
 * (for using an ordinal bin
 * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
 * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
 * `type` property can be either `"temporal"` (default, for using a temporal scale) or
 * [`"ordinal"` (for using an ordinal
 * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
 * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
 * the `type` property refers to the post-aggregation data type. For example, we can
 * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
 * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
 * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
 * must have exactly the same type as their primary channels (e.g., `x`, `y`).
 *
 * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
 *
 * Data type based on level of measurement
 */

enum Type : 
    case geojson
    case nominal
    case ordinal
    case quantitative
    case temporal
given Decoder[Type] = Decoder.decodeString.emapTry(x => Try(Type.valueOf(x) )) 
given Encoder[Type] = Encoder.encodeString.contramap(_.toString())

/**
 * A constant value in data domain.
 */
type PrimitiveValue = Boolean | Double | RepeatRefClass | String | NullValue
given Decoder[PrimitiveValue] = {
    List[Decoder[PrimitiveValue]](
        Decoder[Boolean].widen,
        Decoder[Double].widen,
        Decoder[RepeatRefClass].widen,
        Decoder[String].widen,
        Decoder[NullValue].widen,
    ).reduceLeft(_ or _)
}

given Encoder[PrimitiveValue] = Encoder.instance {
    case enc0 : Boolean => Encoder.encodeBoolean(enc0)
    case enc1 : Double => Encoder.encodeDouble(enc1)
    case enc2 : RepeatRefClass => Encoder.AsObject[RepeatRefClass].apply(enc2)
    case enc3 : String => Encoder.encodeString(enc3)
    case enc4 : NullValue => Encoder.encodeNone(enc4)
}

/**
 * Object for defining datetime in Vega-Lite Filter. If both month and quarter are provided,
 * month has higher precedence. `day` cannot be combined with other date. We accept string
 * for month and day names.
 *
 * Reference to a repeated value.
 */
case class RepeatRefClass (
    /**
     * Integer value representing the date (day of the month) from 1-31.
     */
    val date : Option[Double] = None,

    /**
     * Value representing the day of a week. This can be one of: (1) integer value -- `1`
     * represents Monday; (2) case-insensitive day name (e.g., `"Monday"`); (3)
     * case-insensitive, 3-character short day name (e.g., `"Mon"`).
     *
     * **Warning:** A DateTime definition object with `day`** should not be combined with
     * `year`, `quarter`, `month`, or `date`.
     */
    val day : Option[DayUnion] = None,

    /**
     * Integer value representing the hour of a day from 0-23.
     */
    val hours : Option[Double] = None,

    /**
     * Integer value representing the millisecond segment of time.
     */
    val milliseconds : Option[Double] = None,

    /**
     * Integer value representing the minute segment of time from 0-59.
     */
    val minutes : Option[Double] = None,

    /**
     * One of: (1) integer value representing the month from `1`-`12`. `1` represents January;
     * (2) case-insensitive month name (e.g., `"January"`); (3) case-insensitive, 3-character
     * short month name (e.g., `"Jan"`).
     */
    val month : Option[Month] = None,

    /**
     * Integer value representing the quarter of the year (from 1-4).
     */
    val quarter : Option[Double] = None,

    /**
     * Integer value representing the second segment (0-59) of a time value
     */
    val seconds : Option[Double] = None,

    /**
     * A boolean flag indicating if date time is in utc time. If false, the date time is in
     * local time
     */
    val utc : Option[Boolean] = None,

    /**
     * Integer value representing the year.
     */
    val year : Option[Double] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None,

    val repeat : Option[RepeatEnum] = None
) derives Encoder.AsObject, Decoder

enum RepeatEnum : 
    case column
    case layer
    case repeat
    case row
given Decoder[RepeatEnum] = Decoder.decodeString.emapTry(x => Try(RepeatEnum.valueOf(x) )) 
given Encoder[RepeatEnum] = Encoder.encodeString.contramap(_.toString())

/**
 * __Required.__ A string defining the name of the field from which to pull a data value or
 * an object defining iterated values from the
 * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
 *
 * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
 *
 * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
 * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
 * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
 * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
 * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
 * required if `aggregate` is `count`.
 *
 * The data [field](https://vega.github.io/vega-lite/docs/field.html) to sort by.
 *
 * __Default value:__ If unspecified, defaults to the field specified in the outer data
 * reference.
 */
type Field = RepeatRef | String
given Decoder[Field] = {
    List[Decoder[Field]](
        Decoder[RepeatRef].widen,
        Decoder[String].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Field] = Encoder.instance {
    case enc0 : RepeatRef => Encoder.AsObject[RepeatRef].apply(enc0)
    case enc1 : String => Encoder.encodeString(enc1)
}

/**
 * Reference to a repeated value.
 */
case class RepeatRef (
    val repeat : RepeatEnum
) derives Encoder.AsObject, Decoder

/**
 * Properties of a legend or boolean flag for determining whether to show it.
 */
case class Legend (
    val aria : Option[Aria] = None,
    val clipHeight : Option[CornerRadius] = None,
    val columnPadding : Option[CornerRadius] = None,
    val columns : Option[CornerRadius] = None,
    val cornerRadius : Option[CornerRadius] = None,
    val description : Option[BackgroundUnion] = None,

    /**
     * The direction of the legend, one of `"vertical"` or `"horizontal"`.
     *
     * __Default value:__
     * - For top-/bottom-`orient`ed legends, `"horizontal"`
     * - For left-/right-`orient`ed legends, `"vertical"`
     * - For top/bottom-left/right-`orient`ed legends, `"horizontal"` for gradient legends and
     * `"vertical"` for symbol legends.
     */
    val direction : Option[Orientation] = None,

    val fillColor : Option[Color] = None,

    /**
     * When used with the default `"number"` and `"time"` format type, the text formatting
     * pattern for labels of guides (axes, legends, headers) and text marks.
     *
     * - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number
     * format pattern](https://github.com/d3/d3-format#locale_format).
     * - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format
     * pattern](https://github.com/d3/d3-time-format#locale_format).
     *
     * See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for
     * more examples.
     *
     * When used with a [custom
     * `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this
     * value will be passed as `format` alongside `datum.value` to the registered function.
     *
     * __Default value:__  Derived from
     * [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for
     * number format and from
     * [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time
     * format.
     */
    val format : Option[Format] = None,

    /**
     * The format type for labels. One of `"number"`, `"time"`, or a [registered custom format
     * type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).
     *
     * __Default value:__
     * - `"time"` for temporal fields and ordinal and nominal fields with `timeUnit`.
     * - `"number"` for quantitative fields as well as ordinal and nominal fields without
     * `timeUnit`.
     */
    val formatType : Option[String] = None,

    val gradientLength : Option[FontSize] = None,
    val gradientOpacity : Option[CornerRadius] = None,
    val gradientStrokeColor : Option[Color] = None,
    val gradientStrokeWidth : Option[FontSize] = None,
    val gradientThickness : Option[FontSize] = None,
    val gridAlign : Option[GridAlign] = None,
    val labelAlign : Option[TitleAlignUnion] = None,
    val labelBaseline : Option[BackgroundUnion] = None,
    val labelColor : Option[Color] = None,

    /**
     * [Vega expression](https://vega.github.io/vega/docs/expressions/) for customizing labels.
     *
     * __Note:__ The label text and value can be assessed via the `label` and `value` properties
     * of the legend's backing `datum` object.
     */
    val labelExpr : Option[String] = None,

    val labelFont : Option[BackgroundUnion] = None,
    val labelFontSize : Option[FontSize] = None,
    val labelFontStyle : Option[BackgroundUnion] = None,
    val labelFontWeight : Option[FontWeightUnion] = None,
    val labelLimit : Option[CornerRadius] = None,
    val labelOffset : Option[FontSize] = None,
    val labelOpacity : Option[CornerRadius] = None,
    val labelOverlap : Option[LabelOverlap] = None,
    val labelPadding : Option[CornerRadius] = None,
    val labelSeparation : Option[CornerRadius] = None,
    val legendX : Option[CornerRadius] = None,
    val legendY : Option[CornerRadius] = None,
    val offset : Option[CornerRadius] = None,

    /**
     * The orientation of the legend, which determines how the legend is positioned within the
     * scene. One of `"left"`, `"right"`, `"top"`, `"bottom"`, `"top-left"`, `"top-right"`,
     * `"bottom-left"`, `"bottom-right"`, `"none"`.
     *
     * __Default value:__ `"right"`
     */
    val orient : Option[LegendOrient] = None,

    val padding : Option[CornerRadius] = None,
    val rowPadding : Option[CornerRadius] = None,
    val strokeColor : Option[Color] = None,
    val symbolDash : Option[StrokeDash] = None,
    val symbolDashOffset : Option[CornerRadius] = None,
    val symbolFillColor : Option[Color] = None,
    val symbolLimit : Option[CornerRadius] = None,
    val symbolOffset : Option[CornerRadius] = None,
    val symbolOpacity : Option[CornerRadius] = None,
    val symbolSize : Option[FontSize] = None,
    val symbolStrokeColor : Option[Color] = None,
    val symbolStrokeWidth : Option[FontSize] = None,
    val symbolType : Option[BackgroundUnion] = None,
    val tickCount : Option[TickCount] = None,

    /**
     * The minimum desired step between legend ticks, in terms of scale domain values. For
     * example, a value of `1` indicates that ticks should not be less than 1 unit apart. If
     * `tickMinStep` is specified, the `tickCount` value will be adjusted, if necessary, to
     * enforce the minimum step value.
     *
     * __Default value__: `undefined`
     */
    val tickMinStep : Option[CornerRadius] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    val titleAlign : Option[TitleAlignUnion] = None,
    val titleAnchor : Option[TitleAnchorUnion] = None,
    val titleBaseline : Option[BackgroundUnion] = None,
    val titleColor : Option[Color] = None,
    val titleFont : Option[BackgroundUnion] = None,
    val titleFontSize : Option[CornerRadius] = None,
    val titleFontStyle : Option[BackgroundUnion] = None,
    val titleFontWeight : Option[FontWeightUnion] = None,
    val titleLimit : Option[FontSize] = None,
    val titleLineHeight : Option[CornerRadius] = None,
    val titleOpacity : Option[CornerRadius] = None,
    val titleOrient : Option[TitleOrientUnion] = None,
    val titlePadding : Option[CornerRadius] = None,

    /**
     * The type of the legend. Use `"symbol"` to create a discrete legend and `"gradient"` for a
     * continuous color gradient.
     *
     * __Default value:__ `"gradient"` for non-binned quantitative fields and temporal fields;
     * `"symbol"` otherwise.
     */
    val `type` : Option[LegendType] = None,

    /**
     * Explicitly set the visible legend values.
     */
    val values : Option[Values] = None,

    /**
     * A non-negative integer indicating the z-index of the legend. If zindex is 0, legend
     * should be drawn behind all chart elements. To put them in front, use zindex = 1.
     */
    val zindex : Option[Double] = None
) derives Encoder.AsObject, Decoder

type Aria = BackgroundExprRef | Boolean
given Decoder[Aria] = {
    List[Decoder[Aria]](
        Decoder[BackgroundExprRef].widen,
        Decoder[Boolean].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Aria] = Encoder.instance {
    case enc0 : BackgroundExprRef => Encoder.AsObject[BackgroundExprRef].apply(enc0)
    case enc1 : Boolean => Encoder.encodeBoolean(enc1)
}

/**
 * The orientation of a non-stacked bar, tick, area, and line charts. The value is either
 * horizontal (default) or vertical.
 * - For bar, rule and tick, this determines whether the size of the bar and tick should be
 * applied to x or y dimension.
 * - For area, this property determines the orient property of the Vega output.
 * - For line and trail marks, this property determines the sort order of the points in the
 * line if `config.sortLineBy` is not specified. For stacked charts, this is always
 * determined by the orientation of the stack; therefore explicitly specified value will be
 * ignored.
 *
 * The direction of the legend, one of `"vertical"` or `"horizontal"`.
 *
 * __Default value:__
 * - For top-/bottom-`orient`ed legends, `"horizontal"`
 * - For left-/right-`orient`ed legends, `"vertical"`
 * - For top/bottom-left/right-`orient`ed legends, `"horizontal"` for gradient legends and
 * `"vertical"` for symbol legends.
 *
 * The default direction (`"horizontal"` or `"vertical"`) for gradient legends.
 *
 * __Default value:__ `"vertical"`.
 *
 * The default direction (`"horizontal"` or `"vertical"`) for symbol legends.
 *
 * __Default value:__ `"vertical"`.
 *
 * Orientation of the box plot. This is normally automatically determined based on types of
 * fields on x and y channels. However, an explicit `orient` be specified when the
 * orientation is ambiguous.
 *
 * __Default value:__ `"vertical"`.
 *
 * Orientation of the error bar. This is normally automatically determined, but can be
 * specified when the orientation is ambiguous and cannot be automatically determined.
 *
 * Orientation of the error band. This is normally automatically determined, but can be
 * specified when the orientation is ambiguous and cannot be automatically determined.
 */

enum Orientation : 
    case horizontal
    case vertical
given Decoder[Orientation] = Decoder.decodeString.emapTry(x => Try(Orientation.valueOf(x) )) 
given Encoder[Orientation] = Encoder.encodeString.contramap(_.toString())

type Color = BackgroundExprRef | String | NullValue
given Decoder[Color] = {
    List[Decoder[Color]](
        Decoder[BackgroundExprRef].widen,
        Decoder[String].widen,
        Decoder[NullValue].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Color] = Encoder.instance {
    case enc0 : BackgroundExprRef => Encoder.AsObject[BackgroundExprRef].apply(enc0)
    case enc1 : String => Encoder.encodeString(enc1)
    case enc2 : NullValue => Encoder.encodeNone(enc2)
}

type Format = Map[String, Option[Json]] | String
given Decoder[Format] = {
    List[Decoder[Format]](
        Decoder[Map[String, Option[Json]]].widen,
        Decoder[String].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Format] = Encoder.instance {
    case enc0 : Map[String, Option[Json]] => Encoder.encodeMap[String,Option[Json]].apply(enc0)
    case enc1 : String => Encoder.encodeString(enc1)
}

type FontSize = BackgroundExprRef | Double
type GridAlign = BackgroundExprRef | LayoutAlign
given Decoder[GridAlign] = {
    List[Decoder[GridAlign]](
        Decoder[BackgroundExprRef].widen,
        Decoder[LayoutAlign].widen,
    ).reduceLeft(_ or _)
}

given Encoder[GridAlign] = Encoder.instance {
    case enc0 : BackgroundExprRef => Encoder.AsObject[BackgroundExprRef].apply(enc0)
    case enc1 : LayoutAlign => summon[Encoder[LayoutAlign]].apply(enc1)
}

/**
 * The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One
 * of `"left"`, `"right"`, `"center"`.
 *
 * __Note:__ Expression reference is *not* supported for range marks.
 *
 * Horizontal text alignment of header labels. One of `"left"`, `"center"`, or `"right"`.
 *
 * Horizontal text alignment (to the anchor) of header titles.
 */
type TitleAlignUnion = BackgroundExprRef | Align
given Decoder[TitleAlignUnion] = {
    List[Decoder[TitleAlignUnion]](
        Decoder[BackgroundExprRef].widen,
        Decoder[Align].widen,
    ).reduceLeft(_ or _)
}

given Encoder[TitleAlignUnion] = Encoder.instance {
    case enc0 : BackgroundExprRef => Encoder.AsObject[BackgroundExprRef].apply(enc0)
    case enc1 : Align => summon[Encoder[Align]].apply(enc1)
}

/**
 * Horizontal text alignment of axis tick labels, overriding the default setting for the
 * current axis orientation.
 *
 * Horizontal text alignment of axis titles.
 *
 * The alignment of the legend label, can be left, center, or right.
 *
 * Horizontal text alignment for legend titles.
 *
 * __Default value:__ `"left"`.
 *
 * Horizontal text alignment for title text. One of `"left"`, `"center"`, or `"right"`.
 */

enum Align : 
    case center
    case left
    case right
given Decoder[Align] = Decoder.decodeString.emapTry(x => Try(Align.valueOf(x) )) 
given Encoder[Align] = Encoder.encodeString.contramap(_.toString())

/**
 * The font weight of the header label.
 *
 * Font weight of the header title. This can be either a string (e.g `"bold"`, `"normal"`)
 * or a number (`100`, `200`, `300`, ..., `900` where `"normal"` = `400` and `"bold"` =
 * `700`).
 */
type FontWeightUnion = BackgroundExprRef | Double | FontWeightEnum
given Decoder[FontWeightUnion] = {
    List[Decoder[FontWeightUnion]](
        Decoder[BackgroundExprRef].widen,
        Decoder[Double].widen,
        Decoder[FontWeightEnum].widen,
    ).reduceLeft(_ or _)
}

given Encoder[FontWeightUnion] = Encoder.instance {
    case enc0 : BackgroundExprRef => Encoder.AsObject[BackgroundExprRef].apply(enc0)
    case enc1 : Double => Encoder.encodeDouble(enc1)
    case enc2 : FontWeightEnum => summon[Encoder[FontWeightEnum]].apply(enc2)
}

enum FontWeightEnum : 
    case bold
    case bolder
    case lighter
    case normal
given Decoder[FontWeightEnum] = Decoder.decodeString.emapTry(x => Try(FontWeightEnum.valueOf(x) )) 
given Encoder[FontWeightEnum] = Encoder.encodeString.contramap(_.toString())

/**
 * The strategy to use for resolving overlap of axis labels. If `false` (the default), no
 * overlap reduction is attempted. If set to `true` or `"parity"`, a strategy of removing
 * every other label is used (this works well for standard linear axes). If set to
 * `"greedy"`, a linear scan of the labels is performed, removing any labels that overlaps
 * with the last visible label (this often works better for log-scaled axes).
 *
 * __Default value:__ `true` for non-nominal fields with non-log scales; `"greedy"` for log
 * scales; otherwise `false`.
 *
 * The strategy to use for resolving overlap of labels in gradient legends. If `false`, no
 * overlap reduction is attempted. If set to `true` or `"parity"`, a strategy of removing
 * every other label is used. If set to `"greedy"`, a linear scan of the labels is
 * performed, removing any label that overlaps with the last visible label (this often works
 * better for log-scaled axes).
 *
 * __Default value:__ `"greedy"` for `log scales otherwise `true`.
 */
type LabelOverlap = BackgroundExprRef | Boolean | String
given Decoder[LabelOverlap] = {
    List[Decoder[LabelOverlap]](
        Decoder[BackgroundExprRef].widen,
        Decoder[Boolean].widen,
        Decoder[String].widen,
    ).reduceLeft(_ or _)
}

given Encoder[LabelOverlap] = Encoder.instance {
    case enc0 : BackgroundExprRef => Encoder.AsObject[BackgroundExprRef].apply(enc0)
    case enc1 : Boolean => Encoder.encodeBoolean(enc1)
    case enc2 : String => Encoder.encodeString(enc2)
}

/**
 * The type of the legend. Use `"symbol"` to create a discrete legend and `"gradient"` for a
 * continuous color gradient.
 *
 * __Default value:__ `"gradient"` for non-binned quantitative fields and temporal fields;
 * `"symbol"` otherwise.
 */

enum LegendType : 
    case gradient
    case symbol
given Decoder[LegendType] = Decoder.decodeString.emapTry(x => Try(LegendType.valueOf(x) )) 
given Encoder[LegendType] = Encoder.encodeString.contramap(_.toString())

/**
 * The orientation of the legend, which determines how the legend is positioned within the
 * scene. One of `"left"`, `"right"`, `"top"`, `"bottom"`, `"top-left"`, `"top-right"`,
 * `"bottom-left"`, `"bottom-right"`, `"none"`.
 *
 * __Default value:__ `"right"`
 */

enum LegendOrient : 
    case bottom
    case `bottom-left`
    case `bottom-right`
    case left
    case none
    case right
    case top
    case `top-left`
    case `top-right`
given Decoder[LegendOrient] = Decoder.decodeString.emapTry(x => Try(LegendOrient.valueOf(x) )) 
given Encoder[LegendOrient] = Encoder.encodeString.contramap(_.toString())

/**
 * The projection’s translation offset as a two-element array `[tx, ty]`.
 *
 * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
 * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
 * between `0` to `1` for opacity).
 */
type StrokeDash = BackgroundExprRef | Seq[Double]
given Decoder[StrokeDash] = {
    List[Decoder[StrokeDash]](
        Decoder[BackgroundExprRef].widen,
        Decoder[Seq[Double]].widen,
    ).reduceLeft(_ or _)
}

given Encoder[StrokeDash] = Encoder.instance {
    case enc0 : BackgroundExprRef => Encoder.AsObject[BackgroundExprRef].apply(enc0)
    case enc1 : Seq[Double] => Encoder.encodeSeq[Double].apply(enc1)
}

type TickCount = Double | TimeInterval | TickCountTimeIntervalStep
given Decoder[TickCount] = {
    List[Decoder[TickCount]](
        Decoder[Double].widen,
        Decoder[TimeInterval].widen,
        Decoder[TickCountTimeIntervalStep].widen,
    ).reduceLeft(_ or _)
}

given Encoder[TickCount] = Encoder.instance {
    case enc0 : Double => Encoder.encodeDouble(enc0)
    case enc1 : TimeInterval => summon[Encoder[TimeInterval]].apply(enc1)
    case enc2 : TickCountTimeIntervalStep => Encoder.AsObject[TickCountTimeIntervalStep].apply(enc2)
}

case class TickCountTimeIntervalStep (
    val interval : Option[TimeInterval] = None,
    val step : Option[Double] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None
) derives Encoder.AsObject, Decoder

enum TimeInterval : 
    case day
    case hour
    case millisecond
    case minute
    case month
    case second
    case week
    case year
given Decoder[TimeInterval] = Decoder.decodeString.emapTry(x => Try(TimeInterval.valueOf(x) )) 
given Encoder[TimeInterval] = Encoder.encodeString.contramap(_.toString())

type LegendTitle = Seq[String] | String | NullValue
given Decoder[LegendTitle] = {
    List[Decoder[LegendTitle]](
        Decoder[Seq[String]].widen,
        Decoder[String].widen,
        Decoder[NullValue].widen,
    ).reduceLeft(_ or _)
}

given Encoder[LegendTitle] = Encoder.instance {
    case enc0 : Seq[String] => Encoder.encodeSeq[String].apply(enc0)
    case enc1 : String => Encoder.encodeString(enc1)
    case enc2 : NullValue => Encoder.encodeNone(enc2)
}

type TitleAnchorUnion = BackgroundExprRef | TitleAnchorEnum | NullValue
given Decoder[TitleAnchorUnion] = {
    List[Decoder[TitleAnchorUnion]](
        Decoder[BackgroundExprRef].widen,
        Decoder[TitleAnchorEnum].widen,
        Decoder[NullValue].widen,
    ).reduceLeft(_ or _)
}

given Encoder[TitleAnchorUnion] = Encoder.instance {
    case enc0 : BackgroundExprRef => Encoder.AsObject[BackgroundExprRef].apply(enc0)
    case enc1 : TitleAnchorEnum => summon[Encoder[TitleAnchorEnum]].apply(enc1)
    case enc2 : NullValue => Encoder.encodeNone(enc2)
}

enum TitleAnchorEnum : 
    case end
    case middle
    case start
given Decoder[TitleAnchorEnum] = Decoder.decodeString.emapTry(x => Try(TitleAnchorEnum.valueOf(x) )) 
given Encoder[TitleAnchorEnum] = Encoder.encodeString.contramap(_.toString())

type TitleOrientUnion = BackgroundExprRef | Orient
given Decoder[TitleOrientUnion] = {
    List[Decoder[TitleOrientUnion]](
        Decoder[BackgroundExprRef].widen,
        Decoder[Orient].widen,
    ).reduceLeft(_ or _)
}

given Encoder[TitleOrientUnion] = Encoder.instance {
    case enc0 : BackgroundExprRef => Encoder.AsObject[BackgroundExprRef].apply(enc0)
    case enc1 : Orient => summon[Encoder[Orient]].apply(enc1)
}

/**
 * The orientation of the header label. One of `"top"`, `"bottom"`, `"left"` or `"right"`.
 *
 * Shortcut for setting both labelOrient and titleOrient.
 *
 * The orientation of the header title. One of `"top"`, `"bottom"`, `"left"` or `"right"`.
 *
 * Orientation of the legend title.
 */

enum Orient : 
    case bottom
    case left
    case right
    case top
given Decoder[Orient] = Decoder.decodeString.emapTry(x => Try(Orient.valueOf(x) )) 
given Encoder[Orient] = Encoder.encodeString.contramap(_.toString())

/**
 * Explicitly set the visible axis tick values.
 *
 * Explicitly set the visible legend values.
 */
type Values = BackgroundExprRef | Seq[SelectionInitInterval]
given Decoder[Values] = {
    List[Decoder[Values]](
        Decoder[BackgroundExprRef].widen,
        Decoder[Seq[SelectionInitInterval]].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Values] = Encoder.instance {
    case enc0 : BackgroundExprRef => Encoder.AsObject[BackgroundExprRef].apply(enc0)
    case enc1 : Seq[SelectionInitInterval] => Encoder.encodeSeq[SelectionInitInterval].apply(enc1)
}

case class Scale (
    /**
     * The alignment of the steps within the scale range.
     *
     * This value must lie in the range `[0,1]`. A value of `0.5` indicates that the steps
     * should be centered within the range. A value of `0` or `1` may be used to shift the bands
     * to one side, say to position them adjacent to an axis.
     *
     * __Default value:__ `0.5`
     */
    val align : Option[CornerRadius] = None,

    /**
     * The logarithm base of the `log` scale (default `10`).
     */
    val base : Option[CornerRadius] = None,

    /**
     * Bin boundaries can be provided to scales as either an explicit array of bin boundaries or
     * as a bin specification object. The legal values are:
     * - An [array](../types/#Array) literal of bin boundary values. For example, `[0, 5, 10,
     * 15, 20]`. The array must include both starting and ending boundaries. The previous
     * example uses five values to indicate a total of four bin intervals: [0-5), [5-10),
     * [10-15), [15-20]. Array literals may include signal references as elements.
     * - A [bin specification object](https://vega.github.io/vega-lite/docs/scale.html#bins)
     * that indicates the bin _step_ size, and optionally the _start_ and _stop_ boundaries.
     * - An array of bin boundaries over the scale domain. If provided, axes and legends will
     * use the bin boundaries to inform the choice of tick marks and text labels.
     */
    val bins : Option[ScaleBins] = None,

    /**
     * If `true`, values that exceed the data domain are clamped to either the minimum or
     * maximum range value
     *
     * __Default value:__ derived from the [scale
     * config](https://vega.github.io/vega-lite/docs/config.html#scale-config)'s `clamp` (`true`
     * by default).
     */
    val clamp : Option[Aria] = None,

    /**
     * A constant determining the slope of the symlog function around zero. Only used for
     * `symlog` scales.
     *
     * __Default value:__ `1`
     */
    val constant : Option[CornerRadius] = None,

    /**
     * Customized domain values in the form of constant values or dynamic values driven by a
     * parameter.
     *
     * 1) Constant `domain` for _quantitative_ fields can take one of the following forms:
     *
     * - A two-element array with minimum and maximum values. To create a diverging scale, this
     * two-element array can be combined with the `domainMid` property.
     * - An array with more than two entries, for [Piecewise quantitative
     * scales](https://vega.github.io/vega-lite/docs/scale.html#piecewise).
     * - A string value `"unaggregated"`, if the input field is aggregated, to indicate that the
     * domain should include the raw data values prior to the aggregation.
     *
     * 2) Constant `domain` for _temporal_ fields can be a two-element array with minimum and
     * maximum values, in the form of either timestamps or the [DateTime definition
     * objects](https://vega.github.io/vega-lite/docs/types.html#datetime).
     *
     * 3) Constant `domain` for _ordinal_ and _nominal_ fields can be an array that lists valid
     * input values.
     *
     * 4) To combine (union) specified constant domain with the field's values, `domain` can be
     * an object with a `unionWith` property that specify constant domain to be combined. For
     * example, `domain: {unionWith: [0, 100]}` for a quantitative scale means that the scale
     * domain always includes `[0, 100]`, but will include other values in the fields beyond
     * `[0, 100]`.
     *
     * 5) Domain can also takes an object defining a field or encoding of a parameter that
     * [interactively
     * determines](https://vega.github.io/vega-lite/docs/selection.html#scale-domains) the scale
     * domain.
     */
    val domain : Option[DomainUnion] = None,

    /**
     * Sets the maximum value in the scale domain, overriding the `domain` property. This
     * property is only intended for use with scales having continuous domains.
     */
    val domainMax : Option[DomainM] = None,

    /**
     * Inserts a single mid-point value into a two-element domain. The mid-point value must lie
     * between the domain minimum and maximum values. This property can be useful for setting a
     * midpoint for [diverging color
     * scales](https://vega.github.io/vega-lite/docs/scale.html#piecewise). The domainMid
     * property is only intended for use with scales supporting continuous, piecewise domains.
     */
    val domainMid : Option[CornerRadius] = None,

    /**
     * Sets the minimum value in the scale domain, overriding the domain property. This property
     * is only intended for use with scales having continuous domains.
     */
    val domainMin : Option[DomainM] = None,

    /**
     * The exponent of the `pow` scale.
     */
    val exponent : Option[CornerRadius] = None,

    /**
     * The interpolation method for range values. By default, a general interpolator for
     * numbers, dates, strings and colors (in HCL space) is used. For color ranges, this
     * property allows interpolation in alternative color spaces. Legal values include `rgb`,
     * `hsl`, `hsl-long`, `lab`, `hcl`, `hcl-long`, `cubehelix` and `cubehelix-long` ('-long'
     * variants use longer paths in polar coordinate spaces). If object-valued, this property
     * accepts an object with a string-valued _type_ property and an optional numeric _gamma_
     * property applicable to rgb and cubehelix interpolators. For more, see the [d3-interpolate
     * documentation](https://github.com/d3/d3-interpolate).
     *
     * * __Default value:__ `hcl`
     */
    val interpolate : Option[ScaleInterpolate] = None,

    /**
     * Extending the domain so that it starts and ends on nice round values. This method
     * typically modifies the scale’s domain, and may only extend the bounds to the nearest
     * round value. Nicing is useful if the domain is computed from data and may be irregular.
     * For example, for a domain of _[0.201479…, 0.996679…]_, a nice domain might be _[0.2,
     * 1.0]_.
     *
     * For quantitative scales such as linear, `nice` can be either a boolean flag or a number.
     * If `nice` is a number, it will represent a desired tick count. This allows greater
     * control over the step size used to extend the bounds, guaranteeing that the returned
     * ticks will exactly cover the domain.
     *
     * For temporal fields with time and utc scales, the `nice` value can be a string indicating
     * the desired time interval. Legal values are `"millisecond"`, `"second"`, `"minute"`,
     * `"hour"`, `"day"`, `"week"`, `"month"`, and `"year"`. Alternatively, `time` and `utc`
     * scales can accept an object-valued interval specifier of the form `{"interval": "month",
     * "step": 3}`, which includes a desired number of interval steps. Here, the domain would
     * snap to quarter (Jan, Apr, Jul, Oct) boundaries.
     *
     * __Default value:__ `true` for unbinned _quantitative_ fields without explicit domain
     * bounds; `false` otherwise.
     */
    val nice : Option[Nice] = None,

    /**
     * For _[continuous](https://vega.github.io/vega-lite/docs/scale.html#continuous)_ scales,
     * expands the scale domain to accommodate the specified number of pixels on each of the
     * scale range. The scale range must represent pixels for this parameter to function as
     * intended. Padding adjustment is performed prior to all other adjustments, including the
     * effects of the `zero`, `nice`, `domainMin`, and `domainMax` properties.
     *
     * For _[band](https://vega.github.io/vega-lite/docs/scale.html#band)_ scales, shortcut for
     * setting `paddingInner` and `paddingOuter` to the same value.
     *
     * For _[point](https://vega.github.io/vega-lite/docs/scale.html#point)_ scales, alias for
     * `paddingOuter`.
     *
     * __Default value:__ For _continuous_ scales, derived from the [scale
     * config](https://vega.github.io/vega-lite/docs/scale.html#config)'s `continuousPadding`.
     * For _band and point_ scales, see `paddingInner` and `paddingOuter`. By default, Vega-Lite
     * sets padding such that _width/height = number of unique values * step_.
     */
    val padding : Option[CornerRadius] = None,

    /**
     * The inner padding (spacing) within each band step of band scales, as a fraction of the
     * step size. This value must lie in the range [0,1].
     *
     * For point scale, this property is invalid as point scales do not have internal band
     * widths (only step sizes between bands).
     *
     * __Default value:__ derived from the [scale
     * config](https://vega.github.io/vega-lite/docs/scale.html#config)'s `bandPaddingInner`.
     */
    val paddingInner : Option[CornerRadius] = None,

    /**
     * The outer padding (spacing) at the ends of the range of band and point scales, as a
     * fraction of the step size. This value must lie in the range [0,1].
     *
     * __Default value:__ derived from the [scale
     * config](https://vega.github.io/vega-lite/docs/scale.html#config)'s `bandPaddingOuter` for
     * band scales and `pointPadding` for point scales. By default, Vega-Lite sets outer padding
     * such that _width/height = number of unique values * step_.
     */
    val paddingOuter : Option[CornerRadius] = None,

    /**
     * The range of the scale. One of:
     *
     * - A string indicating a [pre-defined named scale
     * range](https://vega.github.io/vega-lite/docs/scale.html#range-config) (e.g., example,
     * `"symbol"`, or `"diverging"`).
     *
     * - For [continuous scales](https://vega.github.io/vega-lite/docs/scale.html#continuous),
     * two-element array indicating  minimum and maximum values, or an array with more than two
     * entries for specifying a [piecewise
     * scale](https://vega.github.io/vega-lite/docs/scale.html#piecewise).
     *
     * - For [discrete](https://vega.github.io/vega-lite/docs/scale.html#discrete) and
     * [discretizing](https://vega.github.io/vega-lite/docs/scale.html#discretizing) scales, an
     * array of desired output values or an object with a `field` property representing the
     * range values.  For example, if a field `color` contains CSS color names, we can set
     * `range` to `{field: "color"}`.
     *
     * __Notes:__
     *
     * 1) For color scales you can also specify a color
     * [`scheme`](https://vega.github.io/vega-lite/docs/scale.html#scheme) instead of `range`.
     *
     * 2) Any directly specified `range` for `x` and `y` channels will be ignored. Range can be
     * customized via the view's corresponding
     * [size](https://vega.github.io/vega-lite/docs/size.html) (`width` and `height`).
     */
    val range : Option[ScaleRange] = None,

    /**
     * Sets the maximum value in the scale range, overriding the `range` property or the default
     * range. This property is only intended for use with scales having continuous ranges.
     */
    val rangeMax : Option[X] = None,

    /**
     * Sets the minimum value in the scale range, overriding the `range` property or the default
     * range. This property is only intended for use with scales having continuous ranges.
     */
    val rangeMin : Option[X] = None,

    /**
     * If true, reverses the order of the scale range. __Default value:__ `false`.
     */
    val reverse : Option[Aria] = None,

    /**
     * If `true`, rounds numeric output values to integers. This can be helpful for snapping to
     * the pixel grid.
     *
     * __Default value:__ `false`.
     */
    val round : Option[Aria] = None,

    /**
     * A string indicating a color
     * [scheme](https://vega.github.io/vega-lite/docs/scale.html#scheme) name (e.g.,
     * `"category10"` or `"blues"`) or a [scheme parameter
     * object](https://vega.github.io/vega-lite/docs/scale.html#scheme-params).
     *
     * Discrete color schemes may be used with
     * [discrete](https://vega.github.io/vega-lite/docs/scale.html#discrete) or
     * [discretizing](https://vega.github.io/vega-lite/docs/scale.html#discretizing) scales.
     * Continuous color schemes are intended for use with color scales.
     *
     * For the full list of supported schemes, please refer to the [Vega
     * Scheme](https://vega.github.io/vega/docs/schemes/#reference) reference.
     */
    val scheme : Option[Scheme] = None,

    /**
     * The type of scale. Vega-Lite supports the following categories of scale types:
     *
     * 1) [**Continuous Scales**](https://vega.github.io/vega-lite/docs/scale.html#continuous)
     * -- mapping continuous domains to continuous output ranges
     * ([`"linear"`](https://vega.github.io/vega-lite/docs/scale.html#linear),
     * [`"pow"`](https://vega.github.io/vega-lite/docs/scale.html#pow),
     * [`"sqrt"`](https://vega.github.io/vega-lite/docs/scale.html#sqrt),
     * [`"symlog"`](https://vega.github.io/vega-lite/docs/scale.html#symlog),
     * [`"log"`](https://vega.github.io/vega-lite/docs/scale.html#log),
     * [`"time"`](https://vega.github.io/vega-lite/docs/scale.html#time),
     * [`"utc"`](https://vega.github.io/vega-lite/docs/scale.html#utc).
     *
     * 2) [**Discrete Scales**](https://vega.github.io/vega-lite/docs/scale.html#discrete) --
     * mapping discrete domains to discrete
     * ([`"ordinal"`](https://vega.github.io/vega-lite/docs/scale.html#ordinal)) or continuous
     * ([`"band"`](https://vega.github.io/vega-lite/docs/scale.html#band) and
     * [`"point"`](https://vega.github.io/vega-lite/docs/scale.html#point)) output ranges.
     *
     * 3) [**Discretizing
     * Scales**](https://vega.github.io/vega-lite/docs/scale.html#discretizing) -- mapping
     * continuous domains to discrete output ranges
     * [`"bin-ordinal"`](https://vega.github.io/vega-lite/docs/scale.html#bin-ordinal),
     * [`"quantile"`](https://vega.github.io/vega-lite/docs/scale.html#quantile),
     * [`"quantize"`](https://vega.github.io/vega-lite/docs/scale.html#quantize) and
     * [`"threshold"`](https://vega.github.io/vega-lite/docs/scale.html#threshold).
     *
     * __Default value:__ please see the [scale type
     * table](https://vega.github.io/vega-lite/docs/scale.html#type).
     */
    val `type` : Option[ScaleType] = None,

    /**
     * If `true`, ensures that a zero baseline value is included in the scale domain.
     *
     * __Default value:__ `true` for x and y channels if the quantitative field is not binned
     * and no custom `domain` is provided; `false` otherwise.
     *
     * __Note:__ Log, time, and utc scales do not support `zero`.
     */
    val zero : Option[Aria] = None
) derives Encoder.AsObject, Decoder

/**
 * Bin boundaries can be provided to scales as either an explicit array of bin boundaries or
 * as a bin specification object. The legal values are:
 * - An [array](../types/#Array) literal of bin boundary values. For example, `[0, 5, 10,
 * 15, 20]`. The array must include both starting and ending boundaries. The previous
 * example uses five values to indicate a total of four bin intervals: [0-5), [5-10),
 * [10-15), [15-20]. Array literals may include signal references as elements.
 * - A [bin specification object](https://vega.github.io/vega-lite/docs/scale.html#bins)
 * that indicates the bin _step_ size, and optionally the _start_ and _stop_ boundaries.
 * - An array of bin boundaries over the scale domain. If provided, axes and legends will
 * use the bin boundaries to inform the choice of tick marks and text labels.
 */
type ScaleBins = Seq[Double] | ScaleBinParams
given Decoder[ScaleBins] = {
    List[Decoder[ScaleBins]](
        Decoder[Seq[Double]].widen,
        Decoder[ScaleBinParams].widen,
    ).reduceLeft(_ or _)
}

given Encoder[ScaleBins] = Encoder.instance {
    case enc0 : Seq[Double] => Encoder.encodeSeq[Double].apply(enc0)
    case enc1 : ScaleBinParams => Encoder.AsObject[ScaleBinParams].apply(enc1)
}

case class ScaleBinParams (
    /**
     * The starting (lowest-valued) bin boundary.
     *
     * __Default value:__ The lowest value of the scale domain will be used.
     */
    val start : Option[Double] = None,

    /**
     * The step size defining the bin interval width.
     */
    val step : Double,

    /**
     * The stopping (highest-valued) bin boundary.
     *
     * __Default value:__ The highest value of the scale domain will be used.
     */
    val stop : Option[Double] = None
) derives Encoder.AsObject, Decoder

/**
 * Customized domain values in the form of constant values or dynamic values driven by a
 * parameter.
 *
 * 1) Constant `domain` for _quantitative_ fields can take one of the following forms:
 *
 * - A two-element array with minimum and maximum values. To create a diverging scale, this
 * two-element array can be combined with the `domainMid` property.
 * - An array with more than two entries, for [Piecewise quantitative
 * scales](https://vega.github.io/vega-lite/docs/scale.html#piecewise).
 * - A string value `"unaggregated"`, if the input field is aggregated, to indicate that the
 * domain should include the raw data values prior to the aggregation.
 *
 * 2) Constant `domain` for _temporal_ fields can be a two-element array with minimum and
 * maximum values, in the form of either timestamps or the [DateTime definition
 * objects](https://vega.github.io/vega-lite/docs/types.html#datetime).
 *
 * 3) Constant `domain` for _ordinal_ and _nominal_ fields can be an array that lists valid
 * input values.
 *
 * 4) To combine (union) specified constant domain with the field's values, `domain` can be
 * an object with a `unionWith` property that specify constant domain to be combined. For
 * example, `domain: {unionWith: [0, 100]}` for a quantitative scale means that the scale
 * domain always includes `[0, 100]`, but will include other values in the fields beyond
 * `[0, 100]`.
 *
 * 5) Domain can also takes an object defining a field or encoding of a parameter that
 * [interactively
 * determines](https://vega.github.io/vega-lite/docs/selection.html#scale-domains) the scale
 * domain.
 */
type DomainUnion = DomainUnionWith | String | Seq[Domain]
given Decoder[DomainUnion] = {
    List[Decoder[DomainUnion]](
        Decoder[DomainUnionWith].widen,
        Decoder[String].widen,
        Decoder[Seq[Domain]].widen,
    ).reduceLeft(_ or _)
}

given Encoder[DomainUnion] = Encoder.instance {
    case enc0 : DomainUnionWith => Encoder.AsObject[DomainUnionWith].apply(enc0)
    case enc1 : String => Encoder.encodeString(enc1)
    case enc2 : Seq[Domain] => Encoder.encodeSeq[Domain].apply(enc2)
}

type Domain = Boolean | DomainDateTime | Double | String | NullValue
given Decoder[Domain] = {
    List[Decoder[Domain]](
        Decoder[Boolean].widen,
        Decoder[DomainDateTime].widen,
        Decoder[Double].widen,
        Decoder[String].widen,
        Decoder[NullValue].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Domain] = Encoder.instance {
    case enc0 : Boolean => Encoder.encodeBoolean(enc0)
    case enc1 : DomainDateTime => Encoder.AsObject[DomainDateTime].apply(enc1)
    case enc2 : Double => Encoder.encodeDouble(enc2)
    case enc3 : String => Encoder.encodeString(enc3)
    case enc4 : NullValue => Encoder.encodeNone(enc4)
}

/**
 * Object for defining datetime in Vega-Lite Filter. If both month and quarter are provided,
 * month has higher precedence. `day` cannot be combined with other date. We accept string
 * for month and day names.
 */
case class DomainDateTime (
    /**
     * Integer value representing the date (day of the month) from 1-31.
     */
    val date : Option[Double] = None,

    /**
     * Value representing the day of a week. This can be one of: (1) integer value -- `1`
     * represents Monday; (2) case-insensitive day name (e.g., `"Monday"`); (3)
     * case-insensitive, 3-character short day name (e.g., `"Mon"`).
     *
     * **Warning:** A DateTime definition object with `day`** should not be combined with
     * `year`, `quarter`, `month`, or `date`.
     */
    val day : Option[DayUnion] = None,

    /**
     * Integer value representing the hour of a day from 0-23.
     */
    val hours : Option[Double] = None,

    /**
     * Integer value representing the millisecond segment of time.
     */
    val milliseconds : Option[Double] = None,

    /**
     * Integer value representing the minute segment of time from 0-59.
     */
    val minutes : Option[Double] = None,

    /**
     * One of: (1) integer value representing the month from `1`-`12`. `1` represents January;
     * (2) case-insensitive month name (e.g., `"January"`); (3) case-insensitive, 3-character
     * short month name (e.g., `"Jan"`).
     */
    val month : Option[Month] = None,

    /**
     * Integer value representing the quarter of the year (from 1-4).
     */
    val quarter : Option[Double] = None,

    /**
     * Integer value representing the second segment (0-59) of a time value
     */
    val seconds : Option[Double] = None,

    /**
     * A boolean flag indicating if date time is in utc time. If false, the date time is in
     * local time
     */
    val utc : Option[Boolean] = None,

    /**
     * Integer value representing the year.
     */
    val year : Option[Double] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None
) derives Encoder.AsObject, Decoder

case class DomainUnionWith (
    /**
     * If a selection parameter is specified, the field name to extract selected values for when
     * the selection is
     * [projected](https://vega.github.io/vega-lite/docs/selection.html#project) over multiple
     * fields or encodings.
     */
    val field : Option[String] = None,

    /**
     * The name of a parameter.
     */
    val param : Option[String] = None,

    /**
     * If a selection parameter is specified, the encoding channel to extract selected values
     * for when a selection is
     * [projected](https://vega.github.io/vega-lite/docs/selection.html#project) over multiple
     * fields or encodings.
     */
    val encoding : Option[SingleDefUnitChannel] = None,

    /**
     * Customized domain values to be union with the field's values or explicitly defined
     * domain. Should be an array of valid scale domain values.
     */
    val unionWith : Option[Seq[SelectionInitInterval]] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None
) derives Encoder.AsObject, Decoder

type DomainM = DomainMaxDateTime | Double
given Decoder[DomainM] = {
    List[Decoder[DomainM]](
        Decoder[DomainMaxDateTime].widen,
        Decoder[Double].widen,
    ).reduceLeft(_ or _)
}

given Encoder[DomainM] = Encoder.instance {
    case enc0 : DomainMaxDateTime => Encoder.AsObject[DomainMaxDateTime].apply(enc0)
    case enc1 : Double => Encoder.encodeDouble(enc1)
}

/**
 * Object for defining datetime in Vega-Lite Filter. If both month and quarter are provided,
 * month has higher precedence. `day` cannot be combined with other date. We accept string
 * for month and day names.
 */
case class DomainMaxDateTime (
    /**
     * Integer value representing the date (day of the month) from 1-31.
     */
    val date : Option[Double] = None,

    /**
     * Value representing the day of a week. This can be one of: (1) integer value -- `1`
     * represents Monday; (2) case-insensitive day name (e.g., `"Monday"`); (3)
     * case-insensitive, 3-character short day name (e.g., `"Mon"`).
     *
     * **Warning:** A DateTime definition object with `day`** should not be combined with
     * `year`, `quarter`, `month`, or `date`.
     */
    val day : Option[DayUnion] = None,

    /**
     * Integer value representing the hour of a day from 0-23.
     */
    val hours : Option[Double] = None,

    /**
     * Integer value representing the millisecond segment of time.
     */
    val milliseconds : Option[Double] = None,

    /**
     * Integer value representing the minute segment of time from 0-59.
     */
    val minutes : Option[Double] = None,

    /**
     * One of: (1) integer value representing the month from `1`-`12`. `1` represents January;
     * (2) case-insensitive month name (e.g., `"January"`); (3) case-insensitive, 3-character
     * short month name (e.g., `"Jan"`).
     */
    val month : Option[Month] = None,

    /**
     * Integer value representing the quarter of the year (from 1-4).
     */
    val quarter : Option[Double] = None,

    /**
     * Integer value representing the second segment (0-59) of a time value
     */
    val seconds : Option[Double] = None,

    /**
     * A boolean flag indicating if date time is in utc time. If false, the date time is in
     * local time
     */
    val utc : Option[Boolean] = None,

    /**
     * Integer value representing the year.
     */
    val year : Option[Double] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None
) derives Encoder.AsObject, Decoder

/**
 * The interpolation method for range values. By default, a general interpolator for
 * numbers, dates, strings and colors (in HCL space) is used. For color ranges, this
 * property allows interpolation in alternative color spaces. Legal values include `rgb`,
 * `hsl`, `hsl-long`, `lab`, `hcl`, `hcl-long`, `cubehelix` and `cubehelix-long` ('-long'
 * variants use longer paths in polar coordinate spaces). If object-valued, this property
 * accepts an object with a string-valued _type_ property and an optional numeric _gamma_
 * property applicable to rgb and cubehelix interpolators. For more, see the [d3-interpolate
 * documentation](https://github.com/d3/d3-interpolate).
 *
 * * __Default value:__ `hcl`
 */
type ScaleInterpolate = ScaleInterpolateEnum | ScaleInterpolateParamsClass
given Decoder[ScaleInterpolate] = {
    List[Decoder[ScaleInterpolate]](
        Decoder[ScaleInterpolateEnum].widen,
        Decoder[ScaleInterpolateParamsClass].widen,
    ).reduceLeft(_ or _)
}

given Encoder[ScaleInterpolate] = Encoder.instance {
    case enc0 : ScaleInterpolateEnum => summon[Encoder[ScaleInterpolateEnum]].apply(enc0)
    case enc1 : ScaleInterpolateParamsClass => Encoder.AsObject[ScaleInterpolateParamsClass].apply(enc1)
}

case class ScaleInterpolateParamsClass (
    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None,

    val gamma : Option[Double] = None,
    val `type` : Option[ExprRefType] = None
) derives Encoder.AsObject, Decoder

enum ExprRefType : 
    case cubehelix
    case `cubehelix-long`
    case rgb
given Decoder[ExprRefType] = Decoder.decodeString.emapTry(x => Try(ExprRefType.valueOf(x) )) 
given Encoder[ExprRefType] = Encoder.encodeString.contramap(_.toString())

enum ScaleInterpolateEnum : 
    case cubehelix
    case `cubehelix-long`
    case hcl
    case `hcl-long`
    case hsl
    case `hsl-long`
    case lab
    case rgb
given Decoder[ScaleInterpolateEnum] = Decoder.decodeString.emapTry(x => Try(ScaleInterpolateEnum.valueOf(x) )) 
given Encoder[ScaleInterpolateEnum] = Encoder.encodeString.contramap(_.toString())

/**
 * Extending the domain so that it starts and ends on nice round values. This method
 * typically modifies the scale’s domain, and may only extend the bounds to the nearest
 * round value. Nicing is useful if the domain is computed from data and may be irregular.
 * For example, for a domain of _[0.201479…, 0.996679…]_, a nice domain might be _[0.2,
 * 1.0]_.
 *
 * For quantitative scales such as linear, `nice` can be either a boolean flag or a number.
 * If `nice` is a number, it will represent a desired tick count. This allows greater
 * control over the step size used to extend the bounds, guaranteeing that the returned
 * ticks will exactly cover the domain.
 *
 * For temporal fields with time and utc scales, the `nice` value can be a string indicating
 * the desired time interval. Legal values are `"millisecond"`, `"second"`, `"minute"`,
 * `"hour"`, `"day"`, `"week"`, `"month"`, and `"year"`. Alternatively, `time` and `utc`
 * scales can accept an object-valued interval specifier of the form `{"interval": "month",
 * "step": 3}`, which includes a desired number of interval steps. Here, the domain would
 * snap to quarter (Jan, Apr, Jul, Oct) boundaries.
 *
 * __Default value:__ `true` for unbinned _quantitative_ fields without explicit domain
 * bounds; `false` otherwise.
 */
type Nice = Boolean | Double | TimeInterval | NiceTimeIntervalStep
given Decoder[Nice] = {
    List[Decoder[Nice]](
        Decoder[Boolean].widen,
        Decoder[Double].widen,
        Decoder[TimeInterval].widen,
        Decoder[NiceTimeIntervalStep].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Nice] = Encoder.instance {
    case enc0 : Boolean => Encoder.encodeBoolean(enc0)
    case enc1 : Double => Encoder.encodeDouble(enc1)
    case enc2 : TimeInterval => summon[Encoder[TimeInterval]].apply(enc2)
    case enc3 : NiceTimeIntervalStep => Encoder.AsObject[NiceTimeIntervalStep].apply(enc3)
}

case class NiceTimeIntervalStep (
    val interval : Option[TimeInterval] = None,
    val step : Option[Double] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None
) derives Encoder.AsObject, Decoder

/**
 * The range of the scale. One of:
 *
 * - A string indicating a [pre-defined named scale
 * range](https://vega.github.io/vega-lite/docs/scale.html#range-config) (e.g., example,
 * `"symbol"`, or `"diverging"`).
 *
 * - For [continuous scales](https://vega.github.io/vega-lite/docs/scale.html#continuous),
 * two-element array indicating  minimum and maximum values, or an array with more than two
 * entries for specifying a [piecewise
 * scale](https://vega.github.io/vega-lite/docs/scale.html#piecewise).
 *
 * - For [discrete](https://vega.github.io/vega-lite/docs/scale.html#discrete) and
 * [discretizing](https://vega.github.io/vega-lite/docs/scale.html#discretizing) scales, an
 * array of desired output values or an object with a `field` property representing the
 * range values.  For example, if a field `color` contains CSS color names, we can set
 * `range` to `{field: "color"}`.
 *
 * __Notes:__
 *
 * 1) For color scales you can also specify a color
 * [`scheme`](https://vega.github.io/vega-lite/docs/scale.html#scheme) instead of `range`.
 *
 * 2) Any directly specified `range` for `x` and `y` channels will be ignored. Range can be
 * customized via the view's corresponding
 * [size](https://vega.github.io/vega-lite/docs/size.html) (`width` and `height`).
 */
type ScaleRange = RangeEnum | FieldRange | Seq[FluffyRange]
given Decoder[ScaleRange] = {
    List[Decoder[ScaleRange]](
        Decoder[RangeEnum].widen,
        Decoder[FieldRange].widen,
        Decoder[Seq[FluffyRange]].widen,
    ).reduceLeft(_ or _)
}

given Encoder[ScaleRange] = Encoder.instance {
    case enc0 : RangeEnum => summon[Encoder[RangeEnum]].apply(enc0)
    case enc1 : FieldRange => Encoder.AsObject[FieldRange].apply(enc1)
    case enc2 : Seq[FluffyRange] => Encoder.encodeSeq[FluffyRange].apply(enc2)
}

type FluffyRange = BackgroundExprRef | Seq[Double] | Double | String
given Decoder[FluffyRange] = {
    List[Decoder[FluffyRange]](
        Decoder[BackgroundExprRef].widen,
        Decoder[Seq[Double]].widen,
        Decoder[Double].widen,
        Decoder[String].widen,
    ).reduceLeft(_ or _)
}

given Encoder[FluffyRange] = Encoder.instance {
    case enc0 : BackgroundExprRef => Encoder.AsObject[BackgroundExprRef].apply(enc0)
    case enc1 : Seq[Double] => Encoder.encodeSeq[Double].apply(enc1)
    case enc2 : Double => Encoder.encodeDouble(enc2)
    case enc3 : String => Encoder.encodeString(enc3)
}

case class FieldRange (
    val field : String
) derives Encoder.AsObject, Decoder

enum RangeEnum : 
    case category
    case diverging
    case heatmap
    case height
    case ordinal
    case ramp
    case symbol
    case width
given Decoder[RangeEnum] = Decoder.decodeString.emapTry(x => Try(RangeEnum.valueOf(x) )) 
given Encoder[RangeEnum] = Encoder.encodeString.contramap(_.toString())

type X = BackgroundExprRef | Double | String
given Decoder[X] = {
    List[Decoder[X]](
        Decoder[BackgroundExprRef].widen,
        Decoder[Double].widen,
        Decoder[String].widen,
    ).reduceLeft(_ or _)
}

given Encoder[X] = Encoder.instance {
    case enc0 : BackgroundExprRef => Encoder.AsObject[BackgroundExprRef].apply(enc0)
    case enc1 : Double => Encoder.encodeDouble(enc1)
    case enc2 : String => Encoder.encodeString(enc2)
}

/**
 * The type of scale. Vega-Lite supports the following categories of scale types:
 *
 * 1) [**Continuous Scales**](https://vega.github.io/vega-lite/docs/scale.html#continuous)
 * -- mapping continuous domains to continuous output ranges
 * ([`"linear"`](https://vega.github.io/vega-lite/docs/scale.html#linear),
 * [`"pow"`](https://vega.github.io/vega-lite/docs/scale.html#pow),
 * [`"sqrt"`](https://vega.github.io/vega-lite/docs/scale.html#sqrt),
 * [`"symlog"`](https://vega.github.io/vega-lite/docs/scale.html#symlog),
 * [`"log"`](https://vega.github.io/vega-lite/docs/scale.html#log),
 * [`"time"`](https://vega.github.io/vega-lite/docs/scale.html#time),
 * [`"utc"`](https://vega.github.io/vega-lite/docs/scale.html#utc).
 *
 * 2) [**Discrete Scales**](https://vega.github.io/vega-lite/docs/scale.html#discrete) --
 * mapping discrete domains to discrete
 * ([`"ordinal"`](https://vega.github.io/vega-lite/docs/scale.html#ordinal)) or continuous
 * ([`"band"`](https://vega.github.io/vega-lite/docs/scale.html#band) and
 * [`"point"`](https://vega.github.io/vega-lite/docs/scale.html#point)) output ranges.
 *
 * 3) [**Discretizing
 * Scales**](https://vega.github.io/vega-lite/docs/scale.html#discretizing) -- mapping
 * continuous domains to discrete output ranges
 * [`"bin-ordinal"`](https://vega.github.io/vega-lite/docs/scale.html#bin-ordinal),
 * [`"quantile"`](https://vega.github.io/vega-lite/docs/scale.html#quantile),
 * [`"quantize"`](https://vega.github.io/vega-lite/docs/scale.html#quantize) and
 * [`"threshold"`](https://vega.github.io/vega-lite/docs/scale.html#threshold).
 *
 * __Default value:__ please see the [scale type
 * table](https://vega.github.io/vega-lite/docs/scale.html#type).
 */

enum ScaleType : 
    case band
    case `bin-ordinal`
    case identity
    case linear
    case log
    case ordinal
    case point
    case pow
    case quantile
    case quantize
    case sequential
    case sqrt
    case symlog
    case threshold
    case time
    case utc
given Decoder[ScaleType] = Decoder.decodeString.emapTry(x => Try(ScaleType.valueOf(x) )) 
given Encoder[ScaleType] = Encoder.encodeString.contramap(_.toString())

/**
 * A string indicating a color
 * [scheme](https://vega.github.io/vega-lite/docs/scale.html#scheme) name (e.g.,
 * `"category10"` or `"blues"`) or a [scheme parameter
 * object](https://vega.github.io/vega-lite/docs/scale.html#scheme-params).
 *
 * Discrete color schemes may be used with
 * [discrete](https://vega.github.io/vega-lite/docs/scale.html#discrete) or
 * [discretizing](https://vega.github.io/vega-lite/docs/scale.html#discretizing) scales.
 * Continuous color schemes are intended for use with color scales.
 *
 * For the full list of supported schemes, please refer to the [Vega
 * Scheme](https://vega.github.io/vega/docs/schemes/#reference) reference.
 */
type Scheme = SchemeParams | String
given Decoder[Scheme] = {
    List[Decoder[Scheme]](
        Decoder[SchemeParams].widen,
        Decoder[String].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Scheme] = Encoder.instance {
    case enc0 : SchemeParams => Encoder.AsObject[SchemeParams].apply(enc0)
    case enc1 : String => Encoder.encodeString(enc1)
}

case class SchemeParams (
    /**
     * The number of colors to use in the scheme. This can be useful for scale types such as
     * `"quantize"`, which use the length of the scale range to determine the number of discrete
     * bins for the scale domain.
     */
    val count : Option[Double] = None,

    /**
     * The extent of the color range to use. For example `[0.2, 1]` will rescale the color
     * scheme such that color values in the range _[0, 0.2)_ are excluded from the scheme.
     */
    val extent : Option[Seq[Double]] = None,

    /**
     * A color scheme name for ordinal scales (e.g., `"category10"` or `"blues"`).
     *
     * For the full list of supported schemes, please refer to the [Vega
     * Scheme](https://vega.github.io/vega/docs/schemes/#reference) reference.
     */
    val name : Option[String] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None
) derives Encoder.AsObject, Decoder

/**
 * Sort order for the encoded field.
 *
 * For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
 * `"descending"`.
 *
 * For discrete fields, `sort` can be one of the following:
 * - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
 * JavaScript.
 * - [A string indicating an encoding channel name to sort
 * by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or
 * `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by
 * x-field, descending). This channel string is short-form of [a sort-by-encoding
 * definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For
 * example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order":
 * "descending"}`.
 * - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
 * for sorting by another field.
 * - [An array specifying the field values in preferred
 * order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
 * sort order will obey the values in the array, followed by any unspecified values in their
 * original order. For discrete time field, values in the sort array can be [date-time
 * definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
 * the values can be the month or day names (case insensitive) or their 3-letter initials
 * (e.g., `"Mon"`, `"Tue"`).
 * - `null` indicating no sort.
 *
 * __Default value:__ `"ascending"`
 *
 * __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
 *
 * __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
 */
type SortUnion = EncodingSortField | Sort | Seq[SelectionInitInterval] | NullValue
given Decoder[SortUnion] = {
    List[Decoder[SortUnion]](
        Decoder[EncodingSortField].widen,
        Decoder[Sort].widen,
        Decoder[Seq[SelectionInitInterval]].widen,
        Decoder[NullValue].widen,
    ).reduceLeft(_ or _)
}

given Encoder[SortUnion] = Encoder.instance {
    case enc0 : EncodingSortField => Encoder.AsObject[EncodingSortField].apply(enc0)
    case enc1 : Sort => summon[Encoder[Sort]].apply(enc1)
    case enc2 : Seq[SelectionInitInterval] => Encoder.encodeSeq[SelectionInitInterval].apply(enc2)
    case enc3 : NullValue => Encoder.encodeNone(enc3)
}

/**
 * A sort definition for sorting a discrete scale in an encoding field definition.
 */
case class EncodingSortField (
    /**
     * The data [field](https://vega.github.io/vega-lite/docs/field.html) to sort by.
     *
     * __Default value:__ If unspecified, defaults to the field specified in the outer data
     * reference.
     */
    val field : Option[Field] = None,

    /**
     * An [aggregate operation](https://vega.github.io/vega-lite/docs/aggregate.html#ops) to
     * perform on the field prior to sorting (e.g., `"count"`, `"mean"` and `"median"`). An
     * aggregation is required when there are multiple values of the sort field for each encoded
     * data field. The input data objects will be aggregated, grouped by the encoded data
     * field.
     *
     * For a full list of operations, please see the documentation for
     * [aggregate](https://vega.github.io/vega-lite/docs/aggregate.html#ops).
     *
     * __Default value:__ `"sum"` for stacked plots. Otherwise, `"min"`.
     */
    val op : Option[NonArgAggregateOp] = None,

    /**
     * The sort order. One of `"ascending"` (default), `"descending"`, or `null` (no not sort).
     */
    val order : Option[SortOrder] = None,

    /**
     * The [encoding channel](https://vega.github.io/vega-lite/docs/encoding.html#channels) to
     * sort by (e.g., `"x"`, `"y"`)
     */
    val encoding : Option[SortByChannel] = None
) derives Encoder.AsObject, Decoder

/**
 * The [encoding channel](https://vega.github.io/vega-lite/docs/encoding.html#channels) to
 * sort by (e.g., `"x"`, `"y"`)
 */

enum SortByChannel : 
    case color
    case fill
    case fillOpacity
    case opacity
    case shape
    case size
    case stroke
    case strokeOpacity
    case strokeWidth
    case text
    case x
    case y
given Decoder[SortByChannel] = Decoder.decodeString.emapTry(x => Try(SortByChannel.valueOf(x) )) 
given Encoder[SortByChannel] = Encoder.encodeString.contramap(_.toString())

/**
 * The sort order. One of `"ascending"` (default) or `"descending"`.
 */

enum SortOrder : 
    case ascending
    case descending
given Decoder[SortOrder] = Decoder.decodeString.emapTry(x => Try(SortOrder.valueOf(x) )) 
given Encoder[SortOrder] = Encoder.encodeString.contramap(_.toString())

/**
 * The sort order. One of `"ascending"` (default) or `"descending"`.
 *
 * The [encoding channel](https://vega.github.io/vega-lite/docs/encoding.html#channels) to
 * sort by (e.g., `"x"`, `"y"`)
 */

enum Sort : 
    case `-color`
    case `-fill`
    case `-fillOpacity`
    case `-opacity`
    case `-shape`
    case `-size`
    case `-stroke`
    case `-strokeOpacity`
    case `-strokeWidth`
    case `-text`
    case `-x`
    case `-y`
    case ascending
    case color
    case descending
    case fill
    case fillOpacity
    case opacity
    case shape
    case size
    case stroke
    case strokeOpacity
    case strokeWidth
    case text
    case x
    case y
given Decoder[Sort] = Decoder.decodeString.emapTry(x => Try(Sort.valueOf(x) )) 
given Encoder[Sort] = Encoder.encodeString.contramap(_.toString())

/**
 * Color of the marks – either fill or stroke color based on  the `filled` property of mark
 * definition. By default, `color` represents fill color for `"area"`, `"bar"`, `"tick"`,
 * `"text"`, `"trail"`, `"circle"`, and `"square"` / stroke color for `"line"` and
 * `"point"`.
 *
 * __Default value:__ If undefined, the default color depends on [mark
 * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color`
 * property.
 *
 * _Note:_ 1) For fine-grained control over both fill and stroke colors of the marks, please
 * use the `fill` and `stroke` channels. The `fill` or `stroke` encodings have higher
 * precedence than `color`, thus may override the `color` encoding if conflicting encodings
 * are specified. 2) See the scale documentation for more information about customizing
 * [color scheme](https://vega.github.io/vega-lite/docs/scale.html#scheme).
 *
 * Fill color of the marks. __Default value:__ If undefined, the default color depends on
 * [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color`
 * property.
 *
 * _Note:_ The `fill` encoding has higher precedence than `color`, thus may override the
 * `color` encoding if conflicting encodings are specified.
 *
 * Stroke color of the marks. __Default value:__ If undefined, the default color depends on
 * [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color`
 * property.
 *
 * _Note:_ The `stroke` encoding has higher precedence than `color`, thus may override the
 * `color` encoding if conflicting encodings are specified.
 *
 * A FieldDef with Condition<ValueDef> {   condition: {value: ...},   field: ...,   ... }
 */
case class ColorClass (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[AngleBin] = None,

    /**
     * One or more value definition(s) with [a parameter or a test
     * predicate](https://vega.github.io/vega-lite/docs/condition.html).
     *
     * __Note:__ A field definition's `condition` property can only contain [conditional value
     * definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite
     * only allows at most one encoded field per encoding channel.
     *
     * A field definition or one or more value definition(s) with a parameter predicate.
     */
    val condition : Option[ColorCondition] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * An object defining properties of the legend. If `null`, the legend for the encoding
     * channel will be removed.
     *
     * __Default value:__ If undefined, default [legend
     * properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
     *
     * __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
     */
    val legend : Option[Legend] = None,

    /**
     * An object defining properties of the channel's scale, which is the function that
     * transforms values in the data domain (numbers, dates, strings, etc) to visual values
     * (pixels, colors, sizes) of the encoding channels.
     *
     * If `null`, the scale will be [disabled and the data value will be directly
     * encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
     *
     * __Default value:__ If undefined, default [scale
     * properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
     *
     * __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
     */
    val scale : Option[Scale] = None,

    /**
     * Sort order for the encoded field.
     *
     * For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
     * `"descending"`.
     *
     * For discrete fields, `sort` can be one of the following:
     * - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
     * JavaScript.
     * - [A string indicating an encoding channel name to sort
     * by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or
     * `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by
     * x-field, descending). This channel string is short-form of [a sort-by-encoding
     * definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For
     * example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order":
     * "descending"}`.
     * - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
     * for sorting by another field.
     * - [An array specifying the field values in preferred
     * order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
     * sort order will obey the values in the array, followed by any unspecified values in their
     * original order. For discrete time field, values in the sort array can be [date-time
     * definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
     * the values can be the month or day names (case insensitive) or their 3-letter initials
     * (e.g., `"Mon"`, `"Tue"`).
     * - `null` indicating no sort.
     *
     * __Default value:__ `"ascending"`
     *
     * __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
     *
     * __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
     */
    val sort : Option[SortUnion] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[Type] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Gradient] = None
) derives Encoder.AsObject, Decoder

type ColorCondition = ConditionalPValueDefGradientStringNullExprRef | Seq[ConditionalValueDefGradientStringNullExprRef]
given Decoder[ColorCondition] = {
    List[Decoder[ColorCondition]](
        Decoder[ConditionalPValueDefGradientStringNullExprRef].widen,
        Decoder[Seq[ConditionalValueDefGradientStringNullExprRef]].widen,
    ).reduceLeft(_ or _)
}

given Encoder[ColorCondition] = Encoder.instance {
    case enc0 : ConditionalPValueDefGradientStringNullExprRef => Encoder.AsObject[ConditionalPValueDefGradientStringNullExprRef].apply(enc0)
    case enc1 : Seq[ConditionalValueDefGradientStringNullExprRef] => Encoder.encodeSeq[ConditionalValueDefGradientStringNullExprRef].apply(enc1)
}

case class ConditionalValueDefGradientStringNullExprRef (
    /**
     * Predicate for triggering the condition
     */
    val test : Option[PredicateComposition] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Gradient,

    /**
     * For selection parameters, the predicate of empty selections returns true by default.
     * Override this behavior, by setting this property `empty: false`.
     */
    val empty : Option[Boolean] = None,

    /**
     * Filter using a parameter name.
     */
    val param : Option[String] = None
) derives Encoder.AsObject, Decoder

type Gradient = String | ValueLinearGradient | NullValue
given Decoder[Gradient] = {
    List[Decoder[Gradient]](
        Decoder[String].widen,
        Decoder[ValueLinearGradient].widen,
        Decoder[NullValue].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Gradient] = Encoder.instance {
    case enc0 : String => Encoder.encodeString(enc0)
    case enc1 : ValueLinearGradient => Encoder.AsObject[ValueLinearGradient].apply(enc1)
    case enc2 : NullValue => Encoder.encodeNone(enc2)
}

case class ValueLinearGradient (
    /**
     * The type of gradient. Use `"linear"` for a linear gradient.
     *
     * The type of gradient. Use `"radial"` for a radial gradient.
     */
    val gradient : Option[String] = None,

    val id : Option[String] = None,

    /**
     * An array of gradient stops defining the gradient color sequence.
     */
    val stops : Option[Seq[GradientStop]] = None,

    /**
     * The starting x-coordinate, in normalized [0, 1] coordinates, of the linear gradient.
     *
     * __Default value:__ `0`
     *
     * The x-coordinate, in normalized [0, 1] coordinates, for the center of the inner circle
     * for the gradient.
     *
     * __Default value:__ `0.5`
     */
    val x1 : Option[Double] = None,

    /**
     * The ending x-coordinate, in normalized [0, 1] coordinates, of the linear gradient.
     *
     * __Default value:__ `1`
     *
     * The x-coordinate, in normalized [0, 1] coordinates, for the center of the outer circle
     * for the gradient.
     *
     * __Default value:__ `0.5`
     */
    val x2 : Option[Double] = None,

    /**
     * The starting y-coordinate, in normalized [0, 1] coordinates, of the linear gradient.
     *
     * __Default value:__ `0`
     *
     * The y-coordinate, in normalized [0, 1] coordinates, for the center of the inner circle
     * for the gradient.
     *
     * __Default value:__ `0.5`
     */
    val y1 : Option[Double] = None,

    /**
     * The ending y-coordinate, in normalized [0, 1] coordinates, of the linear gradient.
     *
     * __Default value:__ `0`
     *
     * The y-coordinate, in normalized [0, 1] coordinates, for the center of the outer circle
     * for the gradient.
     *
     * __Default value:__ `0.5`
     */
    val y2 : Option[Double] = None,

    /**
     * The radius length, in normalized [0, 1] coordinates, of the inner circle for the
     * gradient.
     *
     * __Default value:__ `0`
     */
    val r1 : Option[Double] = None,

    /**
     * The radius length, in normalized [0, 1] coordinates, of the outer circle for the
     * gradient.
     *
     * __Default value:__ `0.5`
     */
    val r2 : Option[Double] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None
) derives Encoder.AsObject, Decoder

case class GradientStop (
    /**
     * The color value at this point in the gradient.
     */
    val color : String,

    /**
     * The offset fraction for the color stop, indicating its position within the gradient.
     */
    val offset : Double
) derives Encoder.AsObject, Decoder

case class ConditionalPValueDefGradientStringNullExprRef (
    /**
     * Predicate for triggering the condition
     */
    val test : Option[PredicateComposition] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Gradient] = None,

    /**
     * For selection parameters, the predicate of empty selections returns true by default.
     * Override this behavior, by setting this property `empty: false`.
     */
    val empty : Option[Boolean] = None,

    /**
     * Filter using a parameter name.
     */
    val param : Option[String] = None,

    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[AngleBin] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * An object defining properties of the legend. If `null`, the legend for the encoding
     * channel will be removed.
     *
     * __Default value:__ If undefined, default [legend
     * properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
     *
     * __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
     */
    val legend : Option[Legend] = None,

    /**
     * An object defining properties of the channel's scale, which is the function that
     * transforms values in the data domain (numbers, dates, strings, etc) to visual values
     * (pixels, colors, sizes) of the encoding channels.
     *
     * If `null`, the scale will be [disabled and the data value will be directly
     * encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
     *
     * __Default value:__ If undefined, default [scale
     * properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
     *
     * __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
     */
    val scale : Option[Scale] = None,

    /**
     * Sort order for the encoded field.
     *
     * For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
     * `"descending"`.
     *
     * For discrete fields, `sort` can be one of the following:
     * - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
     * JavaScript.
     * - [A string indicating an encoding channel name to sort
     * by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or
     * `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by
     * x-field, descending). This channel string is short-form of [a sort-by-encoding
     * definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For
     * example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order":
     * "descending"}`.
     * - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
     * for sorting by another field.
     * - [An array specifying the field values in preferred
     * order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
     * sort order will obey the values in the array, followed by any unspecified values in their
     * original order. For discrete time field, values in the sort array can be [date-time
     * definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
     * the values can be the month or day names (case insensitive) or their 3-letter initials
     * (e.g., `"Mon"`, `"Tue"`).
     * - `null` indicating no sort.
     *
     * __Default value:__ `"ascending"`
     *
     * __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
     *
     * __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
     */
    val sort : Option[SortUnion] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[Type] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None
) derives Encoder.AsObject, Decoder

/**
 * A field definition for the horizontal facet of trellis plots.
 *
 * A field definition for the vertical facet of trellis plots.
 */
case class RowColumnEncodingFieldDef (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * The alignment to apply to row/column facet's subplot. The supported string values are
     * `"all"`, `"each"`, and `"none"`.
     *
     * - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed
     * one after the other.
     * - For `"each"`, subviews will be aligned into a clean grid structure, but each row or
     * column may be of variable size.
     * - For `"all"`, subviews will be aligned and each row or column will be sized identically
     * based on the maximum observed size. String values for this property will be applied to
     * both grid rows and columns.
     *
     * __Default value:__ `"all"`.
     */
    val align : Option[LayoutAlign] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[AngleBin] = None,

    /**
     * Boolean flag indicating if facet's subviews should be centered relative to their
     * respective rows or columns.
     *
     * __Default value:__ `false`
     */
    val center : Option[Boolean] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * An object defining properties of a facet's header.
     */
    val header : Option[Header] = None,

    /**
     * Sort order for the encoded field.
     *
     * For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
     * `"descending"`.
     *
     * For discrete fields, `sort` can be one of the following:
     * - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
     * JavaScript.
     * - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
     * for sorting by another field.
     * - [An array specifying the field values in preferred
     * order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
     * sort order will obey the values in the array, followed by any unspecified values in their
     * original order. For discrete time field, values in the sort array can be [date-time
     * definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
     * the values can be the month or day names (case insensitive) or their 3-letter initials
     * (e.g., `"Mon"`, `"Tue"`).
     * - `null` indicating no sort.
     *
     * __Default value:__ `"ascending"`
     *
     * __Note:__ `null` is not supported for `row` and `column`.
     */
    val sort : Option[SortArray] = None,

    /**
     * The spacing in pixels between facet's sub-views.
     *
     * __Default value__: Depends on `"spacing"` property of [the view composition
     * configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by
     * default)
     */
    val spacing : Option[Double] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[StandardType] = None
) derives Encoder.AsObject, Decoder

/**
 * Headers of row / column channels for faceted plots.
 */
case class Header (
    /**
     * When used with the default `"number"` and `"time"` format type, the text formatting
     * pattern for labels of guides (axes, legends, headers) and text marks.
     *
     * - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number
     * format pattern](https://github.com/d3/d3-format#locale_format).
     * - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format
     * pattern](https://github.com/d3/d3-time-format#locale_format).
     *
     * See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for
     * more examples.
     *
     * When used with a [custom
     * `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this
     * value will be passed as `format` alongside `datum.value` to the registered function.
     *
     * __Default value:__  Derived from
     * [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for
     * number format and from
     * [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time
     * format.
     */
    val format : Option[Format] = None,

    /**
     * The format type for labels. One of `"number"`, `"time"`, or a [registered custom format
     * type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).
     *
     * __Default value:__
     * - `"time"` for temporal fields and ordinal and nominal fields with `timeUnit`.
     * - `"number"` for quantitative fields as well as ordinal and nominal fields without
     * `timeUnit`.
     */
    val formatType : Option[String] = None,

    /**
     * Horizontal text alignment of header labels. One of `"left"`, `"center"`, or `"right"`.
     */
    val labelAlign : Option[TitleAlignUnion] = None,

    /**
     * The anchor position for placing the labels. One of `"start"`, `"middle"`, or `"end"`. For
     * example, with a label orientation of top these anchor positions map to a left-, center-,
     * or right-aligned label.
     */
    val labelAnchor : Option[TitleAnchorEnum] = None,

    /**
     * The rotation angle of the header labels.
     *
     * __Default value:__ `0` for column header, `-90` for row header.
     */
    val labelAngle : Option[Double] = None,

    /**
     * The vertical text baseline for the header labels. One of `"alphabetic"` (default),
     * `"top"`, `"middle"`, `"bottom"`, `"line-top"`, or `"line-bottom"`. The `"line-top"` and
     * `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated
     * relative to the `titleLineHeight` rather than `titleFontSize` alone.
     */
    val labelBaseline : Option[BackgroundUnion] = None,

    /**
     * The color of the header label, can be in hex color code or regular color name.
     */
    val labelColor : Option[BackgroundUnion] = None,

    /**
     * [Vega expression](https://vega.github.io/vega/docs/expressions/) for customizing labels.
     *
     * __Note:__ The label text and value can be assessed via the `label` and `value` properties
     * of the header's backing `datum` object.
     */
    val labelExpr : Option[String] = None,

    /**
     * The font of the header label.
     */
    val labelFont : Option[BackgroundUnion] = None,

    /**
     * The font size of the header label, in pixels.
     */
    val labelFontSize : Option[CornerRadius] = None,

    /**
     * The font style of the header label.
     */
    val labelFontStyle : Option[BackgroundUnion] = None,

    /**
     * The font weight of the header label.
     */
    val labelFontWeight : Option[FontWeightUnion] = None,

    /**
     * The maximum length of the header label in pixels. The text value will be automatically
     * truncated if the rendered size exceeds the limit.
     *
     * __Default value:__ `0`, indicating no limit
     */
    val labelLimit : Option[CornerRadius] = None,

    /**
     * Line height in pixels for multi-line header labels or title text with `"line-top"` or
     * `"line-bottom"` baseline.
     */
    val labelLineHeight : Option[CornerRadius] = None,

    /**
     * The orientation of the header label. One of `"top"`, `"bottom"`, `"left"` or `"right"`.
     */
    val labelOrient : Option[Orient] = None,

    /**
     * The padding, in pixel, between facet header's label and the plot.
     *
     * __Default value:__ `10`
     */
    val labelPadding : Option[CornerRadius] = None,

    /**
     * A boolean flag indicating if labels should be included as part of the header.
     *
     * __Default value:__ `true`.
     */
    val labels : Option[Boolean] = None,

    /**
     * Shortcut for setting both labelOrient and titleOrient.
     */
    val orient : Option[Orient] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * Horizontal text alignment (to the anchor) of header titles.
     */
    val titleAlign : Option[TitleAlignUnion] = None,

    /**
     * The anchor position for placing the title. One of `"start"`, `"middle"`, or `"end"`. For
     * example, with an orientation of top these anchor positions map to a left-, center-, or
     * right-aligned title.
     */
    val titleAnchor : Option[TitleAnchorEnum] = None,

    /**
     * The rotation angle of the header title.
     *
     * __Default value:__ `0`.
     */
    val titleAngle : Option[Double] = None,

    /**
     * The vertical text baseline for the header title. One of `"alphabetic"` (default),
     * `"top"`, `"middle"`, `"bottom"`, `"line-top"`, or `"line-bottom"`. The `"line-top"` and
     * `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated
     * relative to the `titleLineHeight` rather than `titleFontSize` alone.
     *
     * __Default value:__ `"middle"`
     */
    val titleBaseline : Option[BackgroundUnion] = None,

    /**
     * Color of the header title, can be in hex color code or regular color name.
     */
    val titleColor : Option[BackgroundUnion] = None,

    /**
     * Font of the header title. (e.g., `"Helvetica Neue"`).
     */
    val titleFont : Option[BackgroundUnion] = None,

    /**
     * Font size of the header title.
     */
    val titleFontSize : Option[CornerRadius] = None,

    /**
     * The font style of the header title.
     */
    val titleFontStyle : Option[BackgroundUnion] = None,

    /**
     * Font weight of the header title. This can be either a string (e.g `"bold"`, `"normal"`)
     * or a number (`100`, `200`, `300`, ..., `900` where `"normal"` = `400` and `"bold"` =
     * `700`).
     */
    val titleFontWeight : Option[FontWeightUnion] = None,

    /**
     * The maximum length of the header title in pixels. The text value will be automatically
     * truncated if the rendered size exceeds the limit.
     *
     * __Default value:__ `0`, indicating no limit
     */
    val titleLimit : Option[CornerRadius] = None,

    /**
     * Line height in pixels for multi-line header title text or title text with `"line-top"` or
     * `"line-bottom"` baseline.
     */
    val titleLineHeight : Option[CornerRadius] = None,

    /**
     * The orientation of the header title. One of `"top"`, `"bottom"`, `"left"` or `"right"`.
     */
    val titleOrient : Option[Orient] = None,

    /**
     * The padding, in pixel, between facet header's title and the label.
     *
     * __Default value:__ `10`
     */
    val titlePadding : Option[CornerRadius] = None
) derives Encoder.AsObject, Decoder

/**
 * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
 * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
 * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
 *
 * Vega-Lite automatically infers data types in many cases as discussed below. However, type
 * is required for a field if: (1) the field is not nominal and the field encoding has no
 * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
 * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
 * or `timeUnit`.
 *
 * __Default value:__
 *
 * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
 * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
 * following criteria:
 * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
 * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
 * `longitude` channel or (3) if the specified scale type is [a quantitative
 * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
 * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
 * the specified scale type is a time or utc scale
 * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
 * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
 * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
 * `order`.
 *
 * 2) For a constant value in data domain (`datum`):
 * - `"quantitative"` if the datum is a number
 * - `"nominal"` if the datum is a string
 * - `"temporal"` if the datum is [a date time
 * object](https://vega.github.io/vega-lite/docs/datetime.html)
 *
 * __Note:__
 * - Data `type` describes the semantics of the data rather than the primitive data types
 * (number, string, etc.). The same primitive data type can have different types of
 * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
 * data.
 * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
 * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
 * `1552199579097`).
 * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
 * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
 * (for using an ordinal bin
 * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
 * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
 * `type` property can be either `"temporal"` (default, for using a temporal scale) or
 * [`"ordinal"` (for using an ordinal
 * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
 * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
 * the `type` property refers to the post-aggregation data type. For example, we can
 * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
 * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
 * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
 * must have exactly the same type as their primary channels (e.g., `x`, `y`).
 *
 * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
 */

enum StandardType : 
    case nominal
    case ordinal
    case quantitative
    case temporal
given Decoder[StandardType] = Decoder.decodeString.emapTry(x => Try(StandardType.valueOf(x) )) 
given Encoder[StandardType] = Encoder.encodeString.contramap(_.toString())

type SortArray = SortOrder | SortEncodingSortField | Seq[SelectionInitInterval] | NullValue
given Decoder[SortArray] = {
    List[Decoder[SortArray]](
        Decoder[SortOrder].widen,
        Decoder[SortEncodingSortField].widen,
        Decoder[Seq[SelectionInitInterval]].widen,
        Decoder[NullValue].widen,
    ).reduceLeft(_ or _)
}

given Encoder[SortArray] = Encoder.instance {
    case enc0 : SortOrder => summon[Encoder[SortOrder]].apply(enc0)
    case enc1 : SortEncodingSortField => Encoder.AsObject[SortEncodingSortField].apply(enc1)
    case enc2 : Seq[SelectionInitInterval] => Encoder.encodeSeq[SelectionInitInterval].apply(enc2)
    case enc3 : NullValue => Encoder.encodeNone(enc3)
}

/**
 * A sort definition for sorting a discrete scale in an encoding field definition.
 */
case class SortEncodingSortField (
    /**
     * The data [field](https://vega.github.io/vega-lite/docs/field.html) to sort by.
     *
     * __Default value:__ If unspecified, defaults to the field specified in the outer data
     * reference.
     */
    val field : Option[Field] = None,

    /**
     * An [aggregate operation](https://vega.github.io/vega-lite/docs/aggregate.html#ops) to
     * perform on the field prior to sorting (e.g., `"count"`, `"mean"` and `"median"`). An
     * aggregation is required when there are multiple values of the sort field for each encoded
     * data field. The input data objects will be aggregated, grouped by the encoded data
     * field.
     *
     * For a full list of operations, please see the documentation for
     * [aggregate](https://vega.github.io/vega-lite/docs/aggregate.html#ops).
     *
     * __Default value:__ `"sum"` for stacked plots. Otherwise, `"min"`.
     */
    val op : Option[NonArgAggregateOp] = None,

    /**
     * The sort order. One of `"ascending"` (default), `"descending"`, or `null` (no not sort).
     */
    val order : Option[SortOrder] = None
) derives Encoder.AsObject, Decoder

/**
 * A text description of this mark for ARIA accessibility (SVG output only). For SVG output
 * the `"aria-label"` attribute will be set to this description.
 *
 * A URL to load upon mouse click.
 *
 * The URL of an image mark.
 *
 * A FieldDef with Condition<ValueDef> {   condition: {value: ...},   field: ...,   ... }
 */
case class DescriptionClass (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[DescriptionBin] = None,

    /**
     * One or more value definition(s) with [a parameter or a test
     * predicate](https://vega.github.io/vega-lite/docs/condition.html).
     *
     * __Note:__ A field definition's `condition` property can only contain [conditional value
     * definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite
     * only allows at most one encoded field per encoding channel.
     *
     * A field definition or one or more value definition(s) with a parameter predicate.
     */
    val condition : Option[DescriptionCondition] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * When used with the default `"number"` and `"time"` format type, the text formatting
     * pattern for labels of guides (axes, legends, headers) and text marks.
     *
     * - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number
     * format pattern](https://github.com/d3/d3-format#locale_format).
     * - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format
     * pattern](https://github.com/d3/d3-time-format#locale_format).
     *
     * See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for
     * more examples.
     *
     * When used with a [custom
     * `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this
     * value will be passed as `format` alongside `datum.value` to the registered function.
     *
     * __Default value:__  Derived from
     * [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for
     * number format and from
     * [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time
     * format.
     */
    val format : Option[Format] = None,

    /**
     * The format type for labels. One of `"number"`, `"time"`, or a [registered custom format
     * type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).
     *
     * __Default value:__
     * - `"time"` for temporal fields and ordinal and nominal fields with `timeUnit`.
     * - `"number"` for quantitative fields as well as ordinal and nominal fields without
     * `timeUnit`.
     */
    val formatType : Option[String] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[StandardType] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Color] = None
) derives Encoder.AsObject, Decoder

type DescriptionBin = BinParams | Boolean | String | NullValue
given Decoder[DescriptionBin] = {
    List[Decoder[DescriptionBin]](
        Decoder[BinParams].widen,
        Decoder[Boolean].widen,
        Decoder[String].widen,
        Decoder[NullValue].widen,
    ).reduceLeft(_ or _)
}

given Encoder[DescriptionBin] = Encoder.instance {
    case enc0 : BinParams => Encoder.AsObject[BinParams].apply(enc0)
    case enc1 : Boolean => Encoder.encodeBoolean(enc1)
    case enc2 : String => Encoder.encodeString(enc2)
    case enc3 : NullValue => Encoder.encodeNone(enc3)
}

type DescriptionCondition = PurpleConditionalPExprRef | Seq[PurpleConditionalValueDefStringExprRef]
given Decoder[DescriptionCondition] = {
    List[Decoder[DescriptionCondition]](
        Decoder[PurpleConditionalPExprRef].widen,
        Decoder[Seq[PurpleConditionalValueDefStringExprRef]].widen,
    ).reduceLeft(_ or _)
}

given Encoder[DescriptionCondition] = Encoder.instance {
    case enc0 : PurpleConditionalPExprRef => Encoder.AsObject[PurpleConditionalPExprRef].apply(enc0)
    case enc1 : Seq[PurpleConditionalValueDefStringExprRef] => Encoder.encodeSeq[PurpleConditionalValueDefStringExprRef].apply(enc1)
}

case class PurpleConditionalValueDefStringExprRef (
    /**
     * Predicate for triggering the condition
     */
    val test : Option[PredicateComposition] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Color,

    /**
     * For selection parameters, the predicate of empty selections returns true by default.
     * Override this behavior, by setting this property `empty: false`.
     */
    val empty : Option[Boolean] = None,

    /**
     * Filter using a parameter name.
     */
    val param : Option[String] = None
) derives Encoder.AsObject, Decoder

case class PurpleConditionalPExprRef (
    /**
     * Predicate for triggering the condition
     */
    val test : Option[PredicateComposition] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Color] = None,

    /**
     * For selection parameters, the predicate of empty selections returns true by default.
     * Override this behavior, by setting this property `empty: false`.
     */
    val empty : Option[Boolean] = None,

    /**
     * Filter using a parameter name.
     */
    val param : Option[String] = None,

    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[AngleBin] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * An object defining properties of the legend. If `null`, the legend for the encoding
     * channel will be removed.
     *
     * __Default value:__ If undefined, default [legend
     * properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
     *
     * __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
     */
    val legend : Option[Legend] = None,

    /**
     * An object defining properties of the channel's scale, which is the function that
     * transforms values in the data domain (numbers, dates, strings, etc) to visual values
     * (pixels, colors, sizes) of the encoding channels.
     *
     * If `null`, the scale will be [disabled and the data value will be directly
     * encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
     *
     * __Default value:__ If undefined, default [scale
     * properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
     *
     * __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
     */
    val scale : Option[Scale] = None,

    /**
     * Sort order for the encoded field.
     *
     * For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
     * `"descending"`.
     *
     * For discrete fields, `sort` can be one of the following:
     * - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
     * JavaScript.
     * - [A string indicating an encoding channel name to sort
     * by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or
     * `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by
     * x-field, descending). This channel string is short-form of [a sort-by-encoding
     * definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For
     * example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order":
     * "descending"}`.
     * - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
     * for sorting by another field.
     * - [An array specifying the field values in preferred
     * order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
     * sort order will obey the values in the array, followed by any unspecified values in their
     * original order. For discrete time field, values in the sort array can be [date-time
     * definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
     * the values can be the month or day names (case insensitive) or their 3-letter initials
     * (e.g., `"Mon"`, `"Tue"`).
     * - `null` indicating no sort.
     *
     * __Default value:__ `"ascending"`
     *
     * __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
     *
     * __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
     */
    val sort : Option[SortUnion] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[Type] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None
) derives Encoder.AsObject, Decoder

type Detail = Seq[TypedFieldDef] | TypedFieldDef
given Decoder[Detail] = {
    List[Decoder[Detail]](
        Decoder[Seq[TypedFieldDef]].widen,
        Decoder[TypedFieldDef].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Detail] = Encoder.instance {
    case enc0 : Seq[TypedFieldDef] => Encoder.encodeSeq[TypedFieldDef].apply(enc0)
    case enc1 : TypedFieldDef => Encoder.AsObject[TypedFieldDef].apply(enc1)
}

/**
 * Field Def without scale (and without bin: "binned" support).
 *
 * Definition object for a data field, its type and transformation of an encoding channel.
 *
 * A data field to use as a unique key for data binding. When a visualization’s data is
 * updated, the key value will be used to match data elements to existing mark instances.
 * Use a key channel to enable object constancy for transitions over dynamic data.
 */
case class TypedFieldDef (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[DescriptionBin] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[StandardType] = None
) derives Encoder.AsObject, Decoder

/**
 * A field definition for the (flexible) facet of trellis plots.
 *
 * If either `row` or `column` is specified, this channel will be ignored.
 */
case class FacetEncodingFieldDef (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * The alignment to apply to grid rows and columns. The supported string values are `"all"`,
     * `"each"`, and `"none"`.
     *
     * - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed
     * one after the other.
     * - For `"each"`, subviews will be aligned into a clean grid structure, but each row or
     * column may be of variable size.
     * - For `"all"`, subviews will be aligned and each row or column will be sized identically
     * based on the maximum observed size. String values for this property will be applied to
     * both grid rows and columns.
     *
     * Alternatively, an object value of the form `{"row": string, "column": string}` can be
     * used to supply different alignments for rows and columns.
     *
     * __Default value:__ `"all"`.
     */
    val align : Option[VegaLiteDSLAlign] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[AngleBin] = None,

    /**
     * The bounds calculation method to use for determining the extent of a sub-plot. One of
     * `full` (the default) or `flush`.
     *
     * - If set to `full`, the entire calculated bounds (including axes, title, and legend) will
     * be used.
     * - If set to `flush`, only the specified width and height values for the sub-view will be
     * used. The `flush` setting can be useful when attempting to place sub-plots without axes
     * or legends into a uniform grid structure.
     *
     * __Default value:__ `"full"`
     */
    val bounds : Option[Bounds] = None,

    /**
     * Boolean flag indicating if subviews should be centered relative to their respective rows
     * or columns.
     *
     * An object value of the form `{"row": boolean, "column": boolean}` can be used to supply
     * different centering values for rows and columns.
     *
     * __Default value:__ `false`
     */
    val center : Option[Center] = None,

    /**
     * The number of columns to include in the view composition layout.
     *
     * __Default value__: `undefined` -- An infinite number of columns (a single row) will be
     * assumed. This is equivalent to `hconcat` (for `concat`) and to using the `column` channel
     * (for `facet` and `repeat`).
     *
     * __Note__:
     *
     * 1) This property is only for:
     * - the general (wrappable) `concat` operator (not `hconcat`/`vconcat`)
     * - the `facet` and `repeat` operator with one field/repetition definition (without
     * row/column nesting)
     *
     * 2) Setting the `columns` to `1` is equivalent to `vconcat` (for `concat`) and to using
     * the `row` channel (for `facet` and `repeat`).
     */
    val columns : Option[Double] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * An object defining properties of a facet's header.
     */
    val header : Option[Header] = None,

    /**
     * Sort order for the encoded field.
     *
     * For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
     * `"descending"`.
     *
     * For discrete fields, `sort` can be one of the following:
     * - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
     * JavaScript.
     * - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
     * for sorting by another field.
     * - [An array specifying the field values in preferred
     * order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
     * sort order will obey the values in the array, followed by any unspecified values in their
     * original order. For discrete time field, values in the sort array can be [date-time
     * definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
     * the values can be the month or day names (case insensitive) or their 3-letter initials
     * (e.g., `"Mon"`, `"Tue"`).
     * - `null` indicating no sort.
     *
     * __Default value:__ `"ascending"`
     *
     * __Note:__ `null` is not supported for `row` and `column`.
     */
    val sort : Option[SortArray] = None,

    /**
     * The spacing in pixels between sub-views of the composition operator. An object of the
     * form `{"row": number, "column": number}` can be used to set different spacing values for
     * rows and columns.
     *
     * __Default value__: Depends on `"spacing"` property of [the view composition
     * configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by
     * default)
     */
    val spacing : Option[Spacing] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[StandardType] = None
) derives Encoder.AsObject, Decoder

type Spacing = Double | RowColNumber
given Decoder[Spacing] = {
    List[Decoder[Spacing]](
        Decoder[Double].widen,
        Decoder[RowColNumber].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Spacing] = Encoder.instance {
    case enc0 : Double => Encoder.encodeDouble(enc0)
    case enc1 : RowColNumber => Encoder.AsObject[RowColNumber].apply(enc1)
}

case class RowColNumber (
    val column : Option[Double] = None,
    val row : Option[Double] = None
) derives Encoder.AsObject, Decoder

/**
 * Color of the marks – either fill or stroke color based on  the `filled` property of mark
 * definition. By default, `color` represents fill color for `"area"`, `"bar"`, `"tick"`,
 * `"text"`, `"trail"`, `"circle"`, and `"square"` / stroke color for `"line"` and
 * `"point"`.
 *
 * __Default value:__ If undefined, the default color depends on [mark
 * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color`
 * property.
 *
 * _Note:_ 1) For fine-grained control over both fill and stroke colors of the marks, please
 * use the `fill` and `stroke` channels. The `fill` or `stroke` encodings have higher
 * precedence than `color`, thus may override the `color` encoding if conflicting encodings
 * are specified. 2) See the scale documentation for more information about customizing
 * [color scheme](https://vega.github.io/vega-lite/docs/scale.html#scheme).
 *
 * Fill color of the marks. __Default value:__ If undefined, the default color depends on
 * [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color`
 * property.
 *
 * _Note:_ The `fill` encoding has higher precedence than `color`, thus may override the
 * `color` encoding if conflicting encodings are specified.
 *
 * Stroke color of the marks. __Default value:__ If undefined, the default color depends on
 * [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color`
 * property.
 *
 * _Note:_ The `stroke` encoding has higher precedence than `color`, thus may override the
 * `color` encoding if conflicting encodings are specified.
 *
 * A FieldDef with Condition<ValueDef> {   condition: {value: ...},   field: ...,   ... }
 */
case class FillClass (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[AngleBin] = None,

    /**
     * One or more value definition(s) with [a parameter or a test
     * predicate](https://vega.github.io/vega-lite/docs/condition.html).
     *
     * __Note:__ A field definition's `condition` property can only contain [conditional value
     * definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite
     * only allows at most one encoded field per encoding channel.
     *
     * A field definition or one or more value definition(s) with a parameter predicate.
     */
    val condition : Option[ColorCondition] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * An object defining properties of the legend. If `null`, the legend for the encoding
     * channel will be removed.
     *
     * __Default value:__ If undefined, default [legend
     * properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
     *
     * __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
     */
    val legend : Option[Legend] = None,

    /**
     * An object defining properties of the channel's scale, which is the function that
     * transforms values in the data domain (numbers, dates, strings, etc) to visual values
     * (pixels, colors, sizes) of the encoding channels.
     *
     * If `null`, the scale will be [disabled and the data value will be directly
     * encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
     *
     * __Default value:__ If undefined, default [scale
     * properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
     *
     * __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
     */
    val scale : Option[Scale] = None,

    /**
     * Sort order for the encoded field.
     *
     * For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
     * `"descending"`.
     *
     * For discrete fields, `sort` can be one of the following:
     * - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
     * JavaScript.
     * - [A string indicating an encoding channel name to sort
     * by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or
     * `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by
     * x-field, descending). This channel string is short-form of [a sort-by-encoding
     * definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For
     * example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order":
     * "descending"}`.
     * - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
     * for sorting by another field.
     * - [An array specifying the field values in preferred
     * order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
     * sort order will obey the values in the array, followed by any unspecified values in their
     * original order. For discrete time field, values in the sort array can be [date-time
     * definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
     * the values can be the month or day names (case insensitive) or their 3-letter initials
     * (e.g., `"Mon"`, `"Tue"`).
     * - `null` indicating no sort.
     *
     * __Default value:__ `"ascending"`
     *
     * __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
     *
     * __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
     */
    val sort : Option[SortUnion] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[Type] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Gradient] = None
) derives Encoder.AsObject, Decoder

/**
 * Rotation angle of point and text marks.
 *
 * Fill opacity of the marks.
 *
 * __Default value:__ If undefined, the default opacity depends on [mark
 * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `fillOpacity`
 * property.
 *
 * Opacity of the marks.
 *
 * __Default value:__ If undefined, the default opacity depends on [mark
 * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `opacity`
 * property.
 *
 * Size of the mark.
 * - For `"point"`, `"square"` and `"circle"`, – the symbol size, or pixel area of the mark.
 * - For `"bar"` and `"tick"` – the bar and tick's size.
 * - For `"text"` – the text's font size.
 * - Size is unsupported for `"line"`, `"area"`, and `"rect"`. (Use `"trail"` instead of
 * line with varying size)
 *
 * Stroke opacity of the marks.
 *
 * __Default value:__ If undefined, the default opacity depends on [mark
 * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `strokeOpacity`
 * property.
 *
 * Stroke width of the marks.
 *
 * __Default value:__ If undefined, the default stroke width depends on [mark
 * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `strokeWidth`
 * property.
 *
 * A FieldDef with Condition<ValueDef> {   condition: {value: ...},   field: ...,   ... }
 */
case class FillOpacityClass (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[AngleBin] = None,

    /**
     * One or more value definition(s) with [a parameter or a test
     * predicate](https://vega.github.io/vega-lite/docs/condition.html).
     *
     * __Note:__ A field definition's `condition` property can only contain [conditional value
     * definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite
     * only allows at most one encoded field per encoding channel.
     *
     * A field definition or one or more value definition(s) with a parameter predicate.
     */
    val condition : Option[AngleCondition] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * An object defining properties of the legend. If `null`, the legend for the encoding
     * channel will be removed.
     *
     * __Default value:__ If undefined, default [legend
     * properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
     *
     * __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
     */
    val legend : Option[Legend] = None,

    /**
     * An object defining properties of the channel's scale, which is the function that
     * transforms values in the data domain (numbers, dates, strings, etc) to visual values
     * (pixels, colors, sizes) of the encoding channels.
     *
     * If `null`, the scale will be [disabled and the data value will be directly
     * encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
     *
     * __Default value:__ If undefined, default [scale
     * properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
     *
     * __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
     */
    val scale : Option[Scale] = None,

    /**
     * Sort order for the encoded field.
     *
     * For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
     * `"descending"`.
     *
     * For discrete fields, `sort` can be one of the following:
     * - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
     * JavaScript.
     * - [A string indicating an encoding channel name to sort
     * by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or
     * `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by
     * x-field, descending). This channel string is short-form of [a sort-by-encoding
     * definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For
     * example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order":
     * "descending"}`.
     * - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
     * for sorting by another field.
     * - [An array specifying the field values in preferred
     * order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
     * sort order will obey the values in the array, followed by any unspecified values in their
     * original order. For discrete time field, values in the sort array can be [date-time
     * definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
     * the values can be the month or day names (case insensitive) or their 3-letter initials
     * (e.g., `"Mon"`, `"Tue"`).
     * - `null` indicating no sort.
     *
     * __Default value:__ `"ascending"`
     *
     * __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
     *
     * __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
     */
    val sort : Option[SortUnion] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[Type] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[CornerRadius] = None
) derives Encoder.AsObject, Decoder

/**
 * A text description of this mark for ARIA accessibility (SVG output only). For SVG output
 * the `"aria-label"` attribute will be set to this description.
 *
 * A URL to load upon mouse click.
 *
 * The URL of an image mark.
 *
 * A FieldDef with Condition<ValueDef> {   condition: {value: ...},   field: ...,   ... }
 */
case class HrefClass (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[DescriptionBin] = None,

    /**
     * One or more value definition(s) with [a parameter or a test
     * predicate](https://vega.github.io/vega-lite/docs/condition.html).
     *
     * __Note:__ A field definition's `condition` property can only contain [conditional value
     * definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite
     * only allows at most one encoded field per encoding channel.
     *
     * A field definition or one or more value definition(s) with a parameter predicate.
     */
    val condition : Option[DescriptionCondition] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * When used with the default `"number"` and `"time"` format type, the text formatting
     * pattern for labels of guides (axes, legends, headers) and text marks.
     *
     * - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number
     * format pattern](https://github.com/d3/d3-format#locale_format).
     * - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format
     * pattern](https://github.com/d3/d3-time-format#locale_format).
     *
     * See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for
     * more examples.
     *
     * When used with a [custom
     * `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this
     * value will be passed as `format` alongside `datum.value` to the registered function.
     *
     * __Default value:__  Derived from
     * [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for
     * number format and from
     * [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time
     * format.
     */
    val format : Option[Format] = None,

    /**
     * The format type for labels. One of `"number"`, `"time"`, or a [registered custom format
     * type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).
     *
     * __Default value:__
     * - `"time"` for temporal fields and ordinal and nominal fields with `timeUnit`.
     * - `"number"` for quantitative fields as well as ordinal and nominal fields without
     * `timeUnit`.
     */
    val formatType : Option[String] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[StandardType] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Color] = None
) derives Encoder.AsObject, Decoder

/**
 * Field Def without scale (and without bin: "binned" support).
 *
 * Definition object for a data field, its type and transformation of an encoding channel.
 *
 * A data field to use as a unique key for data binding. When a visualization’s data is
 * updated, the key value will be used to match data elements to existing mark instances.
 * Use a key channel to enable object constancy for transitions over dynamic data.
 */
case class KeyClass (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[DescriptionBin] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[StandardType] = None
) derives Encoder.AsObject, Decoder

/**
 * Latitude position of geographically projected marks.
 *
 * Longitude position of geographically projected marks.
 */
case class LatitudeClass (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[Json] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[String] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None
) derives Encoder.AsObject, Decoder

/**
 * Latitude-2 position for geographically projected ranged `"area"`, `"bar"`, `"rect"`, and
 * `"rule"`.
 *
 * Longitude-2 position for geographically projected ranged `"area"`, `"bar"`, `"rect"`,
 * and  `"rule"`.
 *
 * The inner radius in pixels of arc marks.
 *
 * The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing
 * values proceed clockwise.
 *
 * X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
 *
 * The `value` of this channel can be a number or a string `"width"` for the width of the
 * plot.
 *
 * Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
 *
 * The `value` of this channel can be a number or a string `"height"` for the height of the
 * plot.
 *
 * A field definition of a secondary channel that shares a scale with another primary
 * channel. For example, `x2`, `xError` and `xError2` share the same scale with `x`.
 *
 * Definition object for a constant value (primitive value or gradient definition) of an
 * encoding channel.
 */
case class Latitude2Class (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[Json] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[Type] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[X] = None
) derives Encoder.AsObject, Decoder

/**
 * Latitude position of geographically projected marks.
 *
 * Longitude position of geographically projected marks.
 */
case class LongitudeClass (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[Json] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[String] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None
) derives Encoder.AsObject, Decoder

/**
 * Latitude-2 position for geographically projected ranged `"area"`, `"bar"`, `"rect"`, and
 * `"rule"`.
 *
 * Longitude-2 position for geographically projected ranged `"area"`, `"bar"`, `"rect"`,
 * and  `"rule"`.
 *
 * The inner radius in pixels of arc marks.
 *
 * The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing
 * values proceed clockwise.
 *
 * X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
 *
 * The `value` of this channel can be a number or a string `"width"` for the width of the
 * plot.
 *
 * Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
 *
 * The `value` of this channel can be a number or a string `"height"` for the height of the
 * plot.
 *
 * A field definition of a secondary channel that shares a scale with another primary
 * channel. For example, `x2`, `xError` and `xError2` share the same scale with `x`.
 *
 * Definition object for a constant value (primitive value or gradient definition) of an
 * encoding channel.
 */
case class Longitude2Class (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[Json] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[Type] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[X] = None
) derives Encoder.AsObject, Decoder

/**
 * Rotation angle of point and text marks.
 *
 * Fill opacity of the marks.
 *
 * __Default value:__ If undefined, the default opacity depends on [mark
 * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `fillOpacity`
 * property.
 *
 * Opacity of the marks.
 *
 * __Default value:__ If undefined, the default opacity depends on [mark
 * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `opacity`
 * property.
 *
 * Size of the mark.
 * - For `"point"`, `"square"` and `"circle"`, – the symbol size, or pixel area of the mark.
 * - For `"bar"` and `"tick"` – the bar and tick's size.
 * - For `"text"` – the text's font size.
 * - Size is unsupported for `"line"`, `"area"`, and `"rect"`. (Use `"trail"` instead of
 * line with varying size)
 *
 * Stroke opacity of the marks.
 *
 * __Default value:__ If undefined, the default opacity depends on [mark
 * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `strokeOpacity`
 * property.
 *
 * Stroke width of the marks.
 *
 * __Default value:__ If undefined, the default stroke width depends on [mark
 * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `strokeWidth`
 * property.
 *
 * A FieldDef with Condition<ValueDef> {   condition: {value: ...},   field: ...,   ... }
 */
case class OpacityClass (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[AngleBin] = None,

    /**
     * One or more value definition(s) with [a parameter or a test
     * predicate](https://vega.github.io/vega-lite/docs/condition.html).
     *
     * __Note:__ A field definition's `condition` property can only contain [conditional value
     * definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite
     * only allows at most one encoded field per encoding channel.
     *
     * A field definition or one or more value definition(s) with a parameter predicate.
     */
    val condition : Option[AngleCondition] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * An object defining properties of the legend. If `null`, the legend for the encoding
     * channel will be removed.
     *
     * __Default value:__ If undefined, default [legend
     * properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
     *
     * __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
     */
    val legend : Option[Legend] = None,

    /**
     * An object defining properties of the channel's scale, which is the function that
     * transforms values in the data domain (numbers, dates, strings, etc) to visual values
     * (pixels, colors, sizes) of the encoding channels.
     *
     * If `null`, the scale will be [disabled and the data value will be directly
     * encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
     *
     * __Default value:__ If undefined, default [scale
     * properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
     *
     * __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
     */
    val scale : Option[Scale] = None,

    /**
     * Sort order for the encoded field.
     *
     * For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
     * `"descending"`.
     *
     * For discrete fields, `sort` can be one of the following:
     * - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
     * JavaScript.
     * - [A string indicating an encoding channel name to sort
     * by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or
     * `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by
     * x-field, descending). This channel string is short-form of [a sort-by-encoding
     * definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For
     * example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order":
     * "descending"}`.
     * - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
     * for sorting by another field.
     * - [An array specifying the field values in preferred
     * order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
     * sort order will obey the values in the array, followed by any unspecified values in their
     * original order. For discrete time field, values in the sort array can be [date-time
     * definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
     * the values can be the month or day names (case insensitive) or their 3-letter initials
     * (e.g., `"Mon"`, `"Tue"`).
     * - `null` indicating no sort.
     *
     * __Default value:__ `"ascending"`
     *
     * __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
     *
     * __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
     */
    val sort : Option[SortUnion] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[Type] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[CornerRadius] = None
) derives Encoder.AsObject, Decoder

type Order = OrderDef | Seq[OrderFieldDef]
given Decoder[Order] = {
    List[Decoder[Order]](
        Decoder[OrderDef].widen,
        Decoder[Seq[OrderFieldDef]].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Order] = Encoder.instance {
    case enc0 : OrderDef => Encoder.AsObject[OrderDef].apply(enc0)
    case enc1 : Seq[OrderFieldDef] => Encoder.encodeSeq[OrderFieldDef].apply(enc1)
}

case class OrderFieldDef (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[DescriptionBin] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * The sort order. One of `"ascending"` (default) or `"descending"`.
     */
    val sort : Option[SortOrder] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[StandardType] = None
) derives Encoder.AsObject, Decoder

case class OrderDef (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[DescriptionBin] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * The sort order. One of `"ascending"` (default) or `"descending"`.
     */
    val sort : Option[SortOrder] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[StandardType] = None,

    /**
     * One or more value definition(s) with [a parameter or a test
     * predicate](https://vega.github.io/vega-lite/docs/condition.html).
     *
     * __Note:__ A field definition's `condition` property can only contain [conditional value
     * definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite
     * only allows at most one encoded field per encoding channel.
     */
    val condition : Option[OrderFieldDefCondition] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[CornerRadius] = None
) derives Encoder.AsObject, Decoder

/**
 * One or more value definition(s) with [a parameter or a test
 * predicate](https://vega.github.io/vega-lite/docs/condition.html).
 *
 * __Note:__ A field definition's `condition` property can only contain [conditional value
 * definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite
 * only allows at most one encoded field per encoding channel.
 */
type OrderFieldDefCondition = ConditionalPValueDefNumber | Seq[ConditionalValueDefNumber]
given Decoder[OrderFieldDefCondition] = {
    List[Decoder[OrderFieldDefCondition]](
        Decoder[ConditionalPValueDefNumber].widen,
        Decoder[Seq[ConditionalValueDefNumber]].widen,
    ).reduceLeft(_ or _)
}

given Encoder[OrderFieldDefCondition] = Encoder.instance {
    case enc0 : ConditionalPValueDefNumber => Encoder.AsObject[ConditionalPValueDefNumber].apply(enc0)
    case enc1 : Seq[ConditionalValueDefNumber] => Encoder.encodeSeq[ConditionalValueDefNumber].apply(enc1)
}

case class ConditionalValueDefNumber (
    /**
     * Predicate for triggering the condition
     */
    val test : Option[PredicateComposition] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Double,

    /**
     * For selection parameters, the predicate of empty selections returns true by default.
     * Override this behavior, by setting this property `empty: false`.
     */
    val empty : Option[Boolean] = None,

    /**
     * Filter using a parameter name.
     */
    val param : Option[String] = None
) derives Encoder.AsObject, Decoder

case class ConditionalPValueDefNumber (
    /**
     * Predicate for triggering the condition
     */
    val test : Option[PredicateComposition] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Double,

    /**
     * For selection parameters, the predicate of empty selections returns true by default.
     * Override this behavior, by setting this property `empty: false`.
     */
    val empty : Option[Boolean] = None,

    /**
     * Filter using a parameter name.
     */
    val param : Option[String] = None
) derives Encoder.AsObject, Decoder

/**
 * The outer radius in pixels of arc marks.
 *
 * - For arc marks, the arc length in radians if theta2 is not specified, otherwise the
 * start arc angle. (A value of 0 indicates up or “north”, increasing values proceed
 * clockwise.)
 *
 * - For text marks, polar coordinate angle in radians.
 *
 * Definition object for a constant value (primitive value or gradient definition) of an
 * encoding channel.
 */
case class RadiusClass (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[DescriptionBin] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * An object defining properties of the channel's scale, which is the function that
     * transforms values in the data domain (numbers, dates, strings, etc) to visual values
     * (pixels, colors, sizes) of the encoding channels.
     *
     * If `null`, the scale will be [disabled and the data value will be directly
     * encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
     *
     * __Default value:__ If undefined, default [scale
     * properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
     *
     * __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
     */
    val scale : Option[Scale] = None,

    /**
     * Sort order for the encoded field.
     *
     * For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
     * `"descending"`.
     *
     * For discrete fields, `sort` can be one of the following:
     * - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
     * JavaScript.
     * - [A string indicating an encoding channel name to sort
     * by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or
     * `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by
     * x-field, descending). This channel string is short-form of [a sort-by-encoding
     * definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For
     * example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order":
     * "descending"}`.
     * - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
     * for sorting by another field.
     * - [An array specifying the field values in preferred
     * order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
     * sort order will obey the values in the array, followed by any unspecified values in their
     * original order. For discrete time field, values in the sort array can be [date-time
     * definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
     * the values can be the month or day names (case insensitive) or their 3-letter initials
     * (e.g., `"Mon"`, `"Tue"`).
     * - `null` indicating no sort.
     *
     * __Default value:__ `"ascending"`
     *
     * __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
     *
     * __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
     */
    val sort : Option[SortUnion] = None,

    /**
     * Type of stacking offset if the field should be stacked. `stack` is only applicable for
     * `x`, `y`, `theta`, and `radius` channels with continuous domains. For example, `stack` of
     * `y` can be used to customize stacking for a vertical bar chart.
     *
     * `stack` can be one of the following values:
     * - `"zero"` or `true`: stacking with baseline offset at zero value of the scale (for
     * creating typical stacked [bar](https://vega.github.io/vega-lite/docs/stack.html#bar) and
     * [area](https://vega.github.io/vega-lite/docs/stack.html#area) chart).
     * - `"normalize"` - stacking with normalized domain (for creating [normalized stacked bar
     * and area charts](https://vega.github.io/vega-lite/docs/stack.html#normalized) and pie
     * charts [with percentage
     * tooltip](https://vega.github.io/vega-lite/docs/arc.html#tooltip)). <br/>
     * -`"center"` - stacking with center baseline (for
     * [streamgraph](https://vega.github.io/vega-lite/docs/stack.html#streamgraph)).
     * - `null` or `false` - No-stacking. This will produce layered
     * [bar](https://vega.github.io/vega-lite/docs/stack.html#layered-bar-chart) and area
     * chart.
     *
     * __Default value:__ `zero` for plots with all of the following conditions are true: (1)
     * the mark is `bar`, `area`, or `arc`; (2) the stacked measure channel (x or y) has a
     * linear scale; (3) At least one of non-position channels mapped to an unaggregated field
     * that is different from x and y. Otherwise, `null` by default.
     *
     * __See also:__ [`stack`](https://vega.github.io/vega-lite/docs/stack.html) documentation.
     */
    val stack : Option[Stack] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[Type] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[X] = None
) derives Encoder.AsObject, Decoder

type Stack = Boolean | StackOffset | NullValue
given Decoder[Stack] = {
    List[Decoder[Stack]](
        Decoder[Boolean].widen,
        Decoder[StackOffset].widen,
        Decoder[NullValue].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Stack] = Encoder.instance {
    case enc0 : Boolean => Encoder.encodeBoolean(enc0)
    case enc1 : StackOffset => summon[Encoder[StackOffset]].apply(enc1)
    case enc2 : NullValue => Encoder.encodeNone(enc2)
}

/**
 * Mode for stacking marks. One of `"zero"` (default), `"center"`, or `"normalize"`. The
 * `"zero"` offset will stack starting at `0`. The `"center"` offset will center the stacks.
 * The `"normalize"` offset will compute percentage values for each stack point, with output
 * values in the range `[0,1]`.
 *
 * __Default value:__ `"zero"`
 */

enum StackOffset : 
    case center
    case normalize
    case zero
given Decoder[StackOffset] = Decoder.decodeString.emapTry(x => Try(StackOffset.valueOf(x) )) 
given Encoder[StackOffset] = Encoder.encodeString.contramap(_.toString())

/**
 * Latitude-2 position for geographically projected ranged `"area"`, `"bar"`, `"rect"`, and
 * `"rule"`.
 *
 * Longitude-2 position for geographically projected ranged `"area"`, `"bar"`, `"rect"`,
 * and  `"rule"`.
 *
 * The inner radius in pixels of arc marks.
 *
 * The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing
 * values proceed clockwise.
 *
 * X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
 *
 * The `value` of this channel can be a number or a string `"width"` for the width of the
 * plot.
 *
 * Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
 *
 * The `value` of this channel can be a number or a string `"height"` for the height of the
 * plot.
 *
 * A field definition of a secondary channel that shares a scale with another primary
 * channel. For example, `x2`, `xError` and `xError2` share the same scale with `x`.
 *
 * Definition object for a constant value (primitive value or gradient definition) of an
 * encoding channel.
 */
case class Radius2Class (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[Json] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[Type] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[X] = None
) derives Encoder.AsObject, Decoder

/**
 * Shape of the mark.
 *
 * 1. For `point` marks the supported values include:   - plotting shapes: `"circle"`,
 * `"square"`, `"cross"`, `"diamond"`, `"triangle-up"`, `"triangle-down"`,
 * `"triangle-right"`, or `"triangle-left"`.   - the line symbol `"stroke"`   - centered
 * directional shapes `"arrow"`, `"wedge"`, or `"triangle"`   - a custom [SVG path
 * string](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths) (For correct
 * sizing, custom shape paths should be defined within a square bounding box with
 * coordinates ranging from -1 to 1 along both the x and y dimensions.)
 *
 * 2. For `geoshape` marks it should be a field definition of the geojson data
 *
 * __Default value:__ If undefined, the default shape depends on [mark
 * config](https://vega.github.io/vega-lite/docs/config.html#point-config)'s `shape`
 * property. (`"circle"` if unset.)
 *
 * A FieldDef with Condition<ValueDef> {   condition: {value: ...},   field: ...,   ... }
 */
case class MarkPropDefStringNullTypeForShape (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[AngleBin] = None,

    /**
     * One or more value definition(s) with [a parameter or a test
     * predicate](https://vega.github.io/vega-lite/docs/condition.html).
     *
     * __Note:__ A field definition's `condition` property can only contain [conditional value
     * definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite
     * only allows at most one encoded field per encoding channel.
     *
     * A field definition or one or more value definition(s) with a parameter predicate.
     */
    val condition : Option[ShapeCondition] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * An object defining properties of the legend. If `null`, the legend for the encoding
     * channel will be removed.
     *
     * __Default value:__ If undefined, default [legend
     * properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
     *
     * __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
     */
    val legend : Option[Legend] = None,

    /**
     * An object defining properties of the channel's scale, which is the function that
     * transforms values in the data domain (numbers, dates, strings, etc) to visual values
     * (pixels, colors, sizes) of the encoding channels.
     *
     * If `null`, the scale will be [disabled and the data value will be directly
     * encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
     *
     * __Default value:__ If undefined, default [scale
     * properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
     *
     * __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
     */
    val scale : Option[Scale] = None,

    /**
     * Sort order for the encoded field.
     *
     * For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
     * `"descending"`.
     *
     * For discrete fields, `sort` can be one of the following:
     * - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
     * JavaScript.
     * - [A string indicating an encoding channel name to sort
     * by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or
     * `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by
     * x-field, descending). This channel string is short-form of [a sort-by-encoding
     * definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For
     * example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order":
     * "descending"}`.
     * - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
     * for sorting by another field.
     * - [An array specifying the field values in preferred
     * order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
     * sort order will obey the values in the array, followed by any unspecified values in their
     * original order. For discrete time field, values in the sort array can be [date-time
     * definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
     * the values can be the month or day names (case insensitive) or their 3-letter initials
     * (e.g., `"Mon"`, `"Tue"`).
     * - `null` indicating no sort.
     *
     * __Default value:__ `"ascending"`
     *
     * __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
     *
     * __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
     */
    val sort : Option[SortUnion] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[Type] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Color] = None
) derives Encoder.AsObject, Decoder

type ShapeCondition = ConditionalPValueDefStringNullExprRef | Seq[ConditionalValueDefStringNullExprRef]
given Decoder[ShapeCondition] = {
    List[Decoder[ShapeCondition]](
        Decoder[ConditionalPValueDefStringNullExprRef].widen,
        Decoder[Seq[ConditionalValueDefStringNullExprRef]].widen,
    ).reduceLeft(_ or _)
}

given Encoder[ShapeCondition] = Encoder.instance {
    case enc0 : ConditionalPValueDefStringNullExprRef => Encoder.AsObject[ConditionalPValueDefStringNullExprRef].apply(enc0)
    case enc1 : Seq[ConditionalValueDefStringNullExprRef] => Encoder.encodeSeq[ConditionalValueDefStringNullExprRef].apply(enc1)
}

case class ConditionalValueDefStringNullExprRef (
    /**
     * Predicate for triggering the condition
     */
    val test : Option[PredicateComposition] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Color,

    /**
     * For selection parameters, the predicate of empty selections returns true by default.
     * Override this behavior, by setting this property `empty: false`.
     */
    val empty : Option[Boolean] = None,

    /**
     * Filter using a parameter name.
     */
    val param : Option[String] = None
) derives Encoder.AsObject, Decoder

case class ConditionalPValueDefStringNullExprRef (
    /**
     * Predicate for triggering the condition
     */
    val test : Option[PredicateComposition] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Color] = None,

    /**
     * For selection parameters, the predicate of empty selections returns true by default.
     * Override this behavior, by setting this property `empty: false`.
     */
    val empty : Option[Boolean] = None,

    /**
     * Filter using a parameter name.
     */
    val param : Option[String] = None,

    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[AngleBin] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * An object defining properties of the legend. If `null`, the legend for the encoding
     * channel will be removed.
     *
     * __Default value:__ If undefined, default [legend
     * properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
     *
     * __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
     */
    val legend : Option[Legend] = None,

    /**
     * An object defining properties of the channel's scale, which is the function that
     * transforms values in the data domain (numbers, dates, strings, etc) to visual values
     * (pixels, colors, sizes) of the encoding channels.
     *
     * If `null`, the scale will be [disabled and the data value will be directly
     * encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
     *
     * __Default value:__ If undefined, default [scale
     * properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
     *
     * __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
     */
    val scale : Option[Scale] = None,

    /**
     * Sort order for the encoded field.
     *
     * For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
     * `"descending"`.
     *
     * For discrete fields, `sort` can be one of the following:
     * - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
     * JavaScript.
     * - [A string indicating an encoding channel name to sort
     * by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or
     * `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by
     * x-field, descending). This channel string is short-form of [a sort-by-encoding
     * definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For
     * example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order":
     * "descending"}`.
     * - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
     * for sorting by another field.
     * - [An array specifying the field values in preferred
     * order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
     * sort order will obey the values in the array, followed by any unspecified values in their
     * original order. For discrete time field, values in the sort array can be [date-time
     * definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
     * the values can be the month or day names (case insensitive) or their 3-letter initials
     * (e.g., `"Mon"`, `"Tue"`).
     * - `null` indicating no sort.
     *
     * __Default value:__ `"ascending"`
     *
     * __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
     *
     * __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
     */
    val sort : Option[SortUnion] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[Type] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None
) derives Encoder.AsObject, Decoder

/**
 * Rotation angle of point and text marks.
 *
 * Fill opacity of the marks.
 *
 * __Default value:__ If undefined, the default opacity depends on [mark
 * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `fillOpacity`
 * property.
 *
 * Opacity of the marks.
 *
 * __Default value:__ If undefined, the default opacity depends on [mark
 * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `opacity`
 * property.
 *
 * Size of the mark.
 * - For `"point"`, `"square"` and `"circle"`, – the symbol size, or pixel area of the mark.
 * - For `"bar"` and `"tick"` – the bar and tick's size.
 * - For `"text"` – the text's font size.
 * - Size is unsupported for `"line"`, `"area"`, and `"rect"`. (Use `"trail"` instead of
 * line with varying size)
 *
 * Stroke opacity of the marks.
 *
 * __Default value:__ If undefined, the default opacity depends on [mark
 * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `strokeOpacity`
 * property.
 *
 * Stroke width of the marks.
 *
 * __Default value:__ If undefined, the default stroke width depends on [mark
 * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `strokeWidth`
 * property.
 *
 * A FieldDef with Condition<ValueDef> {   condition: {value: ...},   field: ...,   ... }
 */
case class SizeClass (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[AngleBin] = None,

    /**
     * One or more value definition(s) with [a parameter or a test
     * predicate](https://vega.github.io/vega-lite/docs/condition.html).
     *
     * __Note:__ A field definition's `condition` property can only contain [conditional value
     * definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite
     * only allows at most one encoded field per encoding channel.
     *
     * A field definition or one or more value definition(s) with a parameter predicate.
     */
    val condition : Option[AngleCondition] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * An object defining properties of the legend. If `null`, the legend for the encoding
     * channel will be removed.
     *
     * __Default value:__ If undefined, default [legend
     * properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
     *
     * __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
     */
    val legend : Option[Legend] = None,

    /**
     * An object defining properties of the channel's scale, which is the function that
     * transforms values in the data domain (numbers, dates, strings, etc) to visual values
     * (pixels, colors, sizes) of the encoding channels.
     *
     * If `null`, the scale will be [disabled and the data value will be directly
     * encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
     *
     * __Default value:__ If undefined, default [scale
     * properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
     *
     * __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
     */
    val scale : Option[Scale] = None,

    /**
     * Sort order for the encoded field.
     *
     * For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
     * `"descending"`.
     *
     * For discrete fields, `sort` can be one of the following:
     * - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
     * JavaScript.
     * - [A string indicating an encoding channel name to sort
     * by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or
     * `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by
     * x-field, descending). This channel string is short-form of [a sort-by-encoding
     * definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For
     * example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order":
     * "descending"}`.
     * - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
     * for sorting by another field.
     * - [An array specifying the field values in preferred
     * order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
     * sort order will obey the values in the array, followed by any unspecified values in their
     * original order. For discrete time field, values in the sort array can be [date-time
     * definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
     * the values can be the month or day names (case insensitive) or their 3-letter initials
     * (e.g., `"Mon"`, `"Tue"`).
     * - `null` indicating no sort.
     *
     * __Default value:__ `"ascending"`
     *
     * __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
     *
     * __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
     */
    val sort : Option[SortUnion] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[Type] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[CornerRadius] = None
) derives Encoder.AsObject, Decoder

/**
 * Color of the marks – either fill or stroke color based on  the `filled` property of mark
 * definition. By default, `color` represents fill color for `"area"`, `"bar"`, `"tick"`,
 * `"text"`, `"trail"`, `"circle"`, and `"square"` / stroke color for `"line"` and
 * `"point"`.
 *
 * __Default value:__ If undefined, the default color depends on [mark
 * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color`
 * property.
 *
 * _Note:_ 1) For fine-grained control over both fill and stroke colors of the marks, please
 * use the `fill` and `stroke` channels. The `fill` or `stroke` encodings have higher
 * precedence than `color`, thus may override the `color` encoding if conflicting encodings
 * are specified. 2) See the scale documentation for more information about customizing
 * [color scheme](https://vega.github.io/vega-lite/docs/scale.html#scheme).
 *
 * Fill color of the marks. __Default value:__ If undefined, the default color depends on
 * [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color`
 * property.
 *
 * _Note:_ The `fill` encoding has higher precedence than `color`, thus may override the
 * `color` encoding if conflicting encodings are specified.
 *
 * Stroke color of the marks. __Default value:__ If undefined, the default color depends on
 * [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color`
 * property.
 *
 * _Note:_ The `stroke` encoding has higher precedence than `color`, thus may override the
 * `color` encoding if conflicting encodings are specified.
 *
 * A FieldDef with Condition<ValueDef> {   condition: {value: ...},   field: ...,   ... }
 */
case class StrokeClass (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[AngleBin] = None,

    /**
     * One or more value definition(s) with [a parameter or a test
     * predicate](https://vega.github.io/vega-lite/docs/condition.html).
     *
     * __Note:__ A field definition's `condition` property can only contain [conditional value
     * definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite
     * only allows at most one encoded field per encoding channel.
     *
     * A field definition or one or more value definition(s) with a parameter predicate.
     */
    val condition : Option[ColorCondition] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * An object defining properties of the legend. If `null`, the legend for the encoding
     * channel will be removed.
     *
     * __Default value:__ If undefined, default [legend
     * properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
     *
     * __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
     */
    val legend : Option[Legend] = None,

    /**
     * An object defining properties of the channel's scale, which is the function that
     * transforms values in the data domain (numbers, dates, strings, etc) to visual values
     * (pixels, colors, sizes) of the encoding channels.
     *
     * If `null`, the scale will be [disabled and the data value will be directly
     * encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
     *
     * __Default value:__ If undefined, default [scale
     * properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
     *
     * __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
     */
    val scale : Option[Scale] = None,

    /**
     * Sort order for the encoded field.
     *
     * For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
     * `"descending"`.
     *
     * For discrete fields, `sort` can be one of the following:
     * - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
     * JavaScript.
     * - [A string indicating an encoding channel name to sort
     * by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or
     * `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by
     * x-field, descending). This channel string is short-form of [a sort-by-encoding
     * definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For
     * example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order":
     * "descending"}`.
     * - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
     * for sorting by another field.
     * - [An array specifying the field values in preferred
     * order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
     * sort order will obey the values in the array, followed by any unspecified values in their
     * original order. For discrete time field, values in the sort array can be [date-time
     * definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
     * the values can be the month or day names (case insensitive) or their 3-letter initials
     * (e.g., `"Mon"`, `"Tue"`).
     * - `null` indicating no sort.
     *
     * __Default value:__ `"ascending"`
     *
     * __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
     *
     * __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
     */
    val sort : Option[SortUnion] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[Type] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Gradient] = None
) derives Encoder.AsObject, Decoder

/**
 * Stroke dash of the marks.
 *
 * __Default value:__ `[1,0]` (No dash).
 *
 * A FieldDef with Condition<ValueDef> {   condition: {value: ...},   field: ...,   ... }
 */
case class MarkPropDefNumber (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[AngleBin] = None,

    /**
     * One or more value definition(s) with [a parameter or a test
     * predicate](https://vega.github.io/vega-lite/docs/condition.html).
     *
     * __Note:__ A field definition's `condition` property can only contain [conditional value
     * definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite
     * only allows at most one encoded field per encoding channel.
     *
     * A field definition or one or more value definition(s) with a parameter predicate.
     */
    val condition : Option[StrokeDashCondition] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * An object defining properties of the legend. If `null`, the legend for the encoding
     * channel will be removed.
     *
     * __Default value:__ If undefined, default [legend
     * properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
     *
     * __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
     */
    val legend : Option[Legend] = None,

    /**
     * An object defining properties of the channel's scale, which is the function that
     * transforms values in the data domain (numbers, dates, strings, etc) to visual values
     * (pixels, colors, sizes) of the encoding channels.
     *
     * If `null`, the scale will be [disabled and the data value will be directly
     * encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
     *
     * __Default value:__ If undefined, default [scale
     * properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
     *
     * __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
     */
    val scale : Option[Scale] = None,

    /**
     * Sort order for the encoded field.
     *
     * For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
     * `"descending"`.
     *
     * For discrete fields, `sort` can be one of the following:
     * - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
     * JavaScript.
     * - [A string indicating an encoding channel name to sort
     * by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or
     * `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by
     * x-field, descending). This channel string is short-form of [a sort-by-encoding
     * definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For
     * example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order":
     * "descending"}`.
     * - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
     * for sorting by another field.
     * - [An array specifying the field values in preferred
     * order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
     * sort order will obey the values in the array, followed by any unspecified values in their
     * original order. For discrete time field, values in the sort array can be [date-time
     * definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
     * the values can be the month or day names (case insensitive) or their 3-letter initials
     * (e.g., `"Mon"`, `"Tue"`).
     * - `null` indicating no sort.
     *
     * __Default value:__ `"ascending"`
     *
     * __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
     *
     * __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
     */
    val sort : Option[SortUnion] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[Type] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[StrokeDash] = None
) derives Encoder.AsObject, Decoder

type StrokeDashCondition = ConditionalParameterValueDefNumberExprRefClass | Seq[ConditionalValueDefNumberExprRefElement]
given Decoder[StrokeDashCondition] = {
    List[Decoder[StrokeDashCondition]](
        Decoder[ConditionalParameterValueDefNumberExprRefClass].widen,
        Decoder[Seq[ConditionalValueDefNumberExprRefElement]].widen,
    ).reduceLeft(_ or _)
}

given Encoder[StrokeDashCondition] = Encoder.instance {
    case enc0 : ConditionalParameterValueDefNumberExprRefClass => Encoder.AsObject[ConditionalParameterValueDefNumberExprRefClass].apply(enc0)
    case enc1 : Seq[ConditionalValueDefNumberExprRefElement] => Encoder.encodeSeq[ConditionalValueDefNumberExprRefElement].apply(enc1)
}

case class ConditionalValueDefNumberExprRefElement (
    /**
     * Predicate for triggering the condition
     */
    val test : Option[PredicateComposition] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : StrokeDash,

    /**
     * For selection parameters, the predicate of empty selections returns true by default.
     * Override this behavior, by setting this property `empty: false`.
     */
    val empty : Option[Boolean] = None,

    /**
     * Filter using a parameter name.
     */
    val param : Option[String] = None
) derives Encoder.AsObject, Decoder

case class ConditionalParameterValueDefNumberExprRefClass (
    /**
     * Predicate for triggering the condition
     */
    val test : Option[PredicateComposition] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[StrokeDash] = None,

    /**
     * For selection parameters, the predicate of empty selections returns true by default.
     * Override this behavior, by setting this property `empty: false`.
     */
    val empty : Option[Boolean] = None,

    /**
     * Filter using a parameter name.
     */
    val param : Option[String] = None,

    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[AngleBin] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * An object defining properties of the legend. If `null`, the legend for the encoding
     * channel will be removed.
     *
     * __Default value:__ If undefined, default [legend
     * properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
     *
     * __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
     */
    val legend : Option[Legend] = None,

    /**
     * An object defining properties of the channel's scale, which is the function that
     * transforms values in the data domain (numbers, dates, strings, etc) to visual values
     * (pixels, colors, sizes) of the encoding channels.
     *
     * If `null`, the scale will be [disabled and the data value will be directly
     * encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
     *
     * __Default value:__ If undefined, default [scale
     * properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
     *
     * __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
     */
    val scale : Option[Scale] = None,

    /**
     * Sort order for the encoded field.
     *
     * For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
     * `"descending"`.
     *
     * For discrete fields, `sort` can be one of the following:
     * - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
     * JavaScript.
     * - [A string indicating an encoding channel name to sort
     * by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or
     * `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by
     * x-field, descending). This channel string is short-form of [a sort-by-encoding
     * definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For
     * example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order":
     * "descending"}`.
     * - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
     * for sorting by another field.
     * - [An array specifying the field values in preferred
     * order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
     * sort order will obey the values in the array, followed by any unspecified values in their
     * original order. For discrete time field, values in the sort array can be [date-time
     * definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
     * the values can be the month or day names (case insensitive) or their 3-letter initials
     * (e.g., `"Mon"`, `"Tue"`).
     * - `null` indicating no sort.
     *
     * __Default value:__ `"ascending"`
     *
     * __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
     *
     * __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
     */
    val sort : Option[SortUnion] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[Type] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None
) derives Encoder.AsObject, Decoder

/**
 * Rotation angle of point and text marks.
 *
 * Fill opacity of the marks.
 *
 * __Default value:__ If undefined, the default opacity depends on [mark
 * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `fillOpacity`
 * property.
 *
 * Opacity of the marks.
 *
 * __Default value:__ If undefined, the default opacity depends on [mark
 * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `opacity`
 * property.
 *
 * Size of the mark.
 * - For `"point"`, `"square"` and `"circle"`, – the symbol size, or pixel area of the mark.
 * - For `"bar"` and `"tick"` – the bar and tick's size.
 * - For `"text"` – the text's font size.
 * - Size is unsupported for `"line"`, `"area"`, and `"rect"`. (Use `"trail"` instead of
 * line with varying size)
 *
 * Stroke opacity of the marks.
 *
 * __Default value:__ If undefined, the default opacity depends on [mark
 * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `strokeOpacity`
 * property.
 *
 * Stroke width of the marks.
 *
 * __Default value:__ If undefined, the default stroke width depends on [mark
 * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `strokeWidth`
 * property.
 *
 * A FieldDef with Condition<ValueDef> {   condition: {value: ...},   field: ...,   ... }
 */
case class StrokeOpacityClass (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[AngleBin] = None,

    /**
     * One or more value definition(s) with [a parameter or a test
     * predicate](https://vega.github.io/vega-lite/docs/condition.html).
     *
     * __Note:__ A field definition's `condition` property can only contain [conditional value
     * definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite
     * only allows at most one encoded field per encoding channel.
     *
     * A field definition or one or more value definition(s) with a parameter predicate.
     */
    val condition : Option[AngleCondition] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * An object defining properties of the legend. If `null`, the legend for the encoding
     * channel will be removed.
     *
     * __Default value:__ If undefined, default [legend
     * properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
     *
     * __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
     */
    val legend : Option[Legend] = None,

    /**
     * An object defining properties of the channel's scale, which is the function that
     * transforms values in the data domain (numbers, dates, strings, etc) to visual values
     * (pixels, colors, sizes) of the encoding channels.
     *
     * If `null`, the scale will be [disabled and the data value will be directly
     * encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
     *
     * __Default value:__ If undefined, default [scale
     * properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
     *
     * __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
     */
    val scale : Option[Scale] = None,

    /**
     * Sort order for the encoded field.
     *
     * For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
     * `"descending"`.
     *
     * For discrete fields, `sort` can be one of the following:
     * - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
     * JavaScript.
     * - [A string indicating an encoding channel name to sort
     * by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or
     * `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by
     * x-field, descending). This channel string is short-form of [a sort-by-encoding
     * definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For
     * example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order":
     * "descending"}`.
     * - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
     * for sorting by another field.
     * - [An array specifying the field values in preferred
     * order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
     * sort order will obey the values in the array, followed by any unspecified values in their
     * original order. For discrete time field, values in the sort array can be [date-time
     * definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
     * the values can be the month or day names (case insensitive) or their 3-letter initials
     * (e.g., `"Mon"`, `"Tue"`).
     * - `null` indicating no sort.
     *
     * __Default value:__ `"ascending"`
     *
     * __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
     *
     * __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
     */
    val sort : Option[SortUnion] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[Type] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[CornerRadius] = None
) derives Encoder.AsObject, Decoder

/**
 * Rotation angle of point and text marks.
 *
 * Fill opacity of the marks.
 *
 * __Default value:__ If undefined, the default opacity depends on [mark
 * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `fillOpacity`
 * property.
 *
 * Opacity of the marks.
 *
 * __Default value:__ If undefined, the default opacity depends on [mark
 * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `opacity`
 * property.
 *
 * Size of the mark.
 * - For `"point"`, `"square"` and `"circle"`, – the symbol size, or pixel area of the mark.
 * - For `"bar"` and `"tick"` – the bar and tick's size.
 * - For `"text"` – the text's font size.
 * - Size is unsupported for `"line"`, `"area"`, and `"rect"`. (Use `"trail"` instead of
 * line with varying size)
 *
 * Stroke opacity of the marks.
 *
 * __Default value:__ If undefined, the default opacity depends on [mark
 * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `strokeOpacity`
 * property.
 *
 * Stroke width of the marks.
 *
 * __Default value:__ If undefined, the default stroke width depends on [mark
 * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `strokeWidth`
 * property.
 *
 * A FieldDef with Condition<ValueDef> {   condition: {value: ...},   field: ...,   ... }
 */
case class StrokeWidthClass (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[AngleBin] = None,

    /**
     * One or more value definition(s) with [a parameter or a test
     * predicate](https://vega.github.io/vega-lite/docs/condition.html).
     *
     * __Note:__ A field definition's `condition` property can only contain [conditional value
     * definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite
     * only allows at most one encoded field per encoding channel.
     *
     * A field definition or one or more value definition(s) with a parameter predicate.
     */
    val condition : Option[AngleCondition] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * An object defining properties of the legend. If `null`, the legend for the encoding
     * channel will be removed.
     *
     * __Default value:__ If undefined, default [legend
     * properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
     *
     * __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
     */
    val legend : Option[Legend] = None,

    /**
     * An object defining properties of the channel's scale, which is the function that
     * transforms values in the data domain (numbers, dates, strings, etc) to visual values
     * (pixels, colors, sizes) of the encoding channels.
     *
     * If `null`, the scale will be [disabled and the data value will be directly
     * encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
     *
     * __Default value:__ If undefined, default [scale
     * properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
     *
     * __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
     */
    val scale : Option[Scale] = None,

    /**
     * Sort order for the encoded field.
     *
     * For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
     * `"descending"`.
     *
     * For discrete fields, `sort` can be one of the following:
     * - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
     * JavaScript.
     * - [A string indicating an encoding channel name to sort
     * by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or
     * `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by
     * x-field, descending). This channel string is short-form of [a sort-by-encoding
     * definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For
     * example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order":
     * "descending"}`.
     * - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
     * for sorting by another field.
     * - [An array specifying the field values in preferred
     * order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
     * sort order will obey the values in the array, followed by any unspecified values in their
     * original order. For discrete time field, values in the sort array can be [date-time
     * definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
     * the values can be the month or day names (case insensitive) or their 3-letter initials
     * (e.g., `"Mon"`, `"Tue"`).
     * - `null` indicating no sort.
     *
     * __Default value:__ `"ascending"`
     *
     * __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
     *
     * __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
     */
    val sort : Option[SortUnion] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[Type] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[CornerRadius] = None
) derives Encoder.AsObject, Decoder

/**
 * Text of the `text` mark.
 *
 * A FieldDef with Condition<ValueDef> {   condition: {value: ...},   field: ...,   ... }
 */
case class TextDef (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[DescriptionBin] = None,

    /**
     * One or more value definition(s) with [a parameter or a test
     * predicate](https://vega.github.io/vega-lite/docs/condition.html).
     *
     * __Note:__ A field definition's `condition` property can only contain [conditional value
     * definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite
     * only allows at most one encoded field per encoding channel.
     *
     * A field definition or one or more value definition(s) with a parameter predicate.
     */
    val condition : Option[TextCondition] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * When used with the default `"number"` and `"time"` format type, the text formatting
     * pattern for labels of guides (axes, legends, headers) and text marks.
     *
     * - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number
     * format pattern](https://github.com/d3/d3-format#locale_format).
     * - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format
     * pattern](https://github.com/d3/d3-time-format#locale_format).
     *
     * See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for
     * more examples.
     *
     * When used with a [custom
     * `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this
     * value will be passed as `format` alongside `datum.value` to the registered function.
     *
     * __Default value:__  Derived from
     * [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for
     * number format and from
     * [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time
     * format.
     */
    val format : Option[Format] = None,

    /**
     * The format type for labels. One of `"number"`, `"time"`, or a [registered custom format
     * type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).
     *
     * __Default value:__
     * - `"time"` for temporal fields and ordinal and nominal fields with `timeUnit`.
     * - `"number"` for quantitative fields as well as ordinal and nominal fields without
     * `timeUnit`.
     */
    val formatType : Option[String] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[Type] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[TextUnion] = None
) derives Encoder.AsObject, Decoder

type TextCondition = ConditionalP | Seq[ConditionalValueDefTextExprRef]
given Decoder[TextCondition] = {
    List[Decoder[TextCondition]](
        Decoder[ConditionalP].widen,
        Decoder[Seq[ConditionalValueDefTextExprRef]].widen,
    ).reduceLeft(_ or _)
}

given Encoder[TextCondition] = Encoder.instance {
    case enc0 : ConditionalP => Encoder.AsObject[ConditionalP].apply(enc0)
    case enc1 : Seq[ConditionalValueDefTextExprRef] => Encoder.encodeSeq[ConditionalValueDefTextExprRef].apply(enc1)
}

case class ConditionalValueDefTextExprRef (
    /**
     * Predicate for triggering the condition
     */
    val test : Option[PredicateComposition] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : TextUnion,

    /**
     * For selection parameters, the predicate of empty selections returns true by default.
     * Override this behavior, by setting this property `empty: false`.
     */
    val empty : Option[Boolean] = None,

    /**
     * Filter using a parameter name.
     */
    val param : Option[String] = None
) derives Encoder.AsObject, Decoder

/**
 * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
 * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
 * between `0` to `1` for opacity).
 *
 * The title text.
 */
type TextUnion = BackgroundExprRef | Seq[String] | String
given Decoder[TextUnion] = {
    List[Decoder[TextUnion]](
        Decoder[BackgroundExprRef].widen,
        Decoder[Seq[String]].widen,
        Decoder[String].widen,
    ).reduceLeft(_ or _)
}

given Encoder[TextUnion] = Encoder.instance {
    case enc0 : BackgroundExprRef => Encoder.AsObject[BackgroundExprRef].apply(enc0)
    case enc1 : Seq[String] => Encoder.encodeSeq[String].apply(enc1)
    case enc2 : String => Encoder.encodeString(enc2)
}

case class ConditionalP (
    /**
     * Predicate for triggering the condition
     */
    val test : Option[PredicateComposition] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[TextUnion] = None,

    /**
     * For selection parameters, the predicate of empty selections returns true by default.
     * Override this behavior, by setting this property `empty: false`.
     */
    val empty : Option[Boolean] = None,

    /**
     * Filter using a parameter name.
     */
    val param : Option[String] = None,

    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[DescriptionBin] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * When used with the default `"number"` and `"time"` format type, the text formatting
     * pattern for labels of guides (axes, legends, headers) and text marks.
     *
     * - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number
     * format pattern](https://github.com/d3/d3-format#locale_format).
     * - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format
     * pattern](https://github.com/d3/d3-time-format#locale_format).
     *
     * See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for
     * more examples.
     *
     * When used with a [custom
     * `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this
     * value will be passed as `format` alongside `datum.value` to the registered function.
     *
     * __Default value:__  Derived from
     * [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for
     * number format and from
     * [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time
     * format.
     */
    val format : Option[Format] = None,

    /**
     * The format type for labels. One of `"number"`, `"time"`, or a [registered custom format
     * type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).
     *
     * __Default value:__
     * - `"time"` for temporal fields and ordinal and nominal fields with `timeUnit`.
     * - `"number"` for quantitative fields as well as ordinal and nominal fields without
     * `timeUnit`.
     */
    val formatType : Option[String] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[StandardType] = None
) derives Encoder.AsObject, Decoder

/**
 * The outer radius in pixels of arc marks.
 *
 * - For arc marks, the arc length in radians if theta2 is not specified, otherwise the
 * start arc angle. (A value of 0 indicates up or “north”, increasing values proceed
 * clockwise.)
 *
 * - For text marks, polar coordinate angle in radians.
 *
 * Definition object for a constant value (primitive value or gradient definition) of an
 * encoding channel.
 */
case class ThetaClass (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[DescriptionBin] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * An object defining properties of the channel's scale, which is the function that
     * transforms values in the data domain (numbers, dates, strings, etc) to visual values
     * (pixels, colors, sizes) of the encoding channels.
     *
     * If `null`, the scale will be [disabled and the data value will be directly
     * encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
     *
     * __Default value:__ If undefined, default [scale
     * properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
     *
     * __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
     */
    val scale : Option[Scale] = None,

    /**
     * Sort order for the encoded field.
     *
     * For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
     * `"descending"`.
     *
     * For discrete fields, `sort` can be one of the following:
     * - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
     * JavaScript.
     * - [A string indicating an encoding channel name to sort
     * by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or
     * `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by
     * x-field, descending). This channel string is short-form of [a sort-by-encoding
     * definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For
     * example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order":
     * "descending"}`.
     * - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
     * for sorting by another field.
     * - [An array specifying the field values in preferred
     * order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
     * sort order will obey the values in the array, followed by any unspecified values in their
     * original order. For discrete time field, values in the sort array can be [date-time
     * definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
     * the values can be the month or day names (case insensitive) or their 3-letter initials
     * (e.g., `"Mon"`, `"Tue"`).
     * - `null` indicating no sort.
     *
     * __Default value:__ `"ascending"`
     *
     * __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
     *
     * __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
     */
    val sort : Option[SortUnion] = None,

    /**
     * Type of stacking offset if the field should be stacked. `stack` is only applicable for
     * `x`, `y`, `theta`, and `radius` channels with continuous domains. For example, `stack` of
     * `y` can be used to customize stacking for a vertical bar chart.
     *
     * `stack` can be one of the following values:
     * - `"zero"` or `true`: stacking with baseline offset at zero value of the scale (for
     * creating typical stacked [bar](https://vega.github.io/vega-lite/docs/stack.html#bar) and
     * [area](https://vega.github.io/vega-lite/docs/stack.html#area) chart).
     * - `"normalize"` - stacking with normalized domain (for creating [normalized stacked bar
     * and area charts](https://vega.github.io/vega-lite/docs/stack.html#normalized) and pie
     * charts [with percentage
     * tooltip](https://vega.github.io/vega-lite/docs/arc.html#tooltip)). <br/>
     * -`"center"` - stacking with center baseline (for
     * [streamgraph](https://vega.github.io/vega-lite/docs/stack.html#streamgraph)).
     * - `null` or `false` - No-stacking. This will produce layered
     * [bar](https://vega.github.io/vega-lite/docs/stack.html#layered-bar-chart) and area
     * chart.
     *
     * __Default value:__ `zero` for plots with all of the following conditions are true: (1)
     * the mark is `bar`, `area`, or `arc`; (2) the stacked measure channel (x or y) has a
     * linear scale; (3) At least one of non-position channels mapped to an unaggregated field
     * that is different from x and y. Otherwise, `null` by default.
     *
     * __See also:__ [`stack`](https://vega.github.io/vega-lite/docs/stack.html) documentation.
     */
    val stack : Option[Stack] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[Type] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[X] = None
) derives Encoder.AsObject, Decoder

/**
 * Latitude-2 position for geographically projected ranged `"area"`, `"bar"`, `"rect"`, and
 * `"rule"`.
 *
 * Longitude-2 position for geographically projected ranged `"area"`, `"bar"`, `"rect"`,
 * and  `"rule"`.
 *
 * The inner radius in pixels of arc marks.
 *
 * The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing
 * values proceed clockwise.
 *
 * X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
 *
 * The `value` of this channel can be a number or a string `"width"` for the width of the
 * plot.
 *
 * Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
 *
 * The `value` of this channel can be a number or a string `"height"` for the height of the
 * plot.
 *
 * A field definition of a secondary channel that shares a scale with another primary
 * channel. For example, `x2`, `xError` and `xError2` share the same scale with `x`.
 *
 * Definition object for a constant value (primitive value or gradient definition) of an
 * encoding channel.
 */
case class Theta2Class (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[Json] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[Type] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[X] = None
) derives Encoder.AsObject, Decoder

type EncodingTooltip = FieldOrDatumDefWithConditionStringFieldDefString | Seq[StringFieldDef] | NullValue
given Decoder[EncodingTooltip] = {
    List[Decoder[EncodingTooltip]](
        Decoder[FieldOrDatumDefWithConditionStringFieldDefString].widen,
        Decoder[Seq[StringFieldDef]].widen,
        Decoder[NullValue].widen,
    ).reduceLeft(_ or _)
}

given Encoder[EncodingTooltip] = Encoder.instance {
    case enc0 : FieldOrDatumDefWithConditionStringFieldDefString => Encoder.AsObject[FieldOrDatumDefWithConditionStringFieldDefString].apply(enc0)
    case enc1 : Seq[StringFieldDef] => Encoder.encodeSeq[StringFieldDef].apply(enc1)
    case enc2 : NullValue => Encoder.encodeNone(enc2)
}

case class StringFieldDef (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[DescriptionBin] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * When used with the default `"number"` and `"time"` format type, the text formatting
     * pattern for labels of guides (axes, legends, headers) and text marks.
     *
     * - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number
     * format pattern](https://github.com/d3/d3-format#locale_format).
     * - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format
     * pattern](https://github.com/d3/d3-time-format#locale_format).
     *
     * See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for
     * more examples.
     *
     * When used with a [custom
     * `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this
     * value will be passed as `format` alongside `datum.value` to the registered function.
     *
     * __Default value:__  Derived from
     * [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for
     * number format and from
     * [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time
     * format.
     */
    val format : Option[Format] = None,

    /**
     * The format type for labels. One of `"number"`, `"time"`, or a [registered custom format
     * type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).
     *
     * __Default value:__
     * - `"time"` for temporal fields and ordinal and nominal fields with `timeUnit`.
     * - `"number"` for quantitative fields as well as ordinal and nominal fields without
     * `timeUnit`.
     */
    val formatType : Option[String] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[StandardType] = None
) derives Encoder.AsObject, Decoder

/**
 * A FieldDef with Condition<ValueDef> {   condition: {value: ...},   field: ...,   ... }
 */
case class FieldOrDatumDefWithConditionStringFieldDefString (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[DescriptionBin] = None,

    /**
     * One or more value definition(s) with [a parameter or a test
     * predicate](https://vega.github.io/vega-lite/docs/condition.html).
     *
     * __Note:__ A field definition's `condition` property can only contain [conditional value
     * definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite
     * only allows at most one encoded field per encoding channel.
     *
     * A field definition or one or more value definition(s) with a parameter predicate.
     */
    val condition : Option[FieldOrDatumDefWithConditionStringFieldDefStringCondition] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * When used with the default `"number"` and `"time"` format type, the text formatting
     * pattern for labels of guides (axes, legends, headers) and text marks.
     *
     * - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number
     * format pattern](https://github.com/d3/d3-format#locale_format).
     * - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format
     * pattern](https://github.com/d3/d3-time-format#locale_format).
     *
     * See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for
     * more examples.
     *
     * When used with a [custom
     * `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this
     * value will be passed as `format` alongside `datum.value` to the registered function.
     *
     * __Default value:__  Derived from
     * [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for
     * number format and from
     * [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time
     * format.
     */
    val format : Option[Format] = None,

    /**
     * The format type for labels. One of `"number"`, `"time"`, or a [registered custom format
     * type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).
     *
     * __Default value:__
     * - `"time"` for temporal fields and ordinal and nominal fields with `timeUnit`.
     * - `"number"` for quantitative fields as well as ordinal and nominal fields without
     * `timeUnit`.
     */
    val formatType : Option[String] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[StandardType] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Color] = None
) derives Encoder.AsObject, Decoder

type FieldOrDatumDefWithConditionStringFieldDefStringCondition = FluffyConditionalPExprRef | Seq[FluffyConditionalValueDefStringExprRef]
given Decoder[FieldOrDatumDefWithConditionStringFieldDefStringCondition] = {
    List[Decoder[FieldOrDatumDefWithConditionStringFieldDefStringCondition]](
        Decoder[FluffyConditionalPExprRef].widen,
        Decoder[Seq[FluffyConditionalValueDefStringExprRef]].widen,
    ).reduceLeft(_ or _)
}

given Encoder[FieldOrDatumDefWithConditionStringFieldDefStringCondition] = Encoder.instance {
    case enc0 : FluffyConditionalPExprRef => Encoder.AsObject[FluffyConditionalPExprRef].apply(enc0)
    case enc1 : Seq[FluffyConditionalValueDefStringExprRef] => Encoder.encodeSeq[FluffyConditionalValueDefStringExprRef].apply(enc1)
}

case class FluffyConditionalValueDefStringExprRef (
    /**
     * Predicate for triggering the condition
     */
    val test : Option[PredicateComposition] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Color,

    /**
     * For selection parameters, the predicate of empty selections returns true by default.
     * Override this behavior, by setting this property `empty: false`.
     */
    val empty : Option[Boolean] = None,

    /**
     * Filter using a parameter name.
     */
    val param : Option[String] = None
) derives Encoder.AsObject, Decoder

case class FluffyConditionalPExprRef (
    /**
     * Predicate for triggering the condition
     */
    val test : Option[PredicateComposition] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Color] = None,

    /**
     * For selection parameters, the predicate of empty selections returns true by default.
     * Override this behavior, by setting this property `empty: false`.
     */
    val empty : Option[Boolean] = None,

    /**
     * Filter using a parameter name.
     */
    val param : Option[String] = None,

    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[AngleBin] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * An object defining properties of the legend. If `null`, the legend for the encoding
     * channel will be removed.
     *
     * __Default value:__ If undefined, default [legend
     * properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.
     *
     * __See also:__ [`legend`](https://vega.github.io/vega-lite/docs/legend.html) documentation.
     */
    val legend : Option[Legend] = None,

    /**
     * An object defining properties of the channel's scale, which is the function that
     * transforms values in the data domain (numbers, dates, strings, etc) to visual values
     * (pixels, colors, sizes) of the encoding channels.
     *
     * If `null`, the scale will be [disabled and the data value will be directly
     * encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
     *
     * __Default value:__ If undefined, default [scale
     * properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
     *
     * __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
     */
    val scale : Option[Scale] = None,

    /**
     * Sort order for the encoded field.
     *
     * For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
     * `"descending"`.
     *
     * For discrete fields, `sort` can be one of the following:
     * - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
     * JavaScript.
     * - [A string indicating an encoding channel name to sort
     * by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or
     * `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by
     * x-field, descending). This channel string is short-form of [a sort-by-encoding
     * definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For
     * example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order":
     * "descending"}`.
     * - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
     * for sorting by another field.
     * - [An array specifying the field values in preferred
     * order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
     * sort order will obey the values in the array, followed by any unspecified values in their
     * original order. For discrete time field, values in the sort array can be [date-time
     * definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
     * the values can be the month or day names (case insensitive) or their 3-letter initials
     * (e.g., `"Mon"`, `"Tue"`).
     * - `null` indicating no sort.
     *
     * __Default value:__ `"ascending"`
     *
     * __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
     *
     * __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
     */
    val sort : Option[SortUnion] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[Type] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None
) derives Encoder.AsObject, Decoder

/**
 * A text description of this mark for ARIA accessibility (SVG output only). For SVG output
 * the `"aria-label"` attribute will be set to this description.
 *
 * A URL to load upon mouse click.
 *
 * The URL of an image mark.
 *
 * A FieldDef with Condition<ValueDef> {   condition: {value: ...},   field: ...,   ... }
 */
case class URLClass (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[DescriptionBin] = None,

    /**
     * One or more value definition(s) with [a parameter or a test
     * predicate](https://vega.github.io/vega-lite/docs/condition.html).
     *
     * __Note:__ A field definition's `condition` property can only contain [conditional value
     * definitions](https://vega.github.io/vega-lite/docs/condition.html#value) since Vega-Lite
     * only allows at most one encoded field per encoding channel.
     *
     * A field definition or one or more value definition(s) with a parameter predicate.
     */
    val condition : Option[DescriptionCondition] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * When used with the default `"number"` and `"time"` format type, the text formatting
     * pattern for labels of guides (axes, legends, headers) and text marks.
     *
     * - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number
     * format pattern](https://github.com/d3/d3-format#locale_format).
     * - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format
     * pattern](https://github.com/d3/d3-time-format#locale_format).
     *
     * See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for
     * more examples.
     *
     * When used with a [custom
     * `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this
     * value will be passed as `format` alongside `datum.value` to the registered function.
     *
     * __Default value:__  Derived from
     * [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for
     * number format and from
     * [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time
     * format.
     */
    val format : Option[Format] = None,

    /**
     * The format type for labels. One of `"number"`, `"time"`, or a [registered custom format
     * type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).
     *
     * __Default value:__
     * - `"time"` for temporal fields and ordinal and nominal fields with `timeUnit`.
     * - `"number"` for quantitative fields as well as ordinal and nominal fields without
     * `timeUnit`.
     */
    val formatType : Option[String] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[StandardType] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Color] = None
) derives Encoder.AsObject, Decoder

/**
 * X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified
 * `x2` or `width`.
 *
 * The `value` of this channel can be a number or a string `"width"` for the width of the
 * plot.
 *
 * Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified
 * `y2` or `height`.
 *
 * The `value` of this channel can be a number or a string `"height"` for the height of the
 * plot.
 *
 * Definition object for a constant value (primitive value or gradient definition) of an
 * encoding channel.
 */
case class XClass (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * An object defining properties of axis's gridlines, ticks and labels. If `null`, the axis
     * for the encoding channel will be removed.
     *
     * __Default value:__ If undefined, default [axis
     * properties](https://vega.github.io/vega-lite/docs/axis.html) are applied.
     *
     * __See also:__ [`axis`](https://vega.github.io/vega-lite/docs/axis.html) documentation.
     */
    val axis : Option[Axis] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[DescriptionBin] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * An object defining the properties of the Impute Operation to be applied. The field value
     * of the other positional channel is taken as `key` of the `Impute` Operation. The field of
     * the `color` channel if specified is used as `groupby` of the `Impute` Operation.
     *
     * __See also:__ [`impute`](https://vega.github.io/vega-lite/docs/impute.html) documentation.
     */
    val impute : Option[ImputeParams] = None,

    /**
     * An object defining properties of the channel's scale, which is the function that
     * transforms values in the data domain (numbers, dates, strings, etc) to visual values
     * (pixels, colors, sizes) of the encoding channels.
     *
     * If `null`, the scale will be [disabled and the data value will be directly
     * encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
     *
     * __Default value:__ If undefined, default [scale
     * properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
     *
     * __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
     */
    val scale : Option[Scale] = None,

    /**
     * Sort order for the encoded field.
     *
     * For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
     * `"descending"`.
     *
     * For discrete fields, `sort` can be one of the following:
     * - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
     * JavaScript.
     * - [A string indicating an encoding channel name to sort
     * by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or
     * `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by
     * x-field, descending). This channel string is short-form of [a sort-by-encoding
     * definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For
     * example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order":
     * "descending"}`.
     * - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
     * for sorting by another field.
     * - [An array specifying the field values in preferred
     * order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
     * sort order will obey the values in the array, followed by any unspecified values in their
     * original order. For discrete time field, values in the sort array can be [date-time
     * definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
     * the values can be the month or day names (case insensitive) or their 3-letter initials
     * (e.g., `"Mon"`, `"Tue"`).
     * - `null` indicating no sort.
     *
     * __Default value:__ `"ascending"`
     *
     * __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
     *
     * __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
     */
    val sort : Option[SortUnion] = None,

    /**
     * Type of stacking offset if the field should be stacked. `stack` is only applicable for
     * `x`, `y`, `theta`, and `radius` channels with continuous domains. For example, `stack` of
     * `y` can be used to customize stacking for a vertical bar chart.
     *
     * `stack` can be one of the following values:
     * - `"zero"` or `true`: stacking with baseline offset at zero value of the scale (for
     * creating typical stacked [bar](https://vega.github.io/vega-lite/docs/stack.html#bar) and
     * [area](https://vega.github.io/vega-lite/docs/stack.html#area) chart).
     * - `"normalize"` - stacking with normalized domain (for creating [normalized stacked bar
     * and area charts](https://vega.github.io/vega-lite/docs/stack.html#normalized) and pie
     * charts [with percentage
     * tooltip](https://vega.github.io/vega-lite/docs/arc.html#tooltip)). <br/>
     * -`"center"` - stacking with center baseline (for
     * [streamgraph](https://vega.github.io/vega-lite/docs/stack.html#streamgraph)).
     * - `null` or `false` - No-stacking. This will produce layered
     * [bar](https://vega.github.io/vega-lite/docs/stack.html#layered-bar-chart) and area
     * chart.
     *
     * __Default value:__ `zero` for plots with all of the following conditions are true: (1)
     * the mark is `bar`, `area`, or `arc`; (2) the stacked measure channel (x or y) has a
     * linear scale; (3) At least one of non-position channels mapped to an unaggregated field
     * that is different from x and y. Otherwise, `null` by default.
     *
     * __See also:__ [`stack`](https://vega.github.io/vega-lite/docs/stack.html) documentation.
     */
    val stack : Option[Stack] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[Type] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[X] = None
) derives Encoder.AsObject, Decoder

case class Axis (
    val aria : Option[Aria] = None,
    val bandPosition : Option[CornerRadius] = None,
    val description : Option[BackgroundUnion] = None,

    /**
     * A boolean flag indicating if the domain (the axis baseline) should be included as part of
     * the axis.
     *
     * __Default value:__ `true`
     */
    val domain : Option[Boolean] = None,

    val domainCap : Option[Cap] = None,
    val domainColor : Option[Color] = None,
    val domainDash : Option[StrokeDash] = None,
    val domainDashOffset : Option[CornerRadius] = None,
    val domainOpacity : Option[CornerRadius] = None,
    val domainWidth : Option[CornerRadius] = None,

    /**
     * When used with the default `"number"` and `"time"` format type, the text formatting
     * pattern for labels of guides (axes, legends, headers) and text marks.
     *
     * - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number
     * format pattern](https://github.com/d3/d3-format#locale_format).
     * - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format
     * pattern](https://github.com/d3/d3-time-format#locale_format).
     *
     * See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for
     * more examples.
     *
     * When used with a [custom
     * `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this
     * value will be passed as `format` alongside `datum.value` to the registered function.
     *
     * __Default value:__  Derived from
     * [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for
     * number format and from
     * [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time
     * format.
     */
    val format : Option[Format] = None,

    /**
     * The format type for labels. One of `"number"`, `"time"`, or a [registered custom format
     * type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).
     *
     * __Default value:__
     * - `"time"` for temporal fields and ordinal and nominal fields with `timeUnit`.
     * - `"number"` for quantitative fields as well as ordinal and nominal fields without
     * `timeUnit`.
     */
    val formatType : Option[String] = None,

    /**
     * A boolean flag indicating if grid lines should be included as part of the axis
     *
     * __Default value:__ `true` for [continuous
     * scales](https://vega.github.io/vega-lite/docs/scale.html#continuous) that are not binned;
     * otherwise, `false`.
     */
    val grid : Option[Boolean] = None,

    val gridCap : Option[Cap] = None,
    val gridColor : Option[GridColorUnion] = None,
    val gridDash : Option[AxisGridDash] = None,
    val gridDashOffset : Option[GridDashOffsetUnion] = None,
    val gridOpacity : Option[GridOpacityUnion] = None,
    val gridWidth : Option[GridWidthUnion] = None,
    val labelAlign : Option[ConditionalAxisPropertyAlignNull] = None,
    val labelAngle : Option[LabelAngle] = None,
    val labelBaseline : Option[TextBaseline] = None,
    val labelBound : Option[Label] = None,
    val labelColor : Option[GridColorUnion] = None,

    /**
     * [Vega expression](https://vega.github.io/vega/docs/expressions/) for customizing labels.
     *
     * __Note:__ The label text and value can be assessed via the `label` and `value` properties
     * of the axis's backing `datum` object.
     */
    val labelExpr : Option[String] = None,

    /**
     * Indicates if the first and last axis labels should be aligned flush with the scale range.
     * Flush alignment for a horizontal axis will left-align the first label and right-align the
     * last label. For vertical axes, bottom and top text baselines are applied instead. If this
     * property is a number, it also indicates the number of pixels by which to offset the first
     * and last labels; for example, a value of 2 will flush-align the first and last labels and
     * also push them 2 pixels outward from the center of the axis. The additional adjustment
     * can sometimes help the labels better visually group with corresponding axis ticks.
     *
     * __Default value:__ `true` for axis of a continuous x-scale. Otherwise, `false`.
     */
    val labelFlush : Option[LabelFlush] = None,

    val labelFlushOffset : Option[CornerRadius] = None,
    val labelFont : Option[ConditionalAxisPropertyStringNull] = None,
    val labelFontSize : Option[GridWidthUnion] = None,
    val labelFontStyle : Option[ConditionalAxisPropertyFontStyleNull] = None,
    val labelFontWeight : Option[FontWeight] = None,
    val labelLimit : Option[CornerRadius] = None,
    val labelLineHeight : Option[CornerRadius] = None,
    val labelOffset : Option[GridDashOffsetUnion] = None,
    val labelOpacity : Option[GridDashOffsetUnion] = None,

    /**
     * The strategy to use for resolving overlap of axis labels. If `false` (the default), no
     * overlap reduction is attempted. If set to `true` or `"parity"`, a strategy of removing
     * every other label is used (this works well for standard linear axes). If set to
     * `"greedy"`, a linear scan of the labels is performed, removing any labels that overlaps
     * with the last visible label (this often works better for log-scaled axes).
     *
     * __Default value:__ `true` for non-nominal fields with non-log scales; `"greedy"` for log
     * scales; otherwise `false`.
     */
    val labelOverlap : Option[LabelOverlap] = None,

    val labelPadding : Option[GridDashOffsetUnion] = None,

    /**
     * A boolean flag indicating if labels should be included as part of the axis.
     *
     * __Default value:__ `true`.
     */
    val labels : Option[Boolean] = None,

    val labelSeparation : Option[CornerRadius] = None,
    val maxExtent : Option[CornerRadius] = None,
    val minExtent : Option[CornerRadius] = None,

    /**
     * The offset, in pixels, by which to displace the axis from the edge of the enclosing group
     * or data rectangle.
     *
     * __Default value:__ derived from the [axis
     * config](https://vega.github.io/vega-lite/docs/config.html#facet-scale-config)'s `offset`
     * (`0` by default)
     */
    val offset : Option[CornerRadius] = None,

    /**
     * The orientation of the axis. One of `"top"`, `"bottom"`, `"left"` or `"right"`. The
     * orientation can be used to further specialize the axis type (e.g., a y-axis oriented
     * towards the right edge of the chart).
     *
     * __Default value:__ `"bottom"` for x-axes and `"left"` for y-axes.
     */
    val orient : Option[TitleOrientUnion] = None,

    /**
     * The anchor position of the axis in pixels. For x-axes with top or bottom orientation,
     * this sets the axis group x coordinate. For y-axes with left or right orientation, this
     * sets the axis group y coordinate.
     *
     * __Default value__: `0`
     */
    val position : Option[CornerRadius] = None,

    /**
     * A string or array of strings indicating the name of custom styles to apply to the axis. A
     * style is a named collection of axis property defined within the [style
     * configuration](https://vega.github.io/vega-lite/docs/mark.html#style-config). If style is
     * an array, later styles will override earlier styles.
     *
     * __Default value:__ (none) __Note:__ Any specified style will augment the default style.
     * For example, an x-axis mark with `"style": "foo"` will use `config.axisX` and
     * `config.style.foo` (the specified style `"foo"` has higher precedence).
     */
    val style : Option[Text] = None,

    val tickBand : Option[TickBandUnion] = None,
    val tickCap : Option[Cap] = None,
    val tickColor : Option[GridColorUnion] = None,

    /**
     * A desired number of ticks, for axes visualizing quantitative scales. The resulting number
     * may be different so that values are "nice" (multiples of 2, 5, 10) and lie within the
     * underlying scale's range.
     *
     * For scales of type `"time"` or `"utc"`, the tick count can instead be a time interval
     * specifier. Legal string values are `"millisecond"`, `"second"`, `"minute"`, `"hour"`,
     * `"day"`, `"week"`, `"month"`, and `"year"`. Alternatively, an object-valued interval
     * specifier of the form `{"interval": "month", "step": 3}` includes a desired number of
     * interval steps. Here, ticks are generated for each quarter (Jan, Apr, Jul, Oct)
     * boundary.
     *
     * __Default value__: Determine using a formula `ceil(width/40)` for x and `ceil(height/40)`
     * for y.
     */
    val tickCount : Option[TickCount] = None,

    val tickDash : Option[AxisTickDash] = None,
    val tickDashOffset : Option[GridDashOffsetUnion] = None,

    /**
     * Boolean flag indicating if an extra axis tick should be added for the initial position of
     * the axis. This flag is useful for styling axes for `band` scales such that ticks are
     * placed on band boundaries rather in the middle of a band. Use in conjunction with
     * `"bandPosition": 1` and an axis `"padding"` value of `0`.
     */
    val tickExtra : Option[Boolean] = None,

    /**
     * The minimum desired step between axis ticks, in terms of scale domain values. For
     * example, a value of `1` indicates that ticks should not be less than 1 unit apart. If
     * `tickMinStep` is specified, the `tickCount` value will be adjusted, if necessary, to
     * enforce the minimum step value.
     */
    val tickMinStep : Option[CornerRadius] = None,

    val tickOffset : Option[CornerRadius] = None,
    val tickOpacity : Option[GridDashOffsetUnion] = None,

    /**
     * Boolean flag indicating if pixel position values should be rounded to the nearest
     * integer.
     *
     * __Default value:__ `true`
     */
    val tickRound : Option[Boolean] = None,

    /**
     * Boolean value that determines whether the axis should include ticks.
     *
     * __Default value:__ `true`
     */
    val ticks : Option[Boolean] = None,

    val tickSize : Option[GridWidthUnion] = None,
    val tickWidth : Option[GridWidthUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    val titleAlign : Option[TitleAlignUnion] = None,
    val titleAnchor : Option[TitleAnchorUnion] = None,
    val titleAngle : Option[CornerRadius] = None,
    val titleBaseline : Option[BackgroundUnion] = None,
    val titleColor : Option[Color] = None,
    val titleFont : Option[BackgroundUnion] = None,
    val titleFontSize : Option[FontSize] = None,
    val titleFontStyle : Option[BackgroundUnion] = None,
    val titleFontWeight : Option[FontWeightUnion] = None,
    val titleLimit : Option[FontSize] = None,
    val titleLineHeight : Option[CornerRadius] = None,
    val titleOpacity : Option[CornerRadius] = None,
    val titlePadding : Option[CornerRadius] = None,
    val titleX : Option[CornerRadius] = None,
    val titleY : Option[CornerRadius] = None,
    val translate : Option[CornerRadius] = None,

    /**
     * Explicitly set the visible axis tick values.
     */
    val values : Option[Values] = None,

    /**
     * A non-negative integer indicating the z-index of the axis. If zindex is 0, axes should be
     * drawn behind all chart elements. To put them in front, set `zindex` to `1` or more.
     *
     * __Default value:__ `0` (behind the marks).
     */
    val zindex : Option[Double] = None
) derives Encoder.AsObject, Decoder

type Cap = BackgroundExprRef | StrokeCap
given Decoder[Cap] = {
    List[Decoder[Cap]](
        Decoder[BackgroundExprRef].widen,
        Decoder[StrokeCap].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Cap] = Encoder.instance {
    case enc0 : BackgroundExprRef => Encoder.AsObject[BackgroundExprRef].apply(enc0)
    case enc1 : StrokeCap => summon[Encoder[StrokeCap]].apply(enc1)
}

/**
 * The stroke cap for line ending style. One of `"butt"`, `"round"`, or `"square"`.
 *
 * __Default value:__ `"butt"`
 *
 * The stroke cap for the domain line's ending style. One of `"butt"`, `"round"` or
 * `"square"`.
 *
 * __Default value:__ `"butt"`
 *
 * The stroke cap for grid lines' ending style. One of `"butt"`, `"round"` or `"square"`.
 *
 * __Default value:__ `"butt"`
 *
 * The stroke cap for the tick lines' ending style. One of `"butt"`, `"round"` or
 * `"square"`.
 *
 * __Default value:__ `"butt"`
 */

enum StrokeCap : 
    case butt
    case round
    case square
given Decoder[StrokeCap] = Decoder.decodeString.emapTry(x => Try(StrokeCap.valueOf(x) )) 
given Encoder[StrokeCap] = Encoder.encodeString.contramap(_.toString())

type GridColorUnion = GridColorExprRef | String | NullValue
given Decoder[GridColorUnion] = {
    List[Decoder[GridColorUnion]](
        Decoder[GridColorExprRef].widen,
        Decoder[String].widen,
        Decoder[NullValue].widen,
    ).reduceLeft(_ or _)
}

given Encoder[GridColorUnion] = Encoder.instance {
    case enc0 : GridColorExprRef => Encoder.AsObject[GridColorExprRef].apply(enc0)
    case enc1 : String => Encoder.encodeString(enc1)
    case enc2 : NullValue => Encoder.encodeNone(enc2)
}

case class GridColorExprRef (
    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None,

    val condition : Option[ConditionUnion] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[String] = None
) derives Encoder.AsObject, Decoder

type ConditionUnion = ConditionClass | Seq[ConditionalPredicateValueDefColorNullExprRef]
given Decoder[ConditionUnion] = {
    List[Decoder[ConditionUnion]](
        Decoder[ConditionClass].widen,
        Decoder[Seq[ConditionalPredicateValueDefColorNullExprRef]].widen,
    ).reduceLeft(_ or _)
}

given Encoder[ConditionUnion] = Encoder.instance {
    case enc0 : ConditionClass => Encoder.AsObject[ConditionClass].apply(enc0)
    case enc1 : Seq[ConditionalPredicateValueDefColorNullExprRef] => Encoder.encodeSeq[ConditionalPredicateValueDefColorNullExprRef].apply(enc1)
}

case class ConditionalPredicateValueDefColorNullExprRef (
    /**
     * Predicate for triggering the condition
     */
    val test : PredicateComposition,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[String] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None
) derives Encoder.AsObject, Decoder

case class ConditionClass (
    /**
     * Predicate for triggering the condition
     */
    val test : PredicateComposition,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[String] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None
) derives Encoder.AsObject, Decoder

type AxisGridDash = Seq[Double] | PurpleExprRef
given Decoder[AxisGridDash] = {
    List[Decoder[AxisGridDash]](
        Decoder[Seq[Double]].widen,
        Decoder[PurpleExprRef].widen,
    ).reduceLeft(_ or _)
}

given Encoder[AxisGridDash] = Encoder.instance {
    case enc0 : Seq[Double] => Encoder.encodeSeq[Double].apply(enc0)
    case enc1 : PurpleExprRef => Encoder.AsObject[PurpleExprRef].apply(enc1)
}

case class PurpleExprRef (
    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None,

    val condition : Option[TentacledConditionalPredicateValueDefNumberNullExprRef] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Seq[Double]] = None
) derives Encoder.AsObject, Decoder

type TentacledConditionalPredicateValueDefNumberNullExprRef = Seq[ConditionalPredicateValueDefNumberNullExprRef] | PurpleConditionalPredicateValueDefNumberNullExprRef
given Decoder[TentacledConditionalPredicateValueDefNumberNullExprRef] = {
    List[Decoder[TentacledConditionalPredicateValueDefNumberNullExprRef]](
        Decoder[Seq[ConditionalPredicateValueDefNumberNullExprRef]].widen,
        Decoder[PurpleConditionalPredicateValueDefNumberNullExprRef].widen,
    ).reduceLeft(_ or _)
}

given Encoder[TentacledConditionalPredicateValueDefNumberNullExprRef] = Encoder.instance {
    case enc0 : Seq[ConditionalPredicateValueDefNumberNullExprRef] => Encoder.encodeSeq[ConditionalPredicateValueDefNumberNullExprRef].apply(enc0)
    case enc1 : PurpleConditionalPredicateValueDefNumberNullExprRef => Encoder.AsObject[PurpleConditionalPredicateValueDefNumberNullExprRef].apply(enc1)
}

case class ConditionalPredicateValueDefNumberNullExprRef (
    /**
     * Predicate for triggering the condition
     */
    val test : PredicateComposition,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Seq[Double]] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None
) derives Encoder.AsObject, Decoder

case class PurpleConditionalPredicateValueDefNumberNullExprRef (
    /**
     * Predicate for triggering the condition
     */
    val test : PredicateComposition,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Seq[Double]] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None
) derives Encoder.AsObject, Decoder

type GridDashOffsetUnion = Double | GridDashOffsetExprRef
given Decoder[GridDashOffsetUnion] = {
    List[Decoder[GridDashOffsetUnion]](
        Decoder[Double].widen,
        Decoder[GridDashOffsetExprRef].widen,
    ).reduceLeft(_ or _)
}

given Encoder[GridDashOffsetUnion] = Encoder.instance {
    case enc0 : Double => Encoder.encodeDouble(enc0)
    case enc1 : GridDashOffsetExprRef => Encoder.AsObject[GridDashOffsetExprRef].apply(enc1)
}

case class GridDashOffsetExprRef (
    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None,

    val condition : Option[StickyConditionalPredicateValueDefNumberNullExprRef] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Double] = None
) derives Encoder.AsObject, Decoder

type StickyConditionalPredicateValueDefNumberNullExprRef = Seq[ConditionalPredicateValueDefNumberNullExprRefElement] | FluffyConditionalPredicateValueDefNumberNullExprRef
given Decoder[StickyConditionalPredicateValueDefNumberNullExprRef] = {
    List[Decoder[StickyConditionalPredicateValueDefNumberNullExprRef]](
        Decoder[Seq[ConditionalPredicateValueDefNumberNullExprRefElement]].widen,
        Decoder[FluffyConditionalPredicateValueDefNumberNullExprRef].widen,
    ).reduceLeft(_ or _)
}

given Encoder[StickyConditionalPredicateValueDefNumberNullExprRef] = Encoder.instance {
    case enc0 : Seq[ConditionalPredicateValueDefNumberNullExprRefElement] => Encoder.encodeSeq[ConditionalPredicateValueDefNumberNullExprRefElement].apply(enc0)
    case enc1 : FluffyConditionalPredicateValueDefNumberNullExprRef => Encoder.AsObject[FluffyConditionalPredicateValueDefNumberNullExprRef].apply(enc1)
}

case class ConditionalPredicateValueDefNumberNullExprRefElement (
    /**
     * Predicate for triggering the condition
     */
    val test : PredicateComposition,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Double] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None
) derives Encoder.AsObject, Decoder

case class FluffyConditionalPredicateValueDefNumberNullExprRef (
    /**
     * Predicate for triggering the condition
     */
    val test : PredicateComposition,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Double] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None
) derives Encoder.AsObject, Decoder

type GridOpacityUnion = Double | GridOpacityExprRef
given Decoder[GridOpacityUnion] = {
    List[Decoder[GridOpacityUnion]](
        Decoder[Double].widen,
        Decoder[GridOpacityExprRef].widen,
    ).reduceLeft(_ or _)
}

given Encoder[GridOpacityUnion] = Encoder.instance {
    case enc0 : Double => Encoder.encodeDouble(enc0)
    case enc1 : GridOpacityExprRef => Encoder.AsObject[GridOpacityExprRef].apply(enc1)
}

case class GridOpacityExprRef (
    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None,

    val condition : Option[StickyConditionalPredicateValueDefNumberNullExprRef] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Double] = None
) derives Encoder.AsObject, Decoder

type GridWidthUnion = Double | GridWidthExprRef
given Decoder[GridWidthUnion] = {
    List[Decoder[GridWidthUnion]](
        Decoder[Double].widen,
        Decoder[GridWidthExprRef].widen,
    ).reduceLeft(_ or _)
}

given Encoder[GridWidthUnion] = Encoder.instance {
    case enc0 : Double => Encoder.encodeDouble(enc0)
    case enc1 : GridWidthExprRef => Encoder.AsObject[GridWidthExprRef].apply(enc1)
}

case class GridWidthExprRef (
    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None,

    val condition : Option[StickyConditionalPredicateValueDefNumberNullExprRef] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Double] = None
) derives Encoder.AsObject, Decoder

type ConditionalAxisPropertyAlignNull = Align | FluffyExprRef
given Decoder[ConditionalAxisPropertyAlignNull] = {
    List[Decoder[ConditionalAxisPropertyAlignNull]](
        Decoder[Align].widen,
        Decoder[FluffyExprRef].widen,
    ).reduceLeft(_ or _)
}

given Encoder[ConditionalAxisPropertyAlignNull] = Encoder.instance {
    case enc0 : Align => summon[Encoder[Align]].apply(enc0)
    case enc1 : FluffyExprRef => Encoder.AsObject[FluffyExprRef].apply(enc1)
}

case class FluffyExprRef (
    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None,

    val condition : Option[ExprRefCondition] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Align] = None
) derives Encoder.AsObject, Decoder

type ExprRefCondition = ConditionCondition | Seq[ConditionalPredicateValueDefAlignNullExprRef]
given Decoder[ExprRefCondition] = {
    List[Decoder[ExprRefCondition]](
        Decoder[ConditionCondition].widen,
        Decoder[Seq[ConditionalPredicateValueDefAlignNullExprRef]].widen,
    ).reduceLeft(_ or _)
}

given Encoder[ExprRefCondition] = Encoder.instance {
    case enc0 : ConditionCondition => Encoder.AsObject[ConditionCondition].apply(enc0)
    case enc1 : Seq[ConditionalPredicateValueDefAlignNullExprRef] => Encoder.encodeSeq[ConditionalPredicateValueDefAlignNullExprRef].apply(enc1)
}

case class ConditionalPredicateValueDefAlignNullExprRef (
    /**
     * Predicate for triggering the condition
     */
    val test : PredicateComposition,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Align] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None
) derives Encoder.AsObject, Decoder

case class ConditionCondition (
    /**
     * Predicate for triggering the condition
     */
    val test : PredicateComposition,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Align] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None
) derives Encoder.AsObject, Decoder

type LabelAngle = BackgroundExprRef | Double
type TextBaseline = String | TentacledExprRef
given Decoder[TextBaseline] = {
    List[Decoder[TextBaseline]](
        Decoder[String].widen,
        Decoder[TentacledExprRef].widen,
    ).reduceLeft(_ or _)
}

given Encoder[TextBaseline] = Encoder.instance {
    case enc0 : String => Encoder.encodeString(enc0)
    case enc1 : TentacledExprRef => Encoder.AsObject[TentacledExprRef].apply(enc1)
}

case class TentacledExprRef (
    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None,

    val condition : Option[ExprRefConditionUnion] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[String] = None
) derives Encoder.AsObject, Decoder

type ExprRefConditionUnion = ConditionConditionClass | Seq[ConditionalPredicateValueDefTextBaselineNullExprRef]
given Decoder[ExprRefConditionUnion] = {
    List[Decoder[ExprRefConditionUnion]](
        Decoder[ConditionConditionClass].widen,
        Decoder[Seq[ConditionalPredicateValueDefTextBaselineNullExprRef]].widen,
    ).reduceLeft(_ or _)
}

given Encoder[ExprRefConditionUnion] = Encoder.instance {
    case enc0 : ConditionConditionClass => Encoder.AsObject[ConditionConditionClass].apply(enc0)
    case enc1 : Seq[ConditionalPredicateValueDefTextBaselineNullExprRef] => Encoder.encodeSeq[ConditionalPredicateValueDefTextBaselineNullExprRef].apply(enc1)
}

case class ConditionalPredicateValueDefTextBaselineNullExprRef (
    /**
     * Predicate for triggering the condition
     */
    val test : PredicateComposition,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[String] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None
) derives Encoder.AsObject, Decoder

case class ConditionConditionClass (
    /**
     * Predicate for triggering the condition
     */
    val test : PredicateComposition,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[String] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None
) derives Encoder.AsObject, Decoder

type Label = BackgroundExprRef | Boolean | Double
given Decoder[Label] = {
    List[Decoder[Label]](
        Decoder[BackgroundExprRef].widen,
        Decoder[Boolean].widen,
        Decoder[Double].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Label] = Encoder.instance {
    case enc0 : BackgroundExprRef => Encoder.AsObject[BackgroundExprRef].apply(enc0)
    case enc1 : Boolean => Encoder.encodeBoolean(enc1)
    case enc2 : Double => Encoder.encodeDouble(enc2)
}

/**
 * Indicates if labels should be hidden if they exceed the axis range. If `false` (the
 * default) no bounds overlap analysis is performed. If `true`, labels will be hidden if
 * they exceed the axis range by more than 1 pixel. If this property is a number, it
 * specifies the pixel tolerance: the maximum amount by which a label bounding box may
 * exceed the axis range.
 *
 * __Default value:__ `false`.
 *
 * Indicates if the first and last axis labels should be aligned flush with the scale range.
 * Flush alignment for a horizontal axis will left-align the first label and right-align the
 * last label. For vertical axes, bottom and top text baselines are applied instead. If this
 * property is a number, it also indicates the number of pixels by which to offset the first
 * and last labels; for example, a value of 2 will flush-align the first and last labels and
 * also push them 2 pixels outward from the center of the axis. The additional adjustment
 * can sometimes help the labels better visually group with corresponding axis ticks.
 *
 * __Default value:__ `true` for axis of a continuous x-scale. Otherwise, `false`.
 */
type LabelFlush = Boolean | Double
given Decoder[LabelFlush] = {
    List[Decoder[LabelFlush]](
        Decoder[Boolean].widen,
        Decoder[Double].widen,
    ).reduceLeft(_ or _)
}

given Encoder[LabelFlush] = Encoder.instance {
    case enc0 : Boolean => Encoder.encodeBoolean(enc0)
    case enc1 : Double => Encoder.encodeDouble(enc1)
}

type ConditionalAxisPropertyStringNull = StickyExprRef | String
given Decoder[ConditionalAxisPropertyStringNull] = {
    List[Decoder[ConditionalAxisPropertyStringNull]](
        Decoder[StickyExprRef].widen,
        Decoder[String].widen,
    ).reduceLeft(_ or _)
}

given Encoder[ConditionalAxisPropertyStringNull] = Encoder.instance {
    case enc0 : StickyExprRef => Encoder.AsObject[StickyExprRef].apply(enc0)
    case enc1 : String => Encoder.encodeString(enc1)
}

case class StickyExprRef (
    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None,

    val condition : Option[FluffyConditionalPredicateValueDefStringNullExprRef] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[String] = None
) derives Encoder.AsObject, Decoder

type FluffyConditionalPredicateValueDefStringNullExprRef = Seq[ConditionalPredicateValueDefStringNullExprRef] | PurpleConditionalPredicateValueDefStringNullExprRef
given Decoder[FluffyConditionalPredicateValueDefStringNullExprRef] = {
    List[Decoder[FluffyConditionalPredicateValueDefStringNullExprRef]](
        Decoder[Seq[ConditionalPredicateValueDefStringNullExprRef]].widen,
        Decoder[PurpleConditionalPredicateValueDefStringNullExprRef].widen,
    ).reduceLeft(_ or _)
}

given Encoder[FluffyConditionalPredicateValueDefStringNullExprRef] = Encoder.instance {
    case enc0 : Seq[ConditionalPredicateValueDefStringNullExprRef] => Encoder.encodeSeq[ConditionalPredicateValueDefStringNullExprRef].apply(enc0)
    case enc1 : PurpleConditionalPredicateValueDefStringNullExprRef => Encoder.AsObject[PurpleConditionalPredicateValueDefStringNullExprRef].apply(enc1)
}

case class ConditionalPredicateValueDefStringNullExprRef (
    /**
     * Predicate for triggering the condition
     */
    val test : PredicateComposition,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[String] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None
) derives Encoder.AsObject, Decoder

case class PurpleConditionalPredicateValueDefStringNullExprRef (
    /**
     * Predicate for triggering the condition
     */
    val test : PredicateComposition,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[String] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None
) derives Encoder.AsObject, Decoder

type ConditionalAxisPropertyFontStyleNull = IndigoExprRef | String
given Decoder[ConditionalAxisPropertyFontStyleNull] = {
    List[Decoder[ConditionalAxisPropertyFontStyleNull]](
        Decoder[IndigoExprRef].widen,
        Decoder[String].widen,
    ).reduceLeft(_ or _)
}

given Encoder[ConditionalAxisPropertyFontStyleNull] = Encoder.instance {
    case enc0 : IndigoExprRef => Encoder.AsObject[IndigoExprRef].apply(enc0)
    case enc1 : String => Encoder.encodeString(enc1)
}

case class IndigoExprRef (
    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None,

    val condition : Option[FluffyConditionalPredicateValueDefFontStyleNullExprRef] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[String] = None
) derives Encoder.AsObject, Decoder

type FluffyConditionalPredicateValueDefFontStyleNullExprRef = Seq[ConditionalPredicateValueDefFontStyleNullExprRef] | PurpleConditionalPredicateValueDefFontStyleNullExprRef
given Decoder[FluffyConditionalPredicateValueDefFontStyleNullExprRef] = {
    List[Decoder[FluffyConditionalPredicateValueDefFontStyleNullExprRef]](
        Decoder[Seq[ConditionalPredicateValueDefFontStyleNullExprRef]].widen,
        Decoder[PurpleConditionalPredicateValueDefFontStyleNullExprRef].widen,
    ).reduceLeft(_ or _)
}

given Encoder[FluffyConditionalPredicateValueDefFontStyleNullExprRef] = Encoder.instance {
    case enc0 : Seq[ConditionalPredicateValueDefFontStyleNullExprRef] => Encoder.encodeSeq[ConditionalPredicateValueDefFontStyleNullExprRef].apply(enc0)
    case enc1 : PurpleConditionalPredicateValueDefFontStyleNullExprRef => Encoder.AsObject[PurpleConditionalPredicateValueDefFontStyleNullExprRef].apply(enc1)
}

case class ConditionalPredicateValueDefFontStyleNullExprRef (
    /**
     * Predicate for triggering the condition
     */
    val test : PredicateComposition,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[String] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None
) derives Encoder.AsObject, Decoder

case class PurpleConditionalPredicateValueDefFontStyleNullExprRef (
    /**
     * Predicate for triggering the condition
     */
    val test : PredicateComposition,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[String] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None
) derives Encoder.AsObject, Decoder

type FontWeight = Double | FontWeightEnum | IndecentExprRef
given Decoder[FontWeight] = {
    List[Decoder[FontWeight]](
        Decoder[Double].widen,
        Decoder[FontWeightEnum].widen,
        Decoder[IndecentExprRef].widen,
    ).reduceLeft(_ or _)
}

given Encoder[FontWeight] = Encoder.instance {
    case enc0 : Double => Encoder.encodeDouble(enc0)
    case enc1 : FontWeightEnum => summon[Encoder[FontWeightEnum]].apply(enc1)
    case enc2 : IndecentExprRef => Encoder.AsObject[IndecentExprRef].apply(enc2)
}

case class IndecentExprRef (
    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None,

    val condition : Option[FluffyConditionalPredicateValueDefFontWeightNullExprRef] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[ValueUnion] = None
) derives Encoder.AsObject, Decoder

type FluffyConditionalPredicateValueDefFontWeightNullExprRef = Seq[ConditionalPredicateValueDefFontWeightNullExprRef] | PurpleConditionalPredicateValueDefFontWeightNullExprRef
given Decoder[FluffyConditionalPredicateValueDefFontWeightNullExprRef] = {
    List[Decoder[FluffyConditionalPredicateValueDefFontWeightNullExprRef]](
        Decoder[Seq[ConditionalPredicateValueDefFontWeightNullExprRef]].widen,
        Decoder[PurpleConditionalPredicateValueDefFontWeightNullExprRef].widen,
    ).reduceLeft(_ or _)
}

given Encoder[FluffyConditionalPredicateValueDefFontWeightNullExprRef] = Encoder.instance {
    case enc0 : Seq[ConditionalPredicateValueDefFontWeightNullExprRef] => Encoder.encodeSeq[ConditionalPredicateValueDefFontWeightNullExprRef].apply(enc0)
    case enc1 : PurpleConditionalPredicateValueDefFontWeightNullExprRef => Encoder.AsObject[PurpleConditionalPredicateValueDefFontWeightNullExprRef].apply(enc1)
}

case class ConditionalPredicateValueDefFontWeightNullExprRef (
    /**
     * Predicate for triggering the condition
     */
    val test : PredicateComposition,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[ValueUnion] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None
) derives Encoder.AsObject, Decoder

type ValueUnion = Double | FontWeightEnum | NullValue
given Decoder[ValueUnion] = {
    List[Decoder[ValueUnion]](
        Decoder[Double].widen,
        Decoder[FontWeightEnum].widen,
        Decoder[NullValue].widen,
    ).reduceLeft(_ or _)
}

given Encoder[ValueUnion] = Encoder.instance {
    case enc0 : Double => Encoder.encodeDouble(enc0)
    case enc1 : FontWeightEnum => summon[Encoder[FontWeightEnum]].apply(enc1)
    case enc2 : NullValue => Encoder.encodeNone(enc2)
}

case class PurpleConditionalPredicateValueDefFontWeightNullExprRef (
    /**
     * Predicate for triggering the condition
     */
    val test : PredicateComposition,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[ValueUnion] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None
) derives Encoder.AsObject, Decoder

/**
 * A string or array of strings indicating the name of custom styles to apply to the mark. A
 * style is a named collection of mark property defaults defined within the [style
 * configuration](https://vega.github.io/vega-lite/docs/mark.html#style-config). If style is
 * an array, later styles will override earlier styles. Any [mark
 * properties](https://vega.github.io/vega-lite/docs/encoding.html#mark-prop) explicitly
 * defined within the `encoding` will override a style default.
 *
 * __Default value:__ The mark's name. For example, a bar mark will have style `"bar"` by
 * default. __Note:__ Any specified style will augment the default style. For example, a bar
 * mark with `"style": "foo"` will receive from `config.style.bar` and `config.style.foo`
 * (the specified style `"foo"` has higher precedence).
 *
 * A string or array of strings indicating the name of custom styles to apply to the axis. A
 * style is a named collection of axis property defined within the [style
 * configuration](https://vega.github.io/vega-lite/docs/mark.html#style-config). If style is
 * an array, later styles will override earlier styles.
 *
 * __Default value:__ (none) __Note:__ Any specified style will augment the default style.
 * For example, an x-axis mark with `"style": "foo"` will use `config.axisX` and
 * `config.style.foo` (the specified style `"foo"` has higher precedence).
 *
 * A [mark style property](https://vega.github.io/vega-lite/docs/config.html#style) to apply
 * to the title text mark.
 *
 * __Default value:__ `"group-title"`.
 *
 * Placeholder text if the `text` channel is not specified
 *
 * The subtitle Text.
 *
 * A string or array of strings indicating the name of custom styles to apply to the view
 * background. A style is a named collection of mark property defaults defined within the
 * [style configuration](https://vega.github.io/vega-lite/docs/mark.html#style-config). If
 * style is an array, later styles will override earlier styles.
 *
 * __Default value:__ `"cell"` __Note:__ Any specified view background properties will
 * augment the default style.
 */
type Text = Seq[String] | String
given Decoder[Text] = {
    List[Decoder[Text]](
        Decoder[Seq[String]].widen,
        Decoder[String].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Text] = Encoder.instance {
    case enc0 : Seq[String] => Encoder.encodeSeq[String].apply(enc0)
    case enc1 : String => Encoder.encodeString(enc1)
}

type TickBandUnion = BackgroundExprRef | TickBandEnum
given Decoder[TickBandUnion] = {
    List[Decoder[TickBandUnion]](
        Decoder[BackgroundExprRef].widen,
        Decoder[TickBandEnum].widen,
    ).reduceLeft(_ or _)
}

given Encoder[TickBandUnion] = Encoder.instance {
    case enc0 : BackgroundExprRef => Encoder.AsObject[BackgroundExprRef].apply(enc0)
    case enc1 : TickBandEnum => summon[Encoder[TickBandEnum]].apply(enc1)
}

/**
 * For band scales, indicates if ticks and grid lines should be placed at the `"center"` of
 * a band (default) or at the band `"extent"`s to indicate intervals
 */

enum TickBandEnum : 
    case center
    case extent
given Decoder[TickBandEnum] = Decoder.decodeString.emapTry(x => Try(TickBandEnum.valueOf(x) )) 
given Encoder[TickBandEnum] = Encoder.encodeString.contramap(_.toString())

type AxisTickDash = Seq[Double] | HilariousExprRef
given Decoder[AxisTickDash] = {
    List[Decoder[AxisTickDash]](
        Decoder[Seq[Double]].widen,
        Decoder[HilariousExprRef].widen,
    ).reduceLeft(_ or _)
}

given Encoder[AxisTickDash] = Encoder.instance {
    case enc0 : Seq[Double] => Encoder.encodeSeq[Double].apply(enc0)
    case enc1 : HilariousExprRef => Encoder.AsObject[HilariousExprRef].apply(enc1)
}

case class HilariousExprRef (
    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None,

    val condition : Option[TentacledConditionalPredicateValueDefNumberNullExprRef] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Seq[Double]] = None
) derives Encoder.AsObject, Decoder

case class ImputeParams (
    /**
     * A frame specification as a two-element array used to control the window over which the
     * specified method is applied. The array entries should either be a number indicating the
     * offset from the current data object, or null to indicate unbounded rows preceding or
     * following the current data object. For example, the value `[-5, 5]` indicates that the
     * window should include five objects preceding and five objects following the current
     * object.
     *
     * __Default value:__:  `[null, null]` indicating that the window includes all objects.
     */
    val frame : Option[Seq[Option[Double]]] = None,

    /**
     * Defines the key values that should be considered for imputation. An array of key values
     * or an object defining a [number
     * sequence](https://vega.github.io/vega-lite/docs/impute.html#sequence-def).
     *
     * If provided, this will be used in addition to the key values observed within the input
     * data. If not provided, the values will be derived from all unique values of the `key`
     * field. For `impute` in `encoding`, the key field is the x-field if the y-field is
     * imputed, or vice versa.
     *
     * If there is no impute grouping, this property _must_ be specified.
     */
    val keyvals : Option[Keyvals] = None,

    /**
     * The imputation method to use for the field value of imputed data objects. One of
     * `"value"`, `"mean"`, `"median"`, `"max"` or `"min"`.
     *
     * __Default value:__  `"value"`
     */
    val method : Option[ImputeParamsMethod] = None,

    /**
     * The field value to use when the imputation `method` is `"value"`.
     */
    val value : Option[Json] = None
) derives Encoder.AsObject, Decoder

type Keyvals = Seq[Option[Json]] | ImputeSequence
given Decoder[Keyvals] = {
    List[Decoder[Keyvals]](
        Decoder[Seq[Option[Json]]].widen,
        Decoder[ImputeSequence].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Keyvals] = Encoder.instance {
    case enc0 : Seq[Option[Json]] => Encoder.encodeSeq[Option[Json]].apply(enc0)
    case enc1 : ImputeSequence => Encoder.AsObject[ImputeSequence].apply(enc1)
}

case class ImputeSequence (
    /**
     * The starting value of the sequence. __Default value:__ `0`
     */
    val start : Option[Double] = None,

    /**
     * The step value between sequence entries. __Default value:__ `1` or `-1` if `stop < start`
     */
    val step : Option[Double] = None,

    /**
     * The ending value(exclusive) of the sequence.
     */
    val stop : Double
) derives Encoder.AsObject, Decoder

/**
 * The imputation method to use for the field value of imputed data objects. One of
 * `"value"`, `"mean"`, `"median"`, `"max"` or `"min"`.
 *
 * __Default value:__  `"value"`
 */

enum ImputeParamsMethod : 
    case max
    case mean
    case median
    case min
    case value
given Decoder[ImputeParamsMethod] = Decoder.decodeString.emapTry(x => Try(ImputeParamsMethod.valueOf(x) )) 
given Encoder[ImputeParamsMethod] = Encoder.encodeString.contramap(_.toString())

/**
 * Latitude-2 position for geographically projected ranged `"area"`, `"bar"`, `"rect"`, and
 * `"rule"`.
 *
 * Longitude-2 position for geographically projected ranged `"area"`, `"bar"`, `"rect"`,
 * and  `"rule"`.
 *
 * The inner radius in pixels of arc marks.
 *
 * The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing
 * values proceed clockwise.
 *
 * X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
 *
 * The `value` of this channel can be a number or a string `"width"` for the width of the
 * plot.
 *
 * Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
 *
 * The `value` of this channel can be a number or a string `"height"` for the height of the
 * plot.
 *
 * A field definition of a secondary channel that shares a scale with another primary
 * channel. For example, `x2`, `xError` and `xError2` share the same scale with `x`.
 *
 * Definition object for a constant value (primitive value or gradient definition) of an
 * encoding channel.
 */
case class X2Class (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[Json] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[Type] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[X] = None
) derives Encoder.AsObject, Decoder

/**
 * Error value of x coordinates for error specified `"errorbar"` and `"errorband"`.
 *
 * Secondary error value of x coordinates for error specified `"errorbar"` and
 * `"errorband"`.
 *
 * Error value of y coordinates for error specified `"errorbar"` and `"errorband"`.
 *
 * Secondary error value of y coordinates for error specified `"errorbar"` and
 * `"errorband"`.
 *
 * A field definition of a secondary channel that shares a scale with another primary
 * channel. For example, `x2`, `xError` and `xError2` share the same scale with `x`.
 *
 * Definition object for a constant value (primitive value or gradient definition) of an
 * encoding channel.
 */
case class XErrorClass (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[Json] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Double] = None
) derives Encoder.AsObject, Decoder

/**
 * Error value of x coordinates for error specified `"errorbar"` and `"errorband"`.
 *
 * Secondary error value of x coordinates for error specified `"errorbar"` and
 * `"errorband"`.
 *
 * Error value of y coordinates for error specified `"errorbar"` and `"errorband"`.
 *
 * Secondary error value of y coordinates for error specified `"errorbar"` and
 * `"errorband"`.
 *
 * A field definition of a secondary channel that shares a scale with another primary
 * channel. For example, `x2`, `xError` and `xError2` share the same scale with `x`.
 *
 * Definition object for a constant value (primitive value or gradient definition) of an
 * encoding channel.
 */
case class XError2Class (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[Json] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Double] = None
) derives Encoder.AsObject, Decoder

/**
 * Offset of x-position of the marks
 *
 * Offset of y-position of the marks
 *
 * Definition object for a constant value (primitive value or gradient definition) of an
 * encoding channel.
 */
case class XOffsetClass (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[AngleBin] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * An object defining properties of the channel's scale, which is the function that
     * transforms values in the data domain (numbers, dates, strings, etc) to visual values
     * (pixels, colors, sizes) of the encoding channels.
     *
     * If `null`, the scale will be [disabled and the data value will be directly
     * encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
     *
     * __Default value:__ If undefined, default [scale
     * properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
     *
     * __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
     */
    val scale : Option[Scale] = None,

    /**
     * Sort order for the encoded field.
     *
     * For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
     * `"descending"`.
     *
     * For discrete fields, `sort` can be one of the following:
     * - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
     * JavaScript.
     * - [A string indicating an encoding channel name to sort
     * by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or
     * `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by
     * x-field, descending). This channel string is short-form of [a sort-by-encoding
     * definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For
     * example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order":
     * "descending"}`.
     * - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
     * for sorting by another field.
     * - [An array specifying the field values in preferred
     * order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
     * sort order will obey the values in the array, followed by any unspecified values in their
     * original order. For discrete time field, values in the sort array can be [date-time
     * definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
     * the values can be the month or day names (case insensitive) or their 3-letter initials
     * (e.g., `"Mon"`, `"Tue"`).
     * - `null` indicating no sort.
     *
     * __Default value:__ `"ascending"`
     *
     * __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
     *
     * __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
     */
    val sort : Option[SortUnion] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[Type] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Double] = None
) derives Encoder.AsObject, Decoder

/**
 * X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified
 * `x2` or `width`.
 *
 * The `value` of this channel can be a number or a string `"width"` for the width of the
 * plot.
 *
 * Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified
 * `y2` or `height`.
 *
 * The `value` of this channel can be a number or a string `"height"` for the height of the
 * plot.
 *
 * Definition object for a constant value (primitive value or gradient definition) of an
 * encoding channel.
 */
case class YClass (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * An object defining properties of axis's gridlines, ticks and labels. If `null`, the axis
     * for the encoding channel will be removed.
     *
     * __Default value:__ If undefined, default [axis
     * properties](https://vega.github.io/vega-lite/docs/axis.html) are applied.
     *
     * __See also:__ [`axis`](https://vega.github.io/vega-lite/docs/axis.html) documentation.
     */
    val axis : Option[Axis] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[DescriptionBin] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * An object defining the properties of the Impute Operation to be applied. The field value
     * of the other positional channel is taken as `key` of the `Impute` Operation. The field of
     * the `color` channel if specified is used as `groupby` of the `Impute` Operation.
     *
     * __See also:__ [`impute`](https://vega.github.io/vega-lite/docs/impute.html) documentation.
     */
    val impute : Option[ImputeParams] = None,

    /**
     * An object defining properties of the channel's scale, which is the function that
     * transforms values in the data domain (numbers, dates, strings, etc) to visual values
     * (pixels, colors, sizes) of the encoding channels.
     *
     * If `null`, the scale will be [disabled and the data value will be directly
     * encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
     *
     * __Default value:__ If undefined, default [scale
     * properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
     *
     * __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
     */
    val scale : Option[Scale] = None,

    /**
     * Sort order for the encoded field.
     *
     * For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
     * `"descending"`.
     *
     * For discrete fields, `sort` can be one of the following:
     * - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
     * JavaScript.
     * - [A string indicating an encoding channel name to sort
     * by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or
     * `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by
     * x-field, descending). This channel string is short-form of [a sort-by-encoding
     * definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For
     * example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order":
     * "descending"}`.
     * - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
     * for sorting by another field.
     * - [An array specifying the field values in preferred
     * order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
     * sort order will obey the values in the array, followed by any unspecified values in their
     * original order. For discrete time field, values in the sort array can be [date-time
     * definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
     * the values can be the month or day names (case insensitive) or their 3-letter initials
     * (e.g., `"Mon"`, `"Tue"`).
     * - `null` indicating no sort.
     *
     * __Default value:__ `"ascending"`
     *
     * __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
     *
     * __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
     */
    val sort : Option[SortUnion] = None,

    /**
     * Type of stacking offset if the field should be stacked. `stack` is only applicable for
     * `x`, `y`, `theta`, and `radius` channels with continuous domains. For example, `stack` of
     * `y` can be used to customize stacking for a vertical bar chart.
     *
     * `stack` can be one of the following values:
     * - `"zero"` or `true`: stacking with baseline offset at zero value of the scale (for
     * creating typical stacked [bar](https://vega.github.io/vega-lite/docs/stack.html#bar) and
     * [area](https://vega.github.io/vega-lite/docs/stack.html#area) chart).
     * - `"normalize"` - stacking with normalized domain (for creating [normalized stacked bar
     * and area charts](https://vega.github.io/vega-lite/docs/stack.html#normalized) and pie
     * charts [with percentage
     * tooltip](https://vega.github.io/vega-lite/docs/arc.html#tooltip)). <br/>
     * -`"center"` - stacking with center baseline (for
     * [streamgraph](https://vega.github.io/vega-lite/docs/stack.html#streamgraph)).
     * - `null` or `false` - No-stacking. This will produce layered
     * [bar](https://vega.github.io/vega-lite/docs/stack.html#layered-bar-chart) and area
     * chart.
     *
     * __Default value:__ `zero` for plots with all of the following conditions are true: (1)
     * the mark is `bar`, `area`, or `arc`; (2) the stacked measure channel (x or y) has a
     * linear scale; (3) At least one of non-position channels mapped to an unaggregated field
     * that is different from x and y. Otherwise, `null` by default.
     *
     * __See also:__ [`stack`](https://vega.github.io/vega-lite/docs/stack.html) documentation.
     */
    val stack : Option[Stack] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[Type] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[X] = None
) derives Encoder.AsObject, Decoder

/**
 * Latitude-2 position for geographically projected ranged `"area"`, `"bar"`, `"rect"`, and
 * `"rule"`.
 *
 * Longitude-2 position for geographically projected ranged `"area"`, `"bar"`, `"rect"`,
 * and  `"rule"`.
 *
 * The inner radius in pixels of arc marks.
 *
 * The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing
 * values proceed clockwise.
 *
 * X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
 *
 * The `value` of this channel can be a number or a string `"width"` for the width of the
 * plot.
 *
 * Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
 *
 * The `value` of this channel can be a number or a string `"height"` for the height of the
 * plot.
 *
 * A field definition of a secondary channel that shares a scale with another primary
 * channel. For example, `x2`, `xError` and `xError2` share the same scale with `x`.
 *
 * Definition object for a constant value (primitive value or gradient definition) of an
 * encoding channel.
 */
case class Y2Class (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[Json] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[Type] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[X] = None
) derives Encoder.AsObject, Decoder

/**
 * Error value of x coordinates for error specified `"errorbar"` and `"errorband"`.
 *
 * Secondary error value of x coordinates for error specified `"errorbar"` and
 * `"errorband"`.
 *
 * Error value of y coordinates for error specified `"errorbar"` and `"errorband"`.
 *
 * Secondary error value of y coordinates for error specified `"errorbar"` and
 * `"errorband"`.
 *
 * A field definition of a secondary channel that shares a scale with another primary
 * channel. For example, `x2`, `xError` and `xError2` share the same scale with `x`.
 *
 * Definition object for a constant value (primitive value or gradient definition) of an
 * encoding channel.
 */
case class YErrorClass (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[Json] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Double] = None
) derives Encoder.AsObject, Decoder

/**
 * Error value of x coordinates for error specified `"errorbar"` and `"errorband"`.
 *
 * Secondary error value of x coordinates for error specified `"errorbar"` and
 * `"errorband"`.
 *
 * Error value of y coordinates for error specified `"errorbar"` and `"errorband"`.
 *
 * Secondary error value of y coordinates for error specified `"errorbar"` and
 * `"errorband"`.
 *
 * A field definition of a secondary channel that shares a scale with another primary
 * channel. For example, `x2`, `xError` and `xError2` share the same scale with `x`.
 *
 * Definition object for a constant value (primitive value or gradient definition) of an
 * encoding channel.
 */
case class YError2Class (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[Json] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Double] = None
) derives Encoder.AsObject, Decoder

/**
 * Offset of x-position of the marks
 *
 * Offset of y-position of the marks
 *
 * Definition object for a constant value (primitive value or gradient definition) of an
 * encoding channel.
 */
case class YOffsetClass (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[AngleBin] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * An object defining properties of the channel's scale, which is the function that
     * transforms values in the data domain (numbers, dates, strings, etc) to visual values
     * (pixels, colors, sizes) of the encoding channels.
     *
     * If `null`, the scale will be [disabled and the data value will be directly
     * encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).
     *
     * __Default value:__ If undefined, default [scale
     * properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.
     *
     * __See also:__ [`scale`](https://vega.github.io/vega-lite/docs/scale.html) documentation.
     */
    val scale : Option[Scale] = None,

    /**
     * Sort order for the encoded field.
     *
     * For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
     * `"descending"`.
     *
     * For discrete fields, `sort` can be one of the following:
     * - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
     * JavaScript.
     * - [A string indicating an encoding channel name to sort
     * by](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding) (e.g., `"x"` or
     * `"y"`) with an optional minus prefix for descending sort (e.g., `"-x"` to sort by
     * x-field, descending). This channel string is short-form of [a sort-by-encoding
     * definition](https://vega.github.io/vega-lite/docs/sort.html#sort-by-encoding). For
     * example, `"sort": "-x"` is equivalent to `"sort": {"encoding": "x", "order":
     * "descending"}`.
     * - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
     * for sorting by another field.
     * - [An array specifying the field values in preferred
     * order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
     * sort order will obey the values in the array, followed by any unspecified values in their
     * original order. For discrete time field, values in the sort array can be [date-time
     * definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
     * the values can be the month or day names (case insensitive) or their 3-letter initials
     * (e.g., `"Mon"`, `"Tue"`).
     * - `null` indicating no sort.
     *
     * __Default value:__ `"ascending"`
     *
     * __Note:__ `null` and sorting by another channel is not supported for `row` and `column`.
     *
     * __See also:__ [`sort`](https://vega.github.io/vega-lite/docs/sort.html) documentation.
     */
    val sort : Option[SortUnion] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[Type] = None,

    /**
     * A constant value in data domain.
     */
    val datum : Option[PrimitiveValue] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Double] = None
) derives Encoder.AsObject, Decoder

/**
 * Definition for how to facet the data. One of: 1) [a field definition for faceting the
 * plot by one field](https://vega.github.io/vega-lite/docs/facet.html#field-def) 2) [An
 * object that maps `row` and `column` channels to their field
 * definitions](https://vega.github.io/vega-lite/docs/facet.html#mapping)
 *
 * A field definition for the horizontal facet of trellis plots.
 *
 * A field definition for the vertical facet of trellis plots.
 */
case class Facet (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[AngleBin] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * An object defining properties of a facet's header.
     */
    val header : Option[Header] = None,

    /**
     * Sort order for the encoded field.
     *
     * For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
     * `"descending"`.
     *
     * For discrete fields, `sort` can be one of the following:
     * - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
     * JavaScript.
     * - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
     * for sorting by another field.
     * - [An array specifying the field values in preferred
     * order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
     * sort order will obey the values in the array, followed by any unspecified values in their
     * original order. For discrete time field, values in the sort array can be [date-time
     * definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
     * the values can be the month or day names (case insensitive) or their 3-letter initials
     * (e.g., `"Mon"`, `"Tue"`).
     * - `null` indicating no sort.
     *
     * __Default value:__ `"ascending"`
     *
     * __Note:__ `null` is not supported for `row` and `column`.
     */
    val sort : Option[SortArray] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[StandardType] = None,

    /**
     * A field definition for the horizontal facet of trellis plots.
     */
    val column : Option[FacetFieldDef] = None,

    /**
     * A field definition for the vertical facet of trellis plots.
     */
    val row : Option[FacetFieldDef] = None
) derives Encoder.AsObject, Decoder

/**
 * A field definition for the horizontal facet of trellis plots.
 *
 * A field definition for the vertical facet of trellis plots.
 */
case class FacetFieldDef (
    /**
     * Aggregation function for the field (e.g., `"mean"`, `"sum"`, `"median"`, `"min"`,
     * `"max"`, `"count"`).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html)
     * documentation.
     */
    val aggregate : Option[Aggregate] = None,

    /**
     * Relative position on a band of a stacked, binned, time unit, or band scale. For example,
     * the marks will be positioned at the beginning of the band if set to `0`, and at the
     * middle of the band if set to `0.5`.
     */
    val bandPosition : Option[Double] = None,

    /**
     * A flag for binning a `quantitative` field, [an object defining binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters), or indicating
     * that the data for `x` or `y` channel are binned before they are imported into Vega-Lite
     * (`"binned"`).
     *
     * - If `true`, default [binning
     * parameters](https://vega.github.io/vega-lite/docs/bin.html#bin-parameters) will be
     * applied.
     *
     * - If `"binned"`, this indicates that the data for the `x` (or `y`) channel are already
     * binned. You can map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or
     * `y2`). The scale and axis will be formatted similar to binning in Vega-Lite.  To adjust
     * the axis ticks based on the bin step, you can also set the axis's
     * [`tickMinStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.
     *
     * __Default value:__ `false`
     *
     * __See also:__ [`bin`](https://vega.github.io/vega-lite/docs/bin.html) documentation.
     */
    val bin : Option[AngleBin] = None,

    /**
     * __Required.__ A string defining the name of the field from which to pull a data value or
     * an object defining iterated values from the
     * [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.
     *
     * __See also:__ [`field`](https://vega.github.io/vega-lite/docs/field.html) documentation.
     *
     * __Notes:__ 1)  Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects
     * (e.g., `"field": "foo.bar"` and `"field": "foo['bar']"`). If field names contain dots or
     * brackets but are not nested, you can use `\\` to escape dots and brackets (e.g.,
     * `"a\\.b"` and `"a\\[0\\]"`). See more details about escaping in the [field
     * documentation](https://vega.github.io/vega-lite/docs/field.html). 2) `field` is not
     * required if `aggregate` is `count`.
     */
    val field : Option[Field] = None,

    /**
     * An object defining properties of a facet's header.
     */
    val header : Option[Header] = None,

    /**
     * Sort order for the encoded field.
     *
     * For continuous fields (quantitative or temporal), `sort` can be either `"ascending"` or
     * `"descending"`.
     *
     * For discrete fields, `sort` can be one of the following:
     * - `"ascending"` or `"descending"` -- for sorting by the values' natural order in
     * JavaScript.
     * - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field)
     * for sorting by another field.
     * - [An array specifying the field values in preferred
     * order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the
     * sort order will obey the values in the array, followed by any unspecified values in their
     * original order. For discrete time field, values in the sort array can be [date-time
     * definition objects](types#datetime). In addition, for time units `"month"` and `"day"`,
     * the values can be the month or day names (case insensitive) or their 3-letter initials
     * (e.g., `"Mon"`, `"Tue"`).
     * - `null` indicating no sort.
     *
     * __Default value:__ `"ascending"`
     *
     * __Note:__ `null` is not supported for `row` and `column`.
     */
    val sort : Option[SortArray] = None,

    /**
     * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field. or [a
     * temporal field that gets casted as
     * ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).
     *
     * __Default value:__ `undefined` (None)
     *
     * __See also:__ [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html)
     * documentation.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    /**
     * The type of measurement (`"quantitative"`, `"temporal"`, `"ordinal"`, or `"nominal"`) for
     * the encoded field or constant value (`datum`). It can also be a `"geojson"` type for
     * encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).
     *
     * Vega-Lite automatically infers data types in many cases as discussed below. However, type
     * is required for a field if: (1) the field is not nominal and the field encoding has no
     * specified `aggregate` (except `argmin` and `argmax`), `bin`, scale type, custom `sort`
     * order, nor `timeUnit` or (2) if you wish to use an ordinal scale for a field with `bin`
     * or `timeUnit`.
     *
     * __Default value:__
     *
     * 1) For a data `field`, `"nominal"` is the default data type unless the field encoding has
     * `aggregate`, `channel`, `bin`, scale type, `sort`, or `timeUnit` that satisfies the
     * following criteria:
     * - `"quantitative"` is the default type if (1) the encoded field contains `bin` or
     * `aggregate` except `"argmin"` and `"argmax"`, (2) the encoding channel is `latitude` or
     * `longitude` channel or (3) if the specified scale type is [a quantitative
     * scale](https://vega.github.io/vega-lite/docs/scale.html#type).
     * - `"temporal"` is the default type if (1) the encoded field contains `timeUnit` or (2)
     * the specified scale type is a time or utc scale
     * - `"ordinal"` is the default type if (1) the encoded field contains a [custom `sort`
     * order](https://vega.github.io/vega-lite/docs/sort.html#specifying-custom-sort-order), (2)
     * the specified scale type is an ordinal/point/band scale, or (3) the encoding channel is
     * `order`.
     *
     * 2) For a constant value in data domain (`datum`):
     * - `"quantitative"` if the datum is a number
     * - `"nominal"` if the datum is a string
     * - `"temporal"` if the datum is [a date time
     * object](https://vega.github.io/vega-lite/docs/datetime.html)
     *
     * __Note:__
     * - Data `type` describes the semantics of the data rather than the primitive data types
     * (number, string, etc.). The same primitive data type can have different types of
     * measurement. For example, numeric data can represent quantitative, ordinal, or nominal
     * data.
     * - Data values for a temporal field can be either a date-time string (e.g., `"2015-03-07
     * 12:32:17"`, `"17:01"`, `"2015-03-16"`. `"2015"`) or a timestamp number (e.g.,
     * `1552199579097`).
     * - When using with [`bin`](https://vega.github.io/vega-lite/docs/bin.html), the `type`
     * property can be either `"quantitative"` (for using a linear bin scale) or [`"ordinal"`
     * (for using an ordinal bin
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`timeUnit`](https://vega.github.io/vega-lite/docs/timeunit.html), the
     * `type` property can be either `"temporal"` (default, for using a temporal scale) or
     * [`"ordinal"` (for using an ordinal
     * scale)](https://vega.github.io/vega-lite/docs/type.html#cast-bin).
     * - When using with [`aggregate`](https://vega.github.io/vega-lite/docs/aggregate.html),
     * the `type` property refers to the post-aggregation data type. For example, we can
     * calculate count `distinct` of a categorical field `"cat"` using `{"aggregate":
     * "distinct", "field": "cat"}`. The `"type"` of the aggregate output is `"quantitative"`.
     * - Secondary channels (e.g., `x2`, `y2`, `xError`, `yError`) do not have `type` as they
     * must have exactly the same type as their primary channels (e.g., `x`, `y`).
     *
     * __See also:__ [`type`](https://vega.github.io/vega-lite/docs/type.html) documentation.
     */
    val `type` : Option[StandardType] = None
) derives Encoder.AsObject, Decoder

type SpecHeight = Double | Step | String
given Decoder[SpecHeight] = {
    List[Decoder[SpecHeight]](
        Decoder[Double].widen,
        Decoder[Step].widen,
        Decoder[String].widen,
    ).reduceLeft(_ or _)
}

given Encoder[SpecHeight] = Encoder.instance {
    case enc0 : Double => Encoder.encodeDouble(enc0)
    case enc1 : Step => Encoder.AsObject[Step].apply(enc1)
    case enc2 : String => Encoder.encodeString(enc2)
}

case class Step (
    /**
     * Whether to apply the step to position scale or offset scale when there are both `x` and
     * `xOffset` or both `y` and `yOffset` encodings.
     */
    val `for` : Option[StepFor] = None,

    /**
     * The size (width/height) per discrete step.
     */
    val step : Double
) derives Encoder.AsObject, Decoder

/**
 * Whether to apply the step to position scale or offset scale when there are both `x` and
 * `xOffset` or both `y` and `yOffset` encodings.
 */

enum StepFor : 
    case offset
    case position
given Decoder[StepFor] = Decoder.decodeString.emapTry(x => Try(StepFor.valueOf(x) )) 
given Encoder[StepFor] = Encoder.encodeString.contramap(_.toString())

/**
 * A full layered plot specification, which may contains `encoding` and `projection`
 * properties that will be applied to underlying unit (single-view) specifications.
 *
 * A unit specification, which can contain either [primitive marks or composite
 * marks](https://vega.github.io/vega-lite/docs/mark.html#types).
 *
 * Base interface for a unit (single-view) specification.
 */
case class LayerSpec (
    /**
     * An object describing the data source. Set to `null` to ignore the parent's data source.
     * If no data is set, it is derived from the parent.
     */
    val data : Option[URLData] = None,

    /**
     * Description of this mark for commenting purpose.
     */
    val description : Option[String] = None,

    /**
     * A shared key-value mapping between encoding channels and definition of fields in the
     * underlying layers.
     *
     * A key-value mapping between encoding channels and definition of fields.
     */
    val encoding : Option[LayerEncoding] = None,

    /**
     * The height of a visualization.
     *
     * - For a plot with a continuous y-field, height should be a number.
     * - For a plot with either a discrete y-field or no y-field, height can be either a number
     * indicating a fixed height or an object in the form of `{step: number}` defining the
     * height per discrete step. (No y-field is equivalent to having one discrete step.)
     * - To enable responsive sizing on height, it should be set to `"container"`.
     *
     * __Default value:__ Based on `config.view.continuousHeight` for a plot with a continuous
     * y-field and `config.view.discreteHeight` otherwise.
     *
     * __Note:__ For plots with [`row` and `column`
     * channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the
     * height of a single view and the `"container"` option cannot be used.
     *
     * __See also:__ [`height`](https://vega.github.io/vega-lite/docs/size.html) documentation.
     */
    val height : Option[SpecHeight] = None,

    /**
     * Layer or single view specifications to be layered.
     *
     * __Note__: Specifications inside `layer` cannot use `row` and `column` channels as
     * layering facet specifications is not allowed. Instead, use the [facet
     * operator](https://vega.github.io/vega-lite/docs/facet.html) and place a layer inside a
     * facet.
     */
    val layer : Option[Seq[LayerSpec]] = None,

    /**
     * Name of the visualization for later reference.
     */
    val name : Option[String] = None,

    /**
     * An object defining properties of the geographic projection shared by underlying layers.
     *
     * An object defining properties of geographic projection, which will be applied to `shape`
     * path for `"geoshape"` marks and to `latitude` and `"longitude"` channels for other marks.
     */
    val projection : Option[Projection] = None,

    /**
     * Scale, axis, and legend resolutions for view composition specifications.
     */
    val resolve : Option[Resolve] = None,

    /**
     * Title for the plot.
     */
    val title : Option[LayerTitle] = None,

    /**
     * An array of data transformations such as filter and new field calculation.
     */
    val transform : Option[Seq[Transform]] = None,

    /**
     * An object defining the view background's fill and stroke.
     *
     * __Default value:__ none (transparent)
     */
    val view : Option[ViewBackground] = None,

    /**
     * The width of a visualization.
     *
     * - For a plot with a continuous x-field, width should be a number.
     * - For a plot with either a discrete x-field or no x-field, width can be either a number
     * indicating a fixed width or an object in the form of `{step: number}` defining the width
     * per discrete step. (No x-field is equivalent to having one discrete step.)
     * - To enable responsive sizing on width, it should be set to `"container"`.
     *
     * __Default value:__ Based on `config.view.continuousWidth` for a plot with a continuous
     * x-field and `config.view.discreteWidth` otherwise.
     *
     * __Note:__ For plots with [`row` and `column`
     * channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the
     * width of a single view and the `"container"` option cannot be used.
     *
     * __See also:__ [`width`](https://vega.github.io/vega-lite/docs/size.html) documentation.
     */
    val width : Option[SpecHeight] = None,

    /**
     * A string describing the mark type (one of `"bar"`, `"circle"`, `"square"`, `"tick"`,
     * `"line"`, `"area"`, `"point"`, `"rule"`, `"geoshape"`, and `"text"`) or a [mark
     * definition object](https://vega.github.io/vega-lite/docs/mark.html#mark-def).
     */
    val mark : Option[AnyMark] = None,

    /**
     * An array of parameters that may either be simple variables, or more complex selections
     * that map user input to data queries.
     */
    val params : Option[Seq[SelectionParameter]] = None
) derives Encoder.AsObject, Decoder

/**
 * A shared key-value mapping between encoding channels and definition of fields in the
 * underlying layers.
 *
 * A key-value mapping between encoding channels and definition of fields.
 */
case class LayerEncoding (
    /**
     * Rotation angle of point and text marks.
     */
    val angle : Option[AngleClass] = None,

    /**
     * Color of the marks – either fill or stroke color based on  the `filled` property of mark
     * definition. By default, `color` represents fill color for `"area"`, `"bar"`, `"tick"`,
     * `"text"`, `"trail"`, `"circle"`, and `"square"` / stroke color for `"line"` and
     * `"point"`.
     *
     * __Default value:__ If undefined, the default color depends on [mark
     * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color`
     * property.
     *
     * _Note:_ 1) For fine-grained control over both fill and stroke colors of the marks, please
     * use the `fill` and `stroke` channels. The `fill` or `stroke` encodings have higher
     * precedence than `color`, thus may override the `color` encoding if conflicting encodings
     * are specified. 2) See the scale documentation for more information about customizing
     * [color scheme](https://vega.github.io/vega-lite/docs/scale.html#scheme).
     */
    val color : Option[ColorClass] = None,

    /**
     * A text description of this mark for ARIA accessibility (SVG output only). For SVG output
     * the `"aria-label"` attribute will be set to this description.
     */
    val description : Option[DescriptionClass] = None,

    /**
     * Additional levels of detail for grouping data in aggregate views and in line, trail, and
     * area marks without mapping data to a specific visual channel.
     */
    val detail : Option[Detail] = None,

    /**
     * Fill color of the marks. __Default value:__ If undefined, the default color depends on
     * [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color`
     * property.
     *
     * _Note:_ The `fill` encoding has higher precedence than `color`, thus may override the
     * `color` encoding if conflicting encodings are specified.
     */
    val fill : Option[FillClass] = None,

    /**
     * Fill opacity of the marks.
     *
     * __Default value:__ If undefined, the default opacity depends on [mark
     * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `fillOpacity`
     * property.
     */
    val fillOpacity : Option[FillOpacityClass] = None,

    /**
     * A URL to load upon mouse click.
     */
    val href : Option[HrefClass] = None,

    /**
     * A data field to use as a unique key for data binding. When a visualization’s data is
     * updated, the key value will be used to match data elements to existing mark instances.
     * Use a key channel to enable object constancy for transitions over dynamic data.
     */
    val key : Option[KeyClass] = None,

    /**
     * Latitude position of geographically projected marks.
     */
    val latitude : Option[LatitudeClass] = None,

    /**
     * Latitude-2 position for geographically projected ranged `"area"`, `"bar"`, `"rect"`, and
     * `"rule"`.
     */
    val latitude2 : Option[Latitude2Class] = None,

    /**
     * Longitude position of geographically projected marks.
     */
    val longitude : Option[LongitudeClass] = None,

    /**
     * Longitude-2 position for geographically projected ranged `"area"`, `"bar"`, `"rect"`,
     * and  `"rule"`.
     */
    val longitude2 : Option[Longitude2Class] = None,

    /**
     * Opacity of the marks.
     *
     * __Default value:__ If undefined, the default opacity depends on [mark
     * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `opacity`
     * property.
     */
    val opacity : Option[OpacityClass] = None,

    /**
     * Order of the marks.
     * - For stacked marks, this `order` channel encodes [stack
     * order](https://vega.github.io/vega-lite/docs/stack.html#order).
     * - For line and trail marks, this `order` channel encodes order of data points in the
     * lines. This can be useful for creating [a connected
     * scatterplot](https://vega.github.io/vega-lite/examples/connected_scatterplot.html).
     * Setting `order` to `{"value": null}` makes the line marks use the original order in the
     * data sources.
     * - Otherwise, this `order` channel encodes layer order of the marks.
     *
     * __Note__: In aggregate plots, `order` field should be `aggregate`d to avoid creating
     * additional aggregation grouping.
     */
    val order : Option[Order] = None,

    /**
     * The outer radius in pixels of arc marks.
     */
    val radius : Option[RadiusClass] = None,

    /**
     * The inner radius in pixels of arc marks.
     */
    val radius2 : Option[Radius2Class] = None,

    /**
     * Shape of the mark.
     *
     * 1. For `point` marks the supported values include:   - plotting shapes: `"circle"`,
     * `"square"`, `"cross"`, `"diamond"`, `"triangle-up"`, `"triangle-down"`,
     * `"triangle-right"`, or `"triangle-left"`.   - the line symbol `"stroke"`   - centered
     * directional shapes `"arrow"`, `"wedge"`, or `"triangle"`   - a custom [SVG path
     * string](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths) (For correct
     * sizing, custom shape paths should be defined within a square bounding box with
     * coordinates ranging from -1 to 1 along both the x and y dimensions.)
     *
     * 2. For `geoshape` marks it should be a field definition of the geojson data
     *
     * __Default value:__ If undefined, the default shape depends on [mark
     * config](https://vega.github.io/vega-lite/docs/config.html#point-config)'s `shape`
     * property. (`"circle"` if unset.)
     */
    val shape : Option[MarkPropDefStringNullTypeForShape] = None,

    /**
     * Size of the mark.
     * - For `"point"`, `"square"` and `"circle"`, – the symbol size, or pixel area of the mark.
     * - For `"bar"` and `"tick"` – the bar and tick's size.
     * - For `"text"` – the text's font size.
     * - Size is unsupported for `"line"`, `"area"`, and `"rect"`. (Use `"trail"` instead of
     * line with varying size)
     */
    val size : Option[SizeClass] = None,

    /**
     * Stroke color of the marks. __Default value:__ If undefined, the default color depends on
     * [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color`
     * property.
     *
     * _Note:_ The `stroke` encoding has higher precedence than `color`, thus may override the
     * `color` encoding if conflicting encodings are specified.
     */
    val stroke : Option[StrokeClass] = None,

    /**
     * Stroke dash of the marks.
     *
     * __Default value:__ `[1,0]` (No dash).
     */
    val strokeDash : Option[MarkPropDefNumber] = None,

    /**
     * Stroke opacity of the marks.
     *
     * __Default value:__ If undefined, the default opacity depends on [mark
     * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `strokeOpacity`
     * property.
     */
    val strokeOpacity : Option[StrokeOpacityClass] = None,

    /**
     * Stroke width of the marks.
     *
     * __Default value:__ If undefined, the default stroke width depends on [mark
     * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `strokeWidth`
     * property.
     */
    val strokeWidth : Option[StrokeWidthClass] = None,

    /**
     * Text of the `text` mark.
     */
    val text : Option[TextDef] = None,

    /**
     * - For arc marks, the arc length in radians if theta2 is not specified, otherwise the
     * start arc angle. (A value of 0 indicates up or “north”, increasing values proceed
     * clockwise.)
     *
     * - For text marks, polar coordinate angle in radians.
     */
    val theta : Option[ThetaClass] = None,

    /**
     * The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing
     * values proceed clockwise.
     */
    val theta2 : Option[Theta2Class] = None,

    /**
     * The tooltip text to show upon mouse hover. Specifying `tooltip` encoding overrides [the
     * `tooltip` property in the mark
     * definition](https://vega.github.io/vega-lite/docs/mark.html#mark-def).
     *
     * See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for
     * a detailed discussion about tooltip in Vega-Lite.
     */
    val tooltip : Option[EncodingTooltip] = None,

    /**
     * The URL of an image mark.
     */
    val url : Option[URLClass] = None,

    /**
     * X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified
     * `x2` or `width`.
     *
     * The `value` of this channel can be a number or a string `"width"` for the width of the
     * plot.
     */
    val x : Option[XClass] = None,

    /**
     * X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
     *
     * The `value` of this channel can be a number or a string `"width"` for the width of the
     * plot.
     */
    val x2 : Option[X2Class] = None,

    /**
     * Error value of x coordinates for error specified `"errorbar"` and `"errorband"`.
     */
    val xError : Option[XErrorClass] = None,

    /**
     * Secondary error value of x coordinates for error specified `"errorbar"` and `"errorband"`.
     */
    val xError2 : Option[XError2Class] = None,

    /**
     * Offset of x-position of the marks
     */
    val xOffset : Option[XOffsetClass] = None,

    /**
     * Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified
     * `y2` or `height`.
     *
     * The `value` of this channel can be a number or a string `"height"` for the height of the
     * plot.
     */
    val y : Option[YClass] = None,

    /**
     * Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
     *
     * The `value` of this channel can be a number or a string `"height"` for the height of the
     * plot.
     */
    val y2 : Option[Y2Class] = None,

    /**
     * Error value of y coordinates for error specified `"errorbar"` and `"errorband"`.
     */
    val yError : Option[YErrorClass] = None,

    /**
     * Secondary error value of y coordinates for error specified `"errorbar"` and `"errorband"`.
     */
    val yError2 : Option[YError2Class] = None,

    /**
     * Offset of y-position of the marks
     */
    val yOffset : Option[YOffsetClass] = None
) derives Encoder.AsObject, Decoder

/**
 * A string describing the mark type (one of `"bar"`, `"circle"`, `"square"`, `"tick"`,
 * `"line"`, `"area"`, `"point"`, `"rule"`, `"geoshape"`, and `"text"`) or a [mark
 * definition object](https://vega.github.io/vega-lite/docs/mark.html#mark-def).
 */
type AnyMark = Def | String
given Decoder[AnyMark] = {
    List[Decoder[AnyMark]](
        Decoder[Def].widen,
        Decoder[String].widen,
    ).reduceLeft(_ or _)
}

given Encoder[AnyMark] = Encoder.instance {
    case enc0 : Def => Encoder.AsObject[Def].apply(enc0)
    case enc1 : String => Encoder.encodeString(enc1)
}

case class Def (
    val box : Option[AnyMarkConfig] = None,

    /**
     * Whether a composite mark be clipped to the enclosing group’s width and height.
     *
     * Whether a mark be clipped to the enclosing group’s width and height.
     */
    val clip : Option[Boolean] = None,

    /**
     * Default color.
     *
     * __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
     *
     * __Note:__
     * - This property cannot be used in a [style
     * config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
     * - The `fill` and `stroke` properties have higher precedence than `color` and will
     * override `color`.
     */
    val color : Option[MarkConfigColor] = None,

    /**
     * The extent of the whiskers. Available options include:
     * - `"min-max"`: min and max are the lower and upper whiskers respectively.
     * - A number representing multiple of the interquartile range. This number will be
     * multiplied by the IQR to determine whisker boundary, which spans from the smallest data
     * to the largest data within the range _[Q1 - k * IQR, Q3 + k * IQR]_ where _Q1_ and _Q3_
     * are the first and third quartiles while _IQR_ is the interquartile range (_Q3-Q1_).
     *
     * __Default value:__ `1.5`.
     *
     * The extent of the rule. Available options include:
     * - `"ci"`: Extend the rule to the confidence interval of the mean.
     * - `"stderr"`: The size of rule are set to the value of standard error, extending from the
     * mean.
     * - `"stdev"`: The size of rule are set to the value of standard deviation, extending from
     * the mean.
     * - `"iqr"`: Extend the rule to the q1 and q3.
     *
     * __Default value:__ `"stderr"`.
     *
     * The extent of the band. Available options include:
     * - `"ci"`: Extend the band to the confidence interval of the mean.
     * - `"stderr"`: The size of band are set to the value of standard error, extending from the
     * mean.
     * - `"stdev"`: The size of band are set to the value of standard deviation, extending from
     * the mean.
     * - `"iqr"`: Extend the band to the q1 and q3.
     *
     * __Default value:__ `"stderr"`.
     */
    val extent : Option[BoxPlotDefExtent] = None,

    /**
     * Defines how Vega-Lite should handle marks for invalid values (`null` and `NaN`).
     * - If set to `"filter"` (default), all data items with null values will be skipped (for
     * line, trail, and area marks) or filtered (for other marks).
     * - If `null`, all data items are included. In this case, invalid values will be
     * interpreted as zeroes.
     */
    val invalid : Option[Invalid] = None,

    val median : Option[AnyMarkConfig] = None,

    /**
     * The opacity (value between [0,1]) of the mark.
     *
     * The overall opacity (value between [0,1]).
     *
     * __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or
     * `square` marks or layered `bar` charts and `1` otherwise.
     */
    val opacity : Option[Opacity] = None,

    /**
     * Orientation of the box plot. This is normally automatically determined based on types of
     * fields on x and y channels. However, an explicit `orient` be specified when the
     * orientation is ambiguous.
     *
     * __Default value:__ `"vertical"`.
     *
     * Orientation of the error bar. This is normally automatically determined, but can be
     * specified when the orientation is ambiguous and cannot be automatically determined.
     *
     * Orientation of the error band. This is normally automatically determined, but can be
     * specified when the orientation is ambiguous and cannot be automatically determined.
     *
     * The orientation of a non-stacked bar, tick, area, and line charts. The value is either
     * horizontal (default) or vertical.
     * - For bar, rule and tick, this determines whether the size of the bar and tick should be
     * applied to x or y dimension.
     * - For area, this property determines the orient property of the Vega output.
     * - For line and trail marks, this property determines the sort order of the points in the
     * line if `config.sortLineBy` is not specified. For stacked charts, this is always
     * determined by the orientation of the stack; therefore explicitly specified value will be
     * ignored.
     */
    val orient : Option[Orientation] = None,

    val outliers : Option[AnyMarkConfig] = None,
    val rule : Option[AnyMarkConfig] = None,

    /**
     * Size of the box and median tick of a box plot
     *
     * Size of the ticks of an error bar
     *
     * Default size for marks.
     * - For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that
     * this value sets the area of the symbol; the side lengths will increase with the square
     * root of this value.
     * - For `bar`, this represents the band size of the bar, in pixels.
     * - For `text`, this represents the font size, in pixels.
     *
     * __Default value:__
     * - `30` for point, circle, square marks; width/height's `step`
     * - `2` for bar marks with discrete dimensions;
     * - `5` for bar marks with continuous dimensions;
     * - `11` for text marks.
     */
    val size : Option[CornerRadius] = None,

    val ticks : Option[AnyMarkConfig] = None,

    /**
     * The mark type. This could a primitive mark type (one of `"bar"`, `"circle"`, `"square"`,
     * `"tick"`, `"line"`, `"area"`, `"point"`, `"geoshape"`, `"rule"`, and `"text"`) or a
     * composite mark type (`"boxplot"`, `"errorband"`, `"errorbar"`).
     */
    val `type` : String,

    /**
     * Thickness of the ticks and the bar of an error bar
     *
     * Thickness of the tick mark.
     *
     * __Default value:__  `1`
     */
    val thickness : Option[Double] = None,

    val band : Option[AnyMarkConfig] = None,
    val borders : Option[AnyMarkConfig] = None,

    /**
     * The line interpolation method for the error band. One of the following:
     * - `"linear"`: piecewise linear segments, as in a polyline.
     * - `"linear-closed"`: close the linear segments to form a polygon.
     * - `"step"`: a piecewise constant function (a step function) consisting of alternating
     * horizontal and vertical lines. The y-value changes at the midpoint of each pair of
     * adjacent x-values.
     * - `"step-before"`: a piecewise constant function (a step function) consisting of
     * alternating horizontal and vertical lines. The y-value changes before the x-value.
     * - `"step-after"`: a piecewise constant function (a step function) consisting of
     * alternating horizontal and vertical lines. The y-value changes after the x-value.
     * - `"basis"`: a B-spline, with control point duplication on the ends.
     * - `"basis-open"`: an open B-spline; may not intersect the start or end.
     * - `"basis-closed"`: a closed B-spline, as in a loop.
     * - `"cardinal"`: a Cardinal spline, with control point duplication on the ends.
     * - `"cardinal-open"`: an open Cardinal spline; may not intersect the start or end, but
     * will intersect other control points.
     * - `"cardinal-closed"`: a closed Cardinal spline, as in a loop.
     * - `"bundle"`: equivalent to basis, except the tension parameter is used to straighten the
     * spline.
     * - `"monotone"`: cubic interpolation that preserves monotonicity in y.
     */
    val interpolate : Option[MarkConfigInterpolate] = None,

    /**
     * The tension parameter for the interpolation type of the error band.
     */
    val tension : Option[Opacity] = None,

    /**
     * The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One
     * of `"left"`, `"right"`, `"center"`.
     *
     * __Note:__ Expression reference is *not* supported for range marks.
     */
    val align : Option[TitleAlignUnion] = None,

    val angle : Option[Angle] = None,
    val aria : Option[Aria] = None,
    val ariaRole : Option[BackgroundUnion] = None,
    val ariaRoleDescription : Option[BackgroundUnion] = None,
    val aspect : Option[Aria] = None,

    /**
     * The width of the ticks.
     *
     * __Default value:__  3/4 of step (width step for horizontal ticks and height step for
     * vertical ticks).
     */
    val bandSize : Option[Double] = None,

    /**
     * For text marks, the vertical text baseline. One of `"alphabetic"` (default), `"top"`,
     * `"middle"`, `"bottom"`, `"line-top"`, `"line-bottom"`, or an expression reference that
     * provides one of the valid values. The `"line-top"` and `"line-bottom"` values operate
     * similarly to `"top"` and `"bottom"`, but are calculated relative to the `lineHeight`
     * rather than `fontSize` alone.
     *
     * For range marks, the vertical alignment of the marks. One of `"top"`, `"middle"`,
     * `"bottom"`.
     *
     * __Note:__ Expression reference is *not* supported for range marks.
     */
    val baseline : Option[BackgroundUnion] = None,

    /**
     * Offset between bars for binned field. The ideal value for this is either 0 (preferred by
     * statisticians) or 1 (Vega-Lite default, D3 example style).
     *
     * __Default value:__ `1`
     */
    val binSpacing : Option[Double] = None,

    val blend : Option[BlendUnion] = None,

    /**
     * The default size of the bars on continuous scales.
     *
     * __Default value:__ `5`
     */
    val continuousBandSize : Option[Double] = None,

    val cornerRadius : Option[CornerRadius] = None,
    val cornerRadiusBottomLeft : Option[CornerRadius] = None,
    val cornerRadiusBottomRight : Option[CornerRadius] = None,

    /**
     * - For vertical bars, top-left and top-right corner radius.
     *
     * - For horizontal bars, top-right and bottom-right corner radius.
     */
    val cornerRadiusEnd : Option[CornerRadius] = None,

    val cornerRadiusTopLeft : Option[CornerRadius] = None,
    val cornerRadiusTopRight : Option[CornerRadius] = None,
    val cursor : Option[CursorUnion] = None,
    val description : Option[BackgroundUnion] = None,
    val dir : Option[Dir] = None,

    /**
     * The default size of the bars with discrete dimensions. If unspecified, the default size
     * is  `step-2`, which provides 2 pixel offset between bars.
     */
    val discreteBandSize : Option[DiscreteBandSize] = None,

    val dx : Option[CornerRadius] = None,
    val dy : Option[CornerRadius] = None,
    val ellipsis : Option[BackgroundUnion] = None,

    /**
     * Default fill color. This property has higher precedence than `config.color`. Set to
     * `null` to remove fill.
     *
     * __Default value:__ (None)
     */
    val fill : Option[MarkConfigFill] = None,

    /**
     * Whether the mark's color should be used as fill color instead of stroke color.
     *
     * __Default value:__ `false` for all `point`, `line`, and `rule` marks as well as
     * `geoshape` marks for
     * [`graticule`](https://vega.github.io/vega-lite/docs/data.html#graticule) data sources;
     * otherwise, `true`.
     *
     * __Note:__ This property cannot be used in a [style
     * config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
     */
    val filled : Option[Boolean] = None,

    val fillOpacity : Option[Opacity] = None,
    val font : Option[BackgroundUnion] = None,
    val fontSize : Option[FontSize] = None,
    val fontStyle : Option[BackgroundUnion] = None,
    val fontWeight : Option[FontWeightUnion] = None,

    /**
     * Height of the marks.  One of:
     *
     * - A number representing a fixed pixel height.
     *
     * - A relative band size definition.  For example, `{band: 0.5}` represents half of the band
     */
    val height : Option[BoxPlotDefHeight] = None,

    val href : Option[BackgroundUnion] = None,

    /**
     * The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`.
     *
     * __Default value:__ `0`
     */
    val innerRadius : Option[CornerRadius] = None,

    val limit : Option[CornerRadius] = None,

    /**
     * A flag for overlaying line on top of area marks, or an object defining the properties of
     * the overlayed lines.
     *
     * - If this value is an empty object (`{}`) or `true`, lines with default properties will
     * be used.
     *
     * - If this value is `false`, no lines would be automatically added to area marks.
     *
     * __Default value:__ `false`.
     */
    val line : Option[Line] = None,

    val lineBreak : Option[BackgroundUnion] = None,
    val lineHeight : Option[CornerRadius] = None,

    /**
     * For line and trail marks, this `order` property can be set to `null` or `false` to make
     * the lines use the original order in the data sources.
     */
    val order : Option[Boolean] = None,

    /**
     * The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`.
     *
     * __Default value:__ `0`
     */
    val outerRadius : Option[CornerRadius] = None,

    val padAngle : Option[CornerRadius] = None,

    /**
     * A flag for overlaying points on top of line or area marks, or an object defining the
     * properties of the overlayed points.
     *
     * - If this property is `"transparent"`, transparent points will be used (for enhancing
     * tooltips and selections).
     *
     * - If this property is an empty object (`{}`) or `true`, filled points with default
     * properties will be used.
     *
     * - If this property is `false`, no points would be automatically added to line or area
     * marks.
     *
     * __Default value:__ `false`.
     */
    val point : Option[Point] = None,

    /**
     * For arc mark, the primary (outer) radius in pixels.
     *
     * For text marks, polar coordinate radial offset, in pixels, of the text from the origin
     * determined by the `x` and `y` properties.
     *
     * __Default value:__ `min(plot_width, plot_height)/2`
     */
    val radius : Option[CornerRadius] = None,

    /**
     * The secondary (inner) radius in pixels of arc marks.
     *
     * __Default value:__ `0`
     */
    val radius2 : Option[CornerRadius] = None,

    /**
     * Offset for radius2.
     */
    val radius2Offset : Option[CornerRadius] = None,

    /**
     * Offset for radius.
     */
    val radiusOffset : Option[CornerRadius] = None,

    val shape : Option[BackgroundUnion] = None,
    val smooth : Option[Aria] = None,

    /**
     * Default stroke color. This property has higher precedence than `config.color`. Set to
     * `null` to remove stroke.
     *
     * __Default value:__ (None)
     */
    val stroke : Option[MarkConfigFill] = None,

    val strokeCap : Option[Cap] = None,
    val strokeDash : Option[StrokeDash] = None,
    val strokeDashOffset : Option[CornerRadius] = None,
    val strokeJoin : Option[StrokeJoinUnion] = None,
    val strokeMiterLimit : Option[CornerRadius] = None,
    val strokeOffset : Option[CornerRadius] = None,
    val strokeOpacity : Option[Opacity] = None,
    val strokeWidth : Option[FontSize] = None,

    /**
     * A string or array of strings indicating the name of custom styles to apply to the mark. A
     * style is a named collection of mark property defaults defined within the [style
     * configuration](https://vega.github.io/vega-lite/docs/mark.html#style-config). If style is
     * an array, later styles will override earlier styles. Any [mark
     * properties](https://vega.github.io/vega-lite/docs/encoding.html#mark-prop) explicitly
     * defined within the `encoding` will override a style default.
     *
     * __Default value:__ The mark's name. For example, a bar mark will have style `"bar"` by
     * default. __Note:__ Any specified style will augment the default style. For example, a bar
     * mark with `"style": "foo"` will receive from `config.style.bar` and `config.style.foo`
     * (the specified style `"foo"` has higher precedence).
     */
    val style : Option[Text] = None,

    val text : Option[TextUnion] = None,

    /**
     * - For arc marks, the arc length in radians if theta2 is not specified, otherwise the
     * start arc angle. (A value of 0 indicates up or “north”, increasing values proceed
     * clockwise.)
     *
     * - For text marks, polar coordinate angle in radians.
     */
    val theta : Option[CornerRadius] = None,

    /**
     * The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing
     * values proceed clockwise.
     */
    val theta2 : Option[CornerRadius] = None,

    /**
     * Offset for theta2.
     */
    val theta2Offset : Option[CornerRadius] = None,

    /**
     * Offset for theta.
     */
    val thetaOffset : Option[CornerRadius] = None,

    /**
     * Default relative band position for a time unit. If set to `0`, the marks will be
     * positioned at the beginning of the time unit band step. If set to `0.5`, the marks will
     * be positioned in the middle of the time unit band step.
     */
    val timeUnitBandPosition : Option[Double] = None,

    /**
     * Default relative band size for a time unit. If set to `1`, the bandwidth of the marks
     * will be equal to the time unit band step. If set to `0.5`, bandwidth of the marks will be
     * half of the time unit band step.
     */
    val timeUnitBandSize : Option[Double] = None,

    /**
     * The tooltip text string to show upon mouse hover or an object defining which fields
     * should the tooltip be derived from.
     *
     * - If `tooltip` is `true` or `{"content": "encoding"}`, then all fields from `encoding`
     * will be used.
     * - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted
     * data point will be used.
     * - If set to `null` or `false`, then no tooltip will be used.
     *
     * See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for
     * a detailed discussion about tooltip  in Vega-Lite.
     *
     * __Default value:__ `null`
     */
    val tooltip : Option[OverlayMarkDefTooltip] = None,

    val url : Option[BackgroundUnion] = None,

    /**
     * Width of the marks.  One of:
     *
     * - A number representing a fixed pixel width.
     *
     * - A relative band size definition.  For example, `{band: 0.5}` represents half of the
     * band.
     */
    val width : Option[BoxPlotDefHeight] = None,

    /**
     * X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified
     * `x2` or `width`.
     *
     * The `value` of this channel can be a number or a string `"width"` for the width of the
     * plot.
     */
    val x : Option[X] = None,

    /**
     * X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
     *
     * The `value` of this channel can be a number or a string `"width"` for the width of the
     * plot.
     */
    val x2 : Option[X] = None,

    /**
     * Offset for x2-position.
     */
    val x2Offset : Option[CornerRadius] = None,

    /**
     * Offset for x-position.
     */
    val xOffset : Option[CornerRadius] = None,

    /**
     * Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified
     * `y2` or `height`.
     *
     * The `value` of this channel can be a number or a string `"height"` for the height of the
     * plot.
     */
    val y : Option[X] = None,

    /**
     * Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
     *
     * The `value` of this channel can be a number or a string `"height"` for the height of the
     * plot.
     */
    val y2 : Option[X] = None,

    /**
     * Offset for y2-position.
     */
    val y2Offset : Option[CornerRadius] = None,

    /**
     * Offset for y-position.
     */
    val yOffset : Option[CornerRadius] = None
) derives Encoder.AsObject, Decoder

type Angle = BackgroundExprRef | Double
type AnyMarkConfig = Boolean | Config
given Decoder[AnyMarkConfig] = {
    List[Decoder[AnyMarkConfig]](
        Decoder[Boolean].widen,
        Decoder[Config].widen,
    ).reduceLeft(_ or _)
}

given Encoder[AnyMarkConfig] = Encoder.instance {
    case enc0 : Boolean => Encoder.encodeBoolean(enc0)
    case enc1 : Config => Encoder.AsObject[Config].apply(enc1)
}

/**
 * Circle-Specific Config
 *
 * Geoshape-Specific Config
 *
 * Mark Config
 *
 * Point-Specific Config
 *
 * Rule-Specific Config
 *
 * Square-Specific Config
 *
 * Default style for chart subtitles
 *
 * Default style for chart titles
 *
 * Default style for axis, legend, and header labels.
 *
 * Default style for axis, legend, and header titles.
 *
 * Text-Specific Config
 *
 * Area-Specific Config
 *
 * Bar-Specific Config
 *
 * Arc-specific Config
 *
 * Image-specific Config
 *
 * Rect-Specific Config
 *
 * Line-Specific Config
 *
 * Trail-Specific Config
 *
 * Tick-Specific Config
 */
case class Config (
    /**
     * The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One
     * of `"left"`, `"right"`, `"center"`.
     *
     * __Note:__ Expression reference is *not* supported for range marks.
     */
    val align : Option[TitleAlignUnion] = None,

    val angle : Option[Angle] = None,
    val aria : Option[Aria] = None,
    val ariaRole : Option[BackgroundUnion] = None,
    val ariaRoleDescription : Option[BackgroundUnion] = None,
    val aspect : Option[Aria] = None,

    /**
     * For text marks, the vertical text baseline. One of `"alphabetic"` (default), `"top"`,
     * `"middle"`, `"bottom"`, `"line-top"`, `"line-bottom"`, or an expression reference that
     * provides one of the valid values. The `"line-top"` and `"line-bottom"` values operate
     * similarly to `"top"` and `"bottom"`, but are calculated relative to the `lineHeight`
     * rather than `fontSize` alone.
     *
     * For range marks, the vertical alignment of the marks. One of `"top"`, `"middle"`,
     * `"bottom"`.
     *
     * __Note:__ Expression reference is *not* supported for range marks.
     */
    val baseline : Option[BackgroundUnion] = None,

    val blend : Option[BlendUnion] = None,

    /**
     * Default color.
     *
     * __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
     *
     * __Note:__
     * - This property cannot be used in a [style
     * config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
     * - The `fill` and `stroke` properties have higher precedence than `color` and will
     * override `color`.
     */
    val color : Option[MarkConfigColor] = None,

    val cornerRadius : Option[CornerRadius] = None,
    val cornerRadiusBottomLeft : Option[CornerRadius] = None,
    val cornerRadiusBottomRight : Option[CornerRadius] = None,
    val cornerRadiusTopLeft : Option[CornerRadius] = None,
    val cornerRadiusTopRight : Option[CornerRadius] = None,
    val cursor : Option[CursorUnion] = None,
    val description : Option[BackgroundUnion] = None,
    val dir : Option[Dir] = None,
    val dx : Option[CornerRadius] = None,
    val dy : Option[CornerRadius] = None,
    val ellipsis : Option[BackgroundUnion] = None,
    val endAngle : Option[CornerRadius] = None,

    /**
     * Default fill color. This property has higher precedence than `config.color`. Set to
     * `null` to remove fill.
     *
     * __Default value:__ (None)
     */
    val fill : Option[MarkConfigFill] = None,

    /**
     * Whether the mark's color should be used as fill color instead of stroke color.
     *
     * __Default value:__ `false` for all `point`, `line`, and `rule` marks as well as
     * `geoshape` marks for
     * [`graticule`](https://vega.github.io/vega-lite/docs/data.html#graticule) data sources;
     * otherwise, `true`.
     *
     * __Note:__ This property cannot be used in a [style
     * config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
     */
    val filled : Option[Boolean] = None,

    val fillOpacity : Option[Opacity] = None,
    val font : Option[BackgroundUnion] = None,
    val fontSize : Option[FontSize] = None,
    val fontStyle : Option[BackgroundUnion] = None,
    val fontWeight : Option[FontWeightUnion] = None,
    val height : Option[CornerRadius] = None,
    val href : Option[BackgroundUnion] = None,

    /**
     * The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`.
     *
     * __Default value:__ `0`
     */
    val innerRadius : Option[CornerRadius] = None,

    val interpolate : Option[MarkConfigInterpolate] = None,

    /**
     * Defines how Vega-Lite should handle marks for invalid values (`null` and `NaN`).
     * - If set to `"filter"` (default), all data items with null values will be skipped (for
     * line, trail, and area marks) or filtered (for other marks).
     * - If `null`, all data items are included. In this case, invalid values will be
     * interpreted as zeroes.
     */
    val invalid : Option[Invalid] = None,

    val limit : Option[CornerRadius] = None,
    val lineBreak : Option[BackgroundUnion] = None,
    val lineHeight : Option[CornerRadius] = None,

    /**
     * The overall opacity (value between [0,1]).
     *
     * __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or
     * `square` marks or layered `bar` charts and `1` otherwise.
     */
    val opacity : Option[CornerRadius] = None,

    /**
     * For line and trail marks, this `order` property can be set to `null` or `false` to make
     * the lines use the original order in the data sources.
     */
    val order : Option[Boolean] = None,

    /**
     * The orientation of a non-stacked bar, tick, area, and line charts. The value is either
     * horizontal (default) or vertical.
     * - For bar, rule and tick, this determines whether the size of the bar and tick should be
     * applied to x or y dimension.
     * - For area, this property determines the orient property of the Vega output.
     * - For line and trail marks, this property determines the sort order of the points in the
     * line if `config.sortLineBy` is not specified. For stacked charts, this is always
     * determined by the orientation of the stack; therefore explicitly specified value will be
     * ignored.
     */
    val orient : Option[Orientation] = None,

    /**
     * The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`.
     *
     * __Default value:__ `0`
     */
    val outerRadius : Option[CornerRadius] = None,

    val padAngle : Option[CornerRadius] = None,

    /**
     * For arc mark, the primary (outer) radius in pixels.
     *
     * For text marks, polar coordinate radial offset, in pixels, of the text from the origin
     * determined by the `x` and `y` properties.
     *
     * __Default value:__ `min(plot_width, plot_height)/2`
     */
    val radius : Option[CornerRadius] = None,

    /**
     * The secondary (inner) radius in pixels of arc marks.
     *
     * __Default value:__ `0`
     */
    val radius2 : Option[CornerRadius] = None,

    val shape : Option[BackgroundUnion] = None,

    /**
     * Default size for marks.
     * - For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that
     * this value sets the area of the symbol; the side lengths will increase with the square
     * root of this value.
     * - For `bar`, this represents the band size of the bar, in pixels.
     * - For `text`, this represents the font size, in pixels.
     *
     * __Default value:__
     * - `30` for point, circle, square marks; width/height's `step`
     * - `2` for bar marks with discrete dimensions;
     * - `5` for bar marks with continuous dimensions;
     * - `11` for text marks.
     */
    val size : Option[CornerRadius] = None,

    val smooth : Option[Aria] = None,
    val startAngle : Option[CornerRadius] = None,

    /**
     * Default stroke color. This property has higher precedence than `config.color`. Set to
     * `null` to remove stroke.
     *
     * __Default value:__ (None)
     */
    val stroke : Option[MarkConfigFill] = None,

    val strokeCap : Option[Cap] = None,
    val strokeDash : Option[StrokeDash] = None,
    val strokeDashOffset : Option[CornerRadius] = None,
    val strokeJoin : Option[StrokeJoinUnion] = None,
    val strokeMiterLimit : Option[CornerRadius] = None,
    val strokeOffset : Option[CornerRadius] = None,
    val strokeOpacity : Option[Opacity] = None,
    val strokeWidth : Option[FontSize] = None,
    val tension : Option[CornerRadius] = None,
    val text : Option[TextUnion] = None,

    /**
     * - For arc marks, the arc length in radians if theta2 is not specified, otherwise the
     * start arc angle. (A value of 0 indicates up or “north”, increasing values proceed
     * clockwise.)
     *
     * - For text marks, polar coordinate angle in radians.
     */
    val theta : Option[CornerRadius] = None,

    /**
     * The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing
     * values proceed clockwise.
     */
    val theta2 : Option[CornerRadius] = None,

    /**
     * Default relative band position for a time unit. If set to `0`, the marks will be
     * positioned at the beginning of the time unit band step. If set to `0.5`, the marks will
     * be positioned in the middle of the time unit band step.
     */
    val timeUnitBandPosition : Option[Double] = None,

    /**
     * Default relative band size for a time unit. If set to `1`, the bandwidth of the marks
     * will be equal to the time unit band step. If set to `0.5`, bandwidth of the marks will be
     * half of the time unit band step.
     */
    val timeUnitBandSize : Option[Double] = None,

    /**
     * The tooltip text string to show upon mouse hover or an object defining which fields
     * should the tooltip be derived from.
     *
     * - If `tooltip` is `true` or `{"content": "encoding"}`, then all fields from `encoding`
     * will be used.
     * - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted
     * data point will be used.
     * - If set to `null` or `false`, then no tooltip will be used.
     *
     * See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for
     * a detailed discussion about tooltip  in Vega-Lite.
     *
     * __Default value:__ `null`
     */
    val tooltip : Option[OverlayMarkDefTooltip] = None,

    val url : Option[BackgroundUnion] = None,
    val width : Option[CornerRadius] = None,

    /**
     * X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified
     * `x2` or `width`.
     *
     * The `value` of this channel can be a number or a string `"width"` for the width of the
     * plot.
     */
    val x : Option[X] = None,

    /**
     * X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
     *
     * The `value` of this channel can be a number or a string `"width"` for the width of the
     * plot.
     */
    val x2 : Option[X] = None,

    /**
     * Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified
     * `y2` or `height`.
     *
     * The `value` of this channel can be a number or a string `"height"` for the height of the
     * plot.
     */
    val y : Option[X] = None,

    /**
     * Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
     *
     * The `value` of this channel can be a number or a string `"height"` for the height of the
     * plot.
     */
    val y2 : Option[X] = None,

    /**
     * A flag for overlaying line on top of area marks, or an object defining the properties of
     * the overlayed lines.
     *
     * - If this value is an empty object (`{}`) or `true`, lines with default properties will
     * be used.
     *
     * - If this value is `false`, no lines would be automatically added to area marks.
     *
     * __Default value:__ `false`.
     */
    val line : Option[Line] = None,

    /**
     * A flag for overlaying points on top of line or area marks, or an object defining the
     * properties of the overlayed points.
     *
     * - If this property is `"transparent"`, transparent points will be used (for enhancing
     * tooltips and selections).
     *
     * - If this property is an empty object (`{}`) or `true`, filled points with default
     * properties will be used.
     *
     * - If this property is `false`, no points would be automatically added to line or area
     * marks.
     *
     * __Default value:__ `false`.
     */
    val point : Option[Point] = None,

    /**
     * Offset between bars for binned field. The ideal value for this is either 0 (preferred by
     * statisticians) or 1 (Vega-Lite default, D3 example style).
     *
     * __Default value:__ `1`
     */
    val binSpacing : Option[Double] = None,

    /**
     * The default size of the bars on continuous scales.
     *
     * __Default value:__ `5`
     */
    val continuousBandSize : Option[Double] = None,

    /**
     * - For vertical bars, top-left and top-right corner radius.
     *
     * - For horizontal bars, top-right and bottom-right corner radius.
     */
    val cornerRadiusEnd : Option[CornerRadius] = None,

    /**
     * The default size of the bars with discrete dimensions. If unspecified, the default size
     * is  `step-2`, which provides 2 pixel offset between bars.
     */
    val discreteBandSize : Option[DiscreteBandSize] = None,

    /**
     * The width of the ticks.
     *
     * __Default value:__  3/4 of step (width step for horizontal ticks and height step for
     * vertical ticks).
     */
    val bandSize : Option[Double] = None,

    /**
     * Thickness of the tick mark.
     *
     * __Default value:__  `1`
     */
    val thickness : Option[Double] = None
) derives Encoder.AsObject, Decoder

type BlendUnion = BackgroundExprRef | BlendEnum | NullValue
given Decoder[BlendUnion] = {
    List[Decoder[BlendUnion]](
        Decoder[BackgroundExprRef].widen,
        Decoder[BlendEnum].widen,
        Decoder[NullValue].widen,
    ).reduceLeft(_ or _)
}

given Encoder[BlendUnion] = Encoder.instance {
    case enc0 : BackgroundExprRef => Encoder.AsObject[BackgroundExprRef].apply(enc0)
    case enc1 : BlendEnum => summon[Encoder[BlendEnum]].apply(enc1)
    case enc2 : NullValue => Encoder.encodeNone(enc2)
}

enum BlendEnum : 
    case color
    case `color-burn`
    case `color-dodge`
    case darken
    case difference
    case exclusion
    case `hard-light`
    case hue
    case lighten
    case luminosity
    case multiply
    case overlay
    case saturation
    case screen
    case `soft-light`
given Decoder[BlendEnum] = Decoder.decodeString.emapTry(x => Try(BlendEnum.valueOf(x) )) 
given Encoder[BlendEnum] = Encoder.encodeString.contramap(_.toString())

/**
 * Default color.
 *
 * __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
 *
 * __Note:__
 * - This property cannot be used in a [style
 * config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
 * - The `fill` and `stroke` properties have higher precedence than `color` and will
 * override `color`.
 */
type MarkConfigColor = ColorLinearGradient | String
given Decoder[MarkConfigColor] = {
    List[Decoder[MarkConfigColor]](
        Decoder[ColorLinearGradient].widen,
        Decoder[String].widen,
    ).reduceLeft(_ or _)
}

given Encoder[MarkConfigColor] = Encoder.instance {
    case enc0 : ColorLinearGradient => Encoder.AsObject[ColorLinearGradient].apply(enc0)
    case enc1 : String => Encoder.encodeString(enc1)
}

case class ColorLinearGradient (
    /**
     * The type of gradient. Use `"linear"` for a linear gradient.
     *
     * The type of gradient. Use `"radial"` for a radial gradient.
     */
    val gradient : Option[String] = None,

    val id : Option[String] = None,

    /**
     * An array of gradient stops defining the gradient color sequence.
     */
    val stops : Option[Seq[GradientStop]] = None,

    /**
     * The starting x-coordinate, in normalized [0, 1] coordinates, of the linear gradient.
     *
     * __Default value:__ `0`
     *
     * The x-coordinate, in normalized [0, 1] coordinates, for the center of the inner circle
     * for the gradient.
     *
     * __Default value:__ `0.5`
     */
    val x1 : Option[Double] = None,

    /**
     * The ending x-coordinate, in normalized [0, 1] coordinates, of the linear gradient.
     *
     * __Default value:__ `1`
     *
     * The x-coordinate, in normalized [0, 1] coordinates, for the center of the outer circle
     * for the gradient.
     *
     * __Default value:__ `0.5`
     */
    val x2 : Option[Double] = None,

    /**
     * The starting y-coordinate, in normalized [0, 1] coordinates, of the linear gradient.
     *
     * __Default value:__ `0`
     *
     * The y-coordinate, in normalized [0, 1] coordinates, for the center of the inner circle
     * for the gradient.
     *
     * __Default value:__ `0.5`
     */
    val y1 : Option[Double] = None,

    /**
     * The ending y-coordinate, in normalized [0, 1] coordinates, of the linear gradient.
     *
     * __Default value:__ `0`
     *
     * The y-coordinate, in normalized [0, 1] coordinates, for the center of the outer circle
     * for the gradient.
     *
     * __Default value:__ `0.5`
     */
    val y2 : Option[Double] = None,

    /**
     * The radius length, in normalized [0, 1] coordinates, of the inner circle for the
     * gradient.
     *
     * __Default value:__ `0`
     */
    val r1 : Option[Double] = None,

    /**
     * The radius length, in normalized [0, 1] coordinates, of the outer circle for the
     * gradient.
     *
     * __Default value:__ `0.5`
     */
    val r2 : Option[Double] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None
) derives Encoder.AsObject, Decoder

type CursorUnion = BackgroundExprRef | Cursor
given Decoder[CursorUnion] = {
    List[Decoder[CursorUnion]](
        Decoder[BackgroundExprRef].widen,
        Decoder[Cursor].widen,
    ).reduceLeft(_ or _)
}

given Encoder[CursorUnion] = Encoder.instance {
    case enc0 : BackgroundExprRef => Encoder.AsObject[BackgroundExprRef].apply(enc0)
    case enc1 : Cursor => summon[Encoder[Cursor]].apply(enc1)
}

/**
 * The mouse cursor used over the mark. Any valid [CSS cursor
 * type](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Values) can be used.
 *
 * The mouse cursor used over the interval mark. Any valid [CSS cursor
 * type](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Values) can be used.
 *
 * The mouse cursor used over the view. Any valid [CSS cursor
 * type](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Values) can be used.
 */

enum Cursor : 
    case alias
    case `all-scroll`
    case auto
    case cell
    case `col-resize`
    case `context-menu`
    case copy
    case crosshair
    case default
    case `e-resize`
    case `ew-resize`
    case grab
    case grabbing
    case help
    case move
    case `n-resize`
    case `ne-resize`
    case `nesw-resize`
    case `no-drop`
    case none
    case `not-allowed`
    case `ns-resize`
    case `nw-resize`
    case `nwse-resize`
    case pointer
    case progress
    case `row-resize`
    case `s-resize`
    case `se-resize`
    case `sw-resize`
    case text
    case `vertical-text`
    case `w-resize`
    //case `wait`
    case `zoom-in`
    case `zoom-out`
given Decoder[Cursor] = Decoder.decodeString.emapTry(x => Try(Cursor.valueOf(x) )) 
given Encoder[Cursor] = Encoder.encodeString.contramap(_.toString())

type Dir = BackgroundExprRef | TextDirection
given Decoder[Dir] = {
    List[Decoder[Dir]](
        Decoder[BackgroundExprRef].widen,
        Decoder[TextDirection].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Dir] = Encoder.instance {
    case enc0 : BackgroundExprRef => Encoder.AsObject[BackgroundExprRef].apply(enc0)
    case enc1 : TextDirection => summon[Encoder[TextDirection]].apply(enc1)
}

/**
 * The direction of the text. One of `"ltr"` (left-to-right) or `"rtl"` (right-to-left).
 * This property determines on which side is truncated in response to the limit parameter.
 *
 * __Default value:__ `"ltr"`
 */

enum TextDirection : 
    case ltr
    case rtl
given Decoder[TextDirection] = Decoder.decodeString.emapTry(x => Try(TextDirection.valueOf(x) )) 
given Encoder[TextDirection] = Encoder.encodeString.contramap(_.toString())

type DiscreteBandSize = Double | RelativeBandSize
given Decoder[DiscreteBandSize] = {
    List[Decoder[DiscreteBandSize]](
        Decoder[Double].widen,
        Decoder[RelativeBandSize].widen,
    ).reduceLeft(_ or _)
}

given Encoder[DiscreteBandSize] = Encoder.instance {
    case enc0 : Double => Encoder.encodeDouble(enc0)
    case enc1 : RelativeBandSize => Encoder.AsObject[RelativeBandSize].apply(enc1)
}

case class RelativeBandSize (
    /**
     * The relative band size.  For example `0.5` means half of the band scale's band width.
     */
    val band : Double
) derives Encoder.AsObject, Decoder

type MarkConfigFill = FillLinearGradient | String | NullValue
given Decoder[MarkConfigFill] = {
    List[Decoder[MarkConfigFill]](
        Decoder[FillLinearGradient].widen,
        Decoder[String].widen,
        Decoder[NullValue].widen,
    ).reduceLeft(_ or _)
}

given Encoder[MarkConfigFill] = Encoder.instance {
    case enc0 : FillLinearGradient => Encoder.AsObject[FillLinearGradient].apply(enc0)
    case enc1 : String => Encoder.encodeString(enc1)
    case enc2 : NullValue => Encoder.encodeNone(enc2)
}

case class FillLinearGradient (
    /**
     * The type of gradient. Use `"linear"` for a linear gradient.
     *
     * The type of gradient. Use `"radial"` for a radial gradient.
     */
    val gradient : Option[String] = None,

    val id : Option[String] = None,

    /**
     * An array of gradient stops defining the gradient color sequence.
     */
    val stops : Option[Seq[GradientStop]] = None,

    /**
     * The starting x-coordinate, in normalized [0, 1] coordinates, of the linear gradient.
     *
     * __Default value:__ `0`
     *
     * The x-coordinate, in normalized [0, 1] coordinates, for the center of the inner circle
     * for the gradient.
     *
     * __Default value:__ `0.5`
     */
    val x1 : Option[Double] = None,

    /**
     * The ending x-coordinate, in normalized [0, 1] coordinates, of the linear gradient.
     *
     * __Default value:__ `1`
     *
     * The x-coordinate, in normalized [0, 1] coordinates, for the center of the outer circle
     * for the gradient.
     *
     * __Default value:__ `0.5`
     */
    val x2 : Option[Double] = None,

    /**
     * The starting y-coordinate, in normalized [0, 1] coordinates, of the linear gradient.
     *
     * __Default value:__ `0`
     *
     * The y-coordinate, in normalized [0, 1] coordinates, for the center of the inner circle
     * for the gradient.
     *
     * __Default value:__ `0.5`
     */
    val y1 : Option[Double] = None,

    /**
     * The ending y-coordinate, in normalized [0, 1] coordinates, of the linear gradient.
     *
     * __Default value:__ `0`
     *
     * The y-coordinate, in normalized [0, 1] coordinates, for the center of the outer circle
     * for the gradient.
     *
     * __Default value:__ `0.5`
     */
    val y2 : Option[Double] = None,

    /**
     * The radius length, in normalized [0, 1] coordinates, of the inner circle for the
     * gradient.
     *
     * __Default value:__ `0`
     */
    val r1 : Option[Double] = None,

    /**
     * The radius length, in normalized [0, 1] coordinates, of the outer circle for the
     * gradient.
     *
     * __Default value:__ `0.5`
     */
    val r2 : Option[Double] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None
) derives Encoder.AsObject, Decoder

type Opacity = BackgroundExprRef | Double
type MarkConfigInterpolate = BackgroundExprRef | Interpolate
given Decoder[MarkConfigInterpolate] = {
    List[Decoder[MarkConfigInterpolate]](
        Decoder[BackgroundExprRef].widen,
        Decoder[Interpolate].widen,
    ).reduceLeft(_ or _)
}

given Encoder[MarkConfigInterpolate] = Encoder.instance {
    case enc0 : BackgroundExprRef => Encoder.AsObject[BackgroundExprRef].apply(enc0)
    case enc1 : Interpolate => summon[Encoder[Interpolate]].apply(enc1)
}

/**
 * The line interpolation method to use for line and area marks. One of the following:
 * - `"linear"`: piecewise linear segments, as in a polyline.
 * - `"linear-closed"`: close the linear segments to form a polygon.
 * - `"step"`: alternate between horizontal and vertical segments, as in a step function.
 * - `"step-before"`: alternate between vertical and horizontal segments, as in a step
 * function.
 * - `"step-after"`: alternate between horizontal and vertical segments, as in a step
 * function.
 * - `"basis"`: a B-spline, with control point duplication on the ends.
 * - `"basis-open"`: an open B-spline; may not intersect the start or end.
 * - `"basis-closed"`: a closed B-spline, as in a loop.
 * - `"cardinal"`: a Cardinal spline, with control point duplication on the ends.
 * - `"cardinal-open"`: an open Cardinal spline; may not intersect the start or end, but
 * will intersect other control points.
 * - `"cardinal-closed"`: a closed Cardinal spline, as in a loop.
 * - `"bundle"`: equivalent to basis, except the tension parameter is used to straighten the
 * spline.
 * - `"monotone"`: cubic interpolation that preserves monotonicity in y.
 *
 * The line interpolation method for the error band. One of the following:
 * - `"linear"`: piecewise linear segments, as in a polyline.
 * - `"linear-closed"`: close the linear segments to form a polygon.
 * - `"step"`: a piecewise constant function (a step function) consisting of alternating
 * horizontal and vertical lines. The y-value changes at the midpoint of each pair of
 * adjacent x-values.
 * - `"step-before"`: a piecewise constant function (a step function) consisting of
 * alternating horizontal and vertical lines. The y-value changes before the x-value.
 * - `"step-after"`: a piecewise constant function (a step function) consisting of
 * alternating horizontal and vertical lines. The y-value changes after the x-value.
 * - `"basis"`: a B-spline, with control point duplication on the ends.
 * - `"basis-open"`: an open B-spline; may not intersect the start or end.
 * - `"basis-closed"`: a closed B-spline, as in a loop.
 * - `"cardinal"`: a Cardinal spline, with control point duplication on the ends.
 * - `"cardinal-open"`: an open Cardinal spline; may not intersect the start or end, but
 * will intersect other control points.
 * - `"cardinal-closed"`: a closed Cardinal spline, as in a loop.
 * - `"bundle"`: equivalent to basis, except the tension parameter is used to straighten the
 * spline.
 * - `"monotone"`: cubic interpolation that preserves monotonicity in y.
 */

enum Interpolate : 
    case basis
    case `basis-closed`
    case `basis-open`
    case bundle
    case cardinal
    case `cardinal-closed`
    case `cardinal-open`
    case `catmull-rom`
    case linear
    case `linear-closed`
    case monotone
    case natural
    case step
    case `step-after`
    case `step-before`
given Decoder[Interpolate] = Decoder.decodeString.emapTry(x => Try(Interpolate.valueOf(x) )) 
given Encoder[Interpolate] = Encoder.encodeString.contramap(_.toString())

enum Invalid : 
    case filter
given Decoder[Invalid] = Decoder.decodeString.emapTry(x => Try(Invalid.valueOf(x) )) 
given Encoder[Invalid] = Encoder.encodeString.contramap(_.toString())

type Line = Boolean | OverlayMarkDef
given Decoder[Line] = {
    List[Decoder[Line]](
        Decoder[Boolean].widen,
        Decoder[OverlayMarkDef].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Line] = Encoder.instance {
    case enc0 : Boolean => Encoder.encodeBoolean(enc0)
    case enc1 : OverlayMarkDef => Encoder.AsObject[OverlayMarkDef].apply(enc1)
}

case class OverlayMarkDef (
    /**
     * The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One
     * of `"left"`, `"right"`, `"center"`.
     *
     * __Note:__ Expression reference is *not* supported for range marks.
     */
    val align : Option[TitleAlignUnion] = None,

    val angle : Option[Angle] = None,
    val aria : Option[Aria] = None,
    val ariaRole : Option[BackgroundUnion] = None,
    val ariaRoleDescription : Option[BackgroundUnion] = None,
    val aspect : Option[Aria] = None,

    /**
     * For text marks, the vertical text baseline. One of `"alphabetic"` (default), `"top"`,
     * `"middle"`, `"bottom"`, `"line-top"`, `"line-bottom"`, or an expression reference that
     * provides one of the valid values. The `"line-top"` and `"line-bottom"` values operate
     * similarly to `"top"` and `"bottom"`, but are calculated relative to the `lineHeight`
     * rather than `fontSize` alone.
     *
     * For range marks, the vertical alignment of the marks. One of `"top"`, `"middle"`,
     * `"bottom"`.
     *
     * __Note:__ Expression reference is *not* supported for range marks.
     */
    val baseline : Option[BackgroundUnion] = None,

    val blend : Option[BlendUnion] = None,

    /**
     * Whether a mark be clipped to the enclosing group’s width and height.
     */
    val clip : Option[Boolean] = None,

    /**
     * Default color.
     *
     * __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
     *
     * __Note:__
     * - This property cannot be used in a [style
     * config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
     * - The `fill` and `stroke` properties have higher precedence than `color` and will
     * override `color`.
     */
    val color : Option[MarkConfigColor] = None,

    val cornerRadius : Option[CornerRadius] = None,
    val cornerRadiusBottomLeft : Option[CornerRadius] = None,
    val cornerRadiusBottomRight : Option[CornerRadius] = None,
    val cornerRadiusTopLeft : Option[CornerRadius] = None,
    val cornerRadiusTopRight : Option[CornerRadius] = None,
    val cursor : Option[CursorUnion] = None,
    val description : Option[BackgroundUnion] = None,
    val dir : Option[Dir] = None,
    val dx : Option[CornerRadius] = None,
    val dy : Option[CornerRadius] = None,
    val ellipsis : Option[BackgroundUnion] = None,
    val endAngle : Option[CornerRadius] = None,

    /**
     * Default fill color. This property has higher precedence than `config.color`. Set to
     * `null` to remove fill.
     *
     * __Default value:__ (None)
     */
    val fill : Option[MarkConfigFill] = None,

    /**
     * Whether the mark's color should be used as fill color instead of stroke color.
     *
     * __Default value:__ `false` for all `point`, `line`, and `rule` marks as well as
     * `geoshape` marks for
     * [`graticule`](https://vega.github.io/vega-lite/docs/data.html#graticule) data sources;
     * otherwise, `true`.
     *
     * __Note:__ This property cannot be used in a [style
     * config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
     */
    val filled : Option[Boolean] = None,

    val fillOpacity : Option[Opacity] = None,
    val font : Option[BackgroundUnion] = None,
    val fontSize : Option[FontSize] = None,
    val fontStyle : Option[BackgroundUnion] = None,
    val fontWeight : Option[FontWeightUnion] = None,
    val height : Option[CornerRadius] = None,
    val href : Option[BackgroundUnion] = None,

    /**
     * The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`.
     *
     * __Default value:__ `0`
     */
    val innerRadius : Option[CornerRadius] = None,

    val interpolate : Option[MarkConfigInterpolate] = None,

    /**
     * Defines how Vega-Lite should handle marks for invalid values (`null` and `NaN`).
     * - If set to `"filter"` (default), all data items with null values will be skipped (for
     * line, trail, and area marks) or filtered (for other marks).
     * - If `null`, all data items are included. In this case, invalid values will be
     * interpreted as zeroes.
     */
    val invalid : Option[Invalid] = None,

    val limit : Option[CornerRadius] = None,
    val lineBreak : Option[BackgroundUnion] = None,
    val lineHeight : Option[CornerRadius] = None,

    /**
     * The overall opacity (value between [0,1]).
     *
     * __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or
     * `square` marks or layered `bar` charts and `1` otherwise.
     */
    val opacity : Option[CornerRadius] = None,

    /**
     * For line and trail marks, this `order` property can be set to `null` or `false` to make
     * the lines use the original order in the data sources.
     */
    val order : Option[Boolean] = None,

    /**
     * The orientation of a non-stacked bar, tick, area, and line charts. The value is either
     * horizontal (default) or vertical.
     * - For bar, rule and tick, this determines whether the size of the bar and tick should be
     * applied to x or y dimension.
     * - For area, this property determines the orient property of the Vega output.
     * - For line and trail marks, this property determines the sort order of the points in the
     * line if `config.sortLineBy` is not specified. For stacked charts, this is always
     * determined by the orientation of the stack; therefore explicitly specified value will be
     * ignored.
     */
    val orient : Option[Orientation] = None,

    /**
     * The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`.
     *
     * __Default value:__ `0`
     */
    val outerRadius : Option[CornerRadius] = None,

    val padAngle : Option[CornerRadius] = None,

    /**
     * For arc mark, the primary (outer) radius in pixels.
     *
     * For text marks, polar coordinate radial offset, in pixels, of the text from the origin
     * determined by the `x` and `y` properties.
     *
     * __Default value:__ `min(plot_width, plot_height)/2`
     */
    val radius : Option[CornerRadius] = None,

    /**
     * The secondary (inner) radius in pixels of arc marks.
     *
     * __Default value:__ `0`
     */
    val radius2 : Option[CornerRadius] = None,

    /**
     * Offset for radius2.
     */
    val radius2Offset : Option[CornerRadius] = None,

    /**
     * Offset for radius.
     */
    val radiusOffset : Option[CornerRadius] = None,

    val shape : Option[BackgroundUnion] = None,

    /**
     * Default size for marks.
     * - For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that
     * this value sets the area of the symbol; the side lengths will increase with the square
     * root of this value.
     * - For `bar`, this represents the band size of the bar, in pixels.
     * - For `text`, this represents the font size, in pixels.
     *
     * __Default value:__
     * - `30` for point, circle, square marks; width/height's `step`
     * - `2` for bar marks with discrete dimensions;
     * - `5` for bar marks with continuous dimensions;
     * - `11` for text marks.
     */
    val size : Option[CornerRadius] = None,

    val smooth : Option[Aria] = None,
    val startAngle : Option[CornerRadius] = None,

    /**
     * Default stroke color. This property has higher precedence than `config.color`. Set to
     * `null` to remove stroke.
     *
     * __Default value:__ (None)
     */
    val stroke : Option[MarkConfigFill] = None,

    val strokeCap : Option[Cap] = None,
    val strokeDash : Option[StrokeDash] = None,
    val strokeDashOffset : Option[CornerRadius] = None,
    val strokeJoin : Option[StrokeJoinUnion] = None,
    val strokeMiterLimit : Option[CornerRadius] = None,
    val strokeOffset : Option[CornerRadius] = None,
    val strokeOpacity : Option[Opacity] = None,
    val strokeWidth : Option[FontSize] = None,

    /**
     * A string or array of strings indicating the name of custom styles to apply to the mark. A
     * style is a named collection of mark property defaults defined within the [style
     * configuration](https://vega.github.io/vega-lite/docs/mark.html#style-config). If style is
     * an array, later styles will override earlier styles. Any [mark
     * properties](https://vega.github.io/vega-lite/docs/encoding.html#mark-prop) explicitly
     * defined within the `encoding` will override a style default.
     *
     * __Default value:__ The mark's name. For example, a bar mark will have style `"bar"` by
     * default. __Note:__ Any specified style will augment the default style. For example, a bar
     * mark with `"style": "foo"` will receive from `config.style.bar` and `config.style.foo`
     * (the specified style `"foo"` has higher precedence).
     */
    val style : Option[Text] = None,

    val tension : Option[CornerRadius] = None,
    val text : Option[TextUnion] = None,

    /**
     * - For arc marks, the arc length in radians if theta2 is not specified, otherwise the
     * start arc angle. (A value of 0 indicates up or “north”, increasing values proceed
     * clockwise.)
     *
     * - For text marks, polar coordinate angle in radians.
     */
    val theta : Option[CornerRadius] = None,

    /**
     * The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing
     * values proceed clockwise.
     */
    val theta2 : Option[CornerRadius] = None,

    /**
     * Offset for theta2.
     */
    val theta2Offset : Option[CornerRadius] = None,

    /**
     * Offset for theta.
     */
    val thetaOffset : Option[CornerRadius] = None,

    /**
     * Default relative band position for a time unit. If set to `0`, the marks will be
     * positioned at the beginning of the time unit band step. If set to `0.5`, the marks will
     * be positioned in the middle of the time unit band step.
     */
    val timeUnitBandPosition : Option[Double] = None,

    /**
     * Default relative band size for a time unit. If set to `1`, the bandwidth of the marks
     * will be equal to the time unit band step. If set to `0.5`, bandwidth of the marks will be
     * half of the time unit band step.
     */
    val timeUnitBandSize : Option[Double] = None,

    /**
     * The tooltip text string to show upon mouse hover or an object defining which fields
     * should the tooltip be derived from.
     *
     * - If `tooltip` is `true` or `{"content": "encoding"}`, then all fields from `encoding`
     * will be used.
     * - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted
     * data point will be used.
     * - If set to `null` or `false`, then no tooltip will be used.
     *
     * See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for
     * a detailed discussion about tooltip  in Vega-Lite.
     *
     * __Default value:__ `null`
     */
    val tooltip : Option[OverlayMarkDefTooltip] = None,

    val url : Option[BackgroundUnion] = None,
    val width : Option[CornerRadius] = None,

    /**
     * X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified
     * `x2` or `width`.
     *
     * The `value` of this channel can be a number or a string `"width"` for the width of the
     * plot.
     */
    val x : Option[X] = None,

    /**
     * X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
     *
     * The `value` of this channel can be a number or a string `"width"` for the width of the
     * plot.
     */
    val x2 : Option[X] = None,

    /**
     * Offset for x2-position.
     */
    val x2Offset : Option[CornerRadius] = None,

    /**
     * Offset for x-position.
     */
    val xOffset : Option[CornerRadius] = None,

    /**
     * Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified
     * `y2` or `height`.
     *
     * The `value` of this channel can be a number or a string `"height"` for the height of the
     * plot.
     */
    val y : Option[X] = None,

    /**
     * Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
     *
     * The `value` of this channel can be a number or a string `"height"` for the height of the
     * plot.
     */
    val y2 : Option[X] = None,

    /**
     * Offset for y2-position.
     */
    val y2Offset : Option[CornerRadius] = None,

    /**
     * Offset for y-position.
     */
    val yOffset : Option[CornerRadius] = None
) derives Encoder.AsObject, Decoder

type StrokeJoinUnion = BackgroundExprRef | StrokeJoin
given Decoder[StrokeJoinUnion] = {
    List[Decoder[StrokeJoinUnion]](
        Decoder[BackgroundExprRef].widen,
        Decoder[StrokeJoin].widen,
    ).reduceLeft(_ or _)
}

given Encoder[StrokeJoinUnion] = Encoder.instance {
    case enc0 : BackgroundExprRef => Encoder.AsObject[BackgroundExprRef].apply(enc0)
    case enc1 : StrokeJoin => summon[Encoder[StrokeJoin]].apply(enc1)
}

/**
 * The stroke line join method. One of `"miter"`, `"round"` or `"bevel"`.
 *
 * __Default value:__ `"miter"`
 */

enum StrokeJoin : 
    case bevel
    case miter
    case round
given Decoder[StrokeJoin] = Decoder.decodeString.emapTry(x => Try(StrokeJoin.valueOf(x) )) 
given Encoder[StrokeJoin] = Encoder.encodeString.contramap(_.toString())

type OverlayMarkDefTooltip = Boolean | Double | String | TooltipContent | NullValue
given Decoder[OverlayMarkDefTooltip] = {
    List[Decoder[OverlayMarkDefTooltip]](
        Decoder[Boolean].widen,
        Decoder[Double].widen,
        Decoder[String].widen,
        Decoder[TooltipContent].widen,
        Decoder[NullValue].widen,
    ).reduceLeft(_ or _)
}

given Encoder[OverlayMarkDefTooltip] = Encoder.instance {
    case enc0 : Boolean => Encoder.encodeBoolean(enc0)
    case enc1 : Double => Encoder.encodeDouble(enc1)
    case enc2 : String => Encoder.encodeString(enc2)
    case enc3 : TooltipContent => Encoder.AsObject[TooltipContent].apply(enc3)
    case enc4 : NullValue => Encoder.encodeNone(enc4)
}

case class TooltipContent (
    val content : Option[Content] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None
) derives Encoder.AsObject, Decoder

enum Content : 
    case data
    case encoding
given Decoder[Content] = Decoder.decodeString.emapTry(x => Try(Content.valueOf(x) )) 
given Encoder[Content] = Encoder.encodeString.contramap(_.toString())

type Point = Boolean | OverlayMarkDef | String
given Decoder[Point] = {
    List[Decoder[Point]](
        Decoder[Boolean].widen,
        Decoder[OverlayMarkDef].widen,
        Decoder[String].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Point] = Encoder.instance {
    case enc0 : Boolean => Encoder.encodeBoolean(enc0)
    case enc1 : OverlayMarkDef => Encoder.AsObject[OverlayMarkDef].apply(enc1)
    case enc2 : String => Encoder.encodeString(enc2)
}

type BoxPlotDefExtent = Double | String
type BoxPlotDefHeight = Double | RelativeBandSizeClass
given Decoder[BoxPlotDefHeight] = {
    List[Decoder[BoxPlotDefHeight]](
        Decoder[Double].widen,
        Decoder[RelativeBandSizeClass].widen,
    ).reduceLeft(_ or _)
}

given Encoder[BoxPlotDefHeight] = Encoder.instance {
    case enc0 : Double => Encoder.encodeDouble(enc0)
    case enc1 : RelativeBandSizeClass => Encoder.AsObject[RelativeBandSizeClass].apply(enc1)
}

case class RelativeBandSizeClass (
    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None,

    /**
     * The relative band size.  For example `0.5` means half of the band scale's band width.
     */
    val band : Option[Double] = None
) derives Encoder.AsObject, Decoder

case class SelectionParameter (
    /**
     * When set, a selection is populated by input elements (also known as dynamic query
     * widgets) or by interacting with the corresponding legend. Direct manipulation interaction
     * is disabled by default; to re-enable it, set the selection's
     * [`on`](https://vega.github.io/vega-lite/docs/selection.html#common-selection-properties)
     * property.
     *
     * Legend bindings are restricted to selections that only specify a single field or
     * encoding.
     *
     * Query widget binding takes the form of Vega's [input element binding
     * definition](https://vega.github.io/vega/docs/signals/#bind) or can be a mapping between
     * projected field/encodings and binding definitions.
     *
     * __See also:__ [`bind`](https://vega.github.io/vega-lite/docs/bind.html) documentation.
     */
    val bind : Option[ParamBind] = None,

    /**
     * Required. A unique name for the selection parameter. Selection names should be valid
     * JavaScript identifiers: they should contain only alphanumeric characters (or "$", or "_")
     * and may not start with a digit. Reserved keywords that may not be used as parameter names
     * are "datum", "event", "item", and "parent".
     */
    val name : String,

    /**
     * Determines the default event processing and data query for the selection. Vega-Lite
     * currently supports two selection types:
     *
     * - `"point"` -- to select multiple discrete data values; the first value is selected on
     * `click` and additional values toggled on shift-click.
     * - `"interval"` -- to select a continuous range of data values on `drag`.
     */
    val select : Select,

    /**
     * Initialize the selection with a mapping between [projected channels or field
     * names](https://vega.github.io/vega-lite/docs/selection.html#project) and initial values.
     *
     * __See also:__ [`init`](https://vega.github.io/vega-lite/docs/value.html) documentation.
     */
    val value : Option[ParamValue] = None
) derives Encoder.AsObject, Decoder

/**
 * When set, a selection is populated by input elements (also known as dynamic query
 * widgets) or by interacting with the corresponding legend. Direct manipulation interaction
 * is disabled by default; to re-enable it, set the selection's
 * [`on`](https://vega.github.io/vega-lite/docs/selection.html#common-selection-properties)
 * property.
 *
 * Legend bindings are restricted to selections that only specify a single field or
 * encoding.
 *
 * Query widget binding takes the form of Vega's [input element binding
 * definition](https://vega.github.io/vega/docs/signals/#bind) or can be a mapping between
 * projected field/encodings and binding definitions.
 *
 * __See also:__ [`bind`](https://vega.github.io/vega-lite/docs/bind.html) documentation.
 */
type ParamBind = String | Map[String, PurpleStream]
given Decoder[ParamBind] = {
    List[Decoder[ParamBind]](
        Decoder[String].widen,
        Decoder[Map[String, PurpleStream]].widen,
    ).reduceLeft(_ or _)
}

given Encoder[ParamBind] = Encoder.instance {
    case enc0 : String => Encoder.encodeString(enc0)
    case enc1 : Map[String, PurpleStream] => Encoder.encodeMap[String,PurpleStream].apply(enc1)
}

type PurpleStream = Seq[Option[Json]] | Double | PurpleBinding | String
given Decoder[PurpleStream] = {
    List[Decoder[PurpleStream]](
        Decoder[Seq[Option[Json]]].widen,
        Decoder[Double].widen,
        Decoder[PurpleBinding].widen,
        Decoder[String].widen,
    ).reduceLeft(_ or _)
}

given Encoder[PurpleStream] = Encoder.instance {
    case enc0 : Seq[Option[Json]] => Encoder.encodeSeq[Option[Json]].apply(enc0)
    case enc1 : Double => Encoder.encodeDouble(enc1)
    case enc2 : PurpleBinding => Encoder.AsObject[PurpleBinding].apply(enc2)
    case enc3 : String => Encoder.encodeString(enc3)
}

/**
 * Binds the parameter to an external input element such as a slider, selection list or
 * radio button group.
 */
case class PurpleBinding (
    /**
     * If defined, delays event handling until the specified milliseconds have elapsed since the
     * last event was fired.
     */
    val debounce : Option[Double] = None,

    /**
     * An optional CSS selector string indicating the parent element to which the input element
     * should be added. By default, all input elements are added within the parent container of
     * the Vega view.
     *
     * An input element that exposes a _value_ property and supports the
     * [EventTarget](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget) interface, or
     * a CSS selector string to such an element. When the element updates and dispatches an
     * event, the _value_ property will be used as the new, bound signal value. When the signal
     * updates independent of the element, the _value_ property will be set to the signal value
     * and a new event will be dispatched on the element.
     */
    val element : Option[ElementUnion] = None,

    /**
     * The type of input element to use. The valid values are `"checkbox"`, `"radio"`,
     * `"range"`, `"select"`, and any other legal [HTML form input
     * type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input).
     */
    val input : Option[String] = None,

    /**
     * By default, the signal name is used to label input elements. This `name` property can be
     * used instead to specify a custom label for the bound signal.
     */
    val name : Option[String] = None,

    /**
     * An array of label strings to represent the `options` values. If unspecified, the
     * `options` value will be coerced to a string and used as the label.
     */
    val labels : Option[Seq[String]] = None,

    /**
     * An array of options to select from.
     */
    val options : Option[Seq[Option[Json]]] = None,

    /**
     * Sets the maximum slider value. Defaults to the larger of the signal value and `100`.
     */
    val max : Option[Double] = None,

    /**
     * Sets the minimum slider value. Defaults to the smaller of the signal value and `0`.
     */
    val min : Option[Double] = None,

    /**
     * Sets the minimum slider increment. If undefined, the step size will be automatically
     * determined based on the `min` and `max` values.
     */
    val step : Option[Double] = None,

    /**
     * A hint for form autofill. See the [HTML autocomplete
     * attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete) for
     * additional information.
     */
    val autocomplete : Option[String] = None,

    /**
     * Text that appears in the form control when it has no value set.
     */
    val placeholder : Option[String] = None,

    /**
     * The event (default `"input"`) to listen for to track changes on the external element.
     */
    val event : Option[String] = None,

    val between : Option[Seq[Stream]] = None,
    val consume : Option[Boolean] = None,
    val filter : Option[Text] = None,
    val markname : Option[String] = None,
    val marktype : Option[MarkType] = None,
    val source : Option[String] = None,
    val throttle : Option[Double] = None,
    val `type` : Option[String] = None,
    val stream : Option[Stream] = None,
    val merge : Option[Seq[Stream]] = None
) derives Encoder.AsObject, Decoder

case class Stream (
    val between : Option[Seq[Stream]] = None,
    val consume : Option[Boolean] = None,
    val debounce : Option[Double] = None,
    val filter : Option[Text] = None,
    val markname : Option[String] = None,
    val marktype : Option[MarkType] = None,
    val source : Option[String] = None,
    val throttle : Option[Double] = None,
    val `type` : Option[String] = None,
    val stream : Option[Stream] = None,
    val merge : Option[Seq[Stream]] = None
) derives Encoder.AsObject, Decoder

enum MarkType : 
    case arc
    case area
    case group
    case image
    case line
    case path
    case rect
    case rule
    case shape
    case symbol
    case text
    case trail
given Decoder[MarkType] = Decoder.decodeString.emapTry(x => Try(MarkType.valueOf(x) )) 
given Encoder[MarkType] = Encoder.encodeString.contramap(_.toString())

type ElementUnion = ElementClass | String
given Decoder[ElementUnion] = {
    List[Decoder[ElementUnion]](
        Decoder[ElementClass].widen,
        Decoder[String].widen,
    ).reduceLeft(_ or _)
}

given Encoder[ElementUnion] = Encoder.instance {
    case enc0 : ElementClass => Encoder.AsObject[ElementClass].apply(enc0)
    case enc1 : String => Encoder.encodeString(enc1)
}

case class ElementClass()  derives Encoder.AsObject, Decoder

/**
 * Determines the default event processing and data query for the selection. Vega-Lite
 * currently supports two selection types:
 *
 * - `"point"` -- to select multiple discrete data values; the first value is selected on
 * `click` and additional values toggled on shift-click.
 * - `"interval"` -- to select a continuous range of data values on `drag`.
 */
type Select = SelectionType | SelectionConfig
given Decoder[Select] = {
    List[Decoder[Select]](
        Decoder[SelectionType].widen,
        Decoder[SelectionConfig].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Select] = Encoder.instance {
    case enc0 : SelectionType => summon[Encoder[SelectionType]].apply(enc0)
    case enc1 : SelectionConfig => Encoder.AsObject[SelectionConfig].apply(enc1)
}

case class SelectionConfig (
    /**
     * Clears the selection, emptying it of all values. This property can be a [Event
     * Stream](https://vega.github.io/vega/docs/event-streams/) or `false` to disable clear.
     *
     * __Default value:__ `dblclick`.
     *
     * __See also:__ [`clear` examples
     * ](https://vega.github.io/vega-lite/docs/selection.html#clear) in the documentation.
     */
    val clear : Option[ClearUnion] = None,

    /**
     * An array of encoding channels. The corresponding data field values must match for a data
     * tuple to fall within the selection.
     *
     * __See also:__ The [projection with `encodings` and `fields`
     * section](https://vega.github.io/vega-lite/docs/selection.html#project) in the
     * documentation.
     */
    val encodings : Option[Seq[SingleDefUnitChannel]] = None,

    /**
     * An array of field names whose values must match for a data tuple to fall within the
     * selection.
     *
     * __See also:__ The [projection with `encodings` and `fields`
     * section](https://vega.github.io/vega-lite/docs/selection.html#project) in the
     * documentation.
     */
    val fields : Option[Seq[String]] = None,

    /**
     * When true, an invisible voronoi diagram is computed to accelerate discrete selection. The
     * data value _nearest_ the mouse cursor is added to the selection.
     *
     * __Default value:__ `false`, which means that data values must be interacted with directly
     * (e.g., clicked on) to be added to the selection.
     *
     * __See also:__ [`nearest`
     * examples](https://vega.github.io/vega-lite/docs/selection.html#nearest) documentation.
     */
    val nearest : Option[Boolean] = None,

    /**
     * A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or
     * selector) that triggers the selection. For interval selections, the event stream must
     * specify a [start and
     * end](https://vega.github.io/vega/docs/event-streams/#between-filters).
     *
     * __See also:__ [`on` examples](https://vega.github.io/vega-lite/docs/selection.html#on) in
     * the documentation.
     */
    val on : Option[OnUnion] = None,

    /**
     * With layered and multi-view displays, a strategy that determines how selections' data
     * queries are resolved when applied in a filter transform, conditional encoding rule, or
     * scale domain.
     *
     * One of:
     * - `"global"` -- only one brush exists for the entire SPLOM. When the user begins to drag,
     * any previous brushes are cleared, and a new one is constructed.
     * - `"union"` -- each cell contains its own brush, and points are highlighted if they lie
     * within _any_ of these individual brushes.
     * - `"intersect"` -- each cell contains its own brush, and points are highlighted only if
     * they fall within _all_ of these individual brushes.
     *
     * __Default value:__ `global`.
     *
     * __See also:__ [`resolve`
     * examples](https://vega.github.io/vega-lite/docs/selection.html#resolve) in the
     * documentation.
     */
    val resolve : Option[SelectionResolution] = None,

    /**
     * Controls whether data values should be toggled (inserted or removed from a point
     * selection) or only ever inserted into point selections.
     *
     * One of:
     * - `true` -- the default behavior, which corresponds to `"event.shiftKey"`.  As a result,
     * data values are toggled when the user interacts with the shift-key pressed.
     * - `false` -- disables toggling behaviour; the selection will only ever contain a single
     * data value corresponding to the most recent interaction.
     * - A [Vega expression](https://vega.github.io/vega/docs/expressions/) which is
     * re-evaluated as the user interacts. If the expression evaluates to `true`, the data value
     * is toggled into or out of the point selection. If the expression evaluates to `false`,
     * the point selection is first cleared, and the data value is then inserted. For example,
     * setting the value to the Vega expression `"true"` will toggle data values without the
     * user pressing the shift-key.
     *
     * __Default value:__ `true`
     *
     * __See also:__ [`toggle`
     * examples](https://vega.github.io/vega-lite/docs/selection.html#toggle) in the
     * documentation.
     */
    val toggle : Option[Toggle] = None,

    /**
     * Determines the default event processing and data query for the selection. Vega-Lite
     * currently supports two selection types:
     *
     * - `"point"` -- to select multiple discrete data values; the first value is selected on
     * `click` and additional values toggled on shift-click.
     * - `"interval"` -- to select a continuous range of data values on `drag`.
     */
    val `type` : String,

    /**
     * An interval selection also adds a rectangle mark to depict the extents of the interval.
     * The `mark` property can be used to customize the appearance of the mark.
     *
     * __See also:__ [`mark`
     * examples](https://vega.github.io/vega-lite/docs/selection.html#mark) in the documentation.
     */
    val mark : Option[BrushConfig] = None,

    /**
     * When truthy, allows a user to interactively move an interval selection back-and-forth.
     * Can be `true`, `false` (to disable panning), or a [Vega event stream
     * definition](https://vega.github.io/vega/docs/event-streams/) which must include a start
     * and end event to trigger continuous panning. Discrete panning (e.g., pressing the
     * left/right arrow keys) will be supported in future versions.
     *
     * __Default value:__ `true`, which corresponds to `[mousedown, window:mouseup] >
     * window:mousemove!`. This default allows users to clicks and drags within an interval
     * selection to reposition it.
     *
     * __See also:__ [`translate`
     * examples](https://vega.github.io/vega-lite/docs/selection.html#translate) in the
     * documentation.
     */
    val translate : Option[Toggle] = None,

    /**
     * When truthy, allows a user to interactively resize an interval selection. Can be `true`,
     * `false` (to disable zooming), or a [Vega event stream
     * definition](https://vega.github.io/vega/docs/event-streams/). Currently, only `wheel`
     * events are supported, but custom event streams can still be used to specify filters,
     * debouncing, and throttling. Future versions will expand the set of events that can
     * trigger this transformation.
     *
     * __Default value:__ `true`, which corresponds to `wheel!`. This default allows users to
     * use the mouse wheel to resize an interval selection.
     *
     * __See also:__ [`zoom`
     * examples](https://vega.github.io/vega-lite/docs/selection.html#zoom) in the documentation.
     */
    val zoom : Option[Toggle] = None
) derives Encoder.AsObject, Decoder

type ClearUnion = Boolean | ClearDerivedStream | String
given Decoder[ClearUnion] = {
    List[Decoder[ClearUnion]](
        Decoder[Boolean].widen,
        Decoder[ClearDerivedStream].widen,
        Decoder[String].widen,
    ).reduceLeft(_ or _)
}

given Encoder[ClearUnion] = Encoder.instance {
    case enc0 : Boolean => Encoder.encodeBoolean(enc0)
    case enc1 : ClearDerivedStream => Encoder.AsObject[ClearDerivedStream].apply(enc1)
    case enc2 : String => Encoder.encodeString(enc2)
}

case class ClearDerivedStream (
    val between : Option[Seq[Stream]] = None,
    val consume : Option[Boolean] = None,
    val debounce : Option[Double] = None,
    val filter : Option[Text] = None,
    val markname : Option[String] = None,
    val marktype : Option[MarkType] = None,
    val source : Option[String] = None,
    val throttle : Option[Double] = None,
    val `type` : Option[String] = None,
    val stream : Option[Stream] = None,
    val merge : Option[Seq[Stream]] = None
) derives Encoder.AsObject, Decoder

/**
 * An interval selection also adds a rectangle mark to depict the extents of the interval.
 * The `mark` property can be used to customize the appearance of the mark.
 *
 * __See also:__ [`mark`
 * examples](https://vega.github.io/vega-lite/docs/selection.html#mark) in the documentation.
 */
case class BrushConfig (
    /**
     * The mouse cursor used over the interval mark. Any valid [CSS cursor
     * type](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Values) can be used.
     */
    val cursor : Option[Cursor] = None,

    /**
     * The fill color of the interval mark.
     *
     * __Default value:__ `"#333333"`
     */
    val fill : Option[String] = None,

    /**
     * The fill opacity of the interval mark (a value between `0` and `1`).
     *
     * __Default value:__ `0.125`
     */
    val fillOpacity : Option[Double] = None,

    /**
     * The stroke color of the interval mark.
     *
     * __Default value:__ `"#ffffff"`
     */
    val stroke : Option[String] = None,

    /**
     * An array of alternating stroke and space lengths, for creating dashed or dotted lines.
     */
    val strokeDash : Option[Seq[Double]] = None,

    /**
     * The offset (in pixels) with which to begin drawing the stroke dash array.
     */
    val strokeDashOffset : Option[Double] = None,

    /**
     * The stroke opacity of the interval mark (a value between `0` and `1`).
     */
    val strokeOpacity : Option[Double] = None,

    /**
     * The stroke width of the interval mark.
     */
    val strokeWidth : Option[Double] = None
) derives Encoder.AsObject, Decoder

type OnUnion = OnDerivedStream | String
given Decoder[OnUnion] = {
    List[Decoder[OnUnion]](
        Decoder[OnDerivedStream].widen,
        Decoder[String].widen,
    ).reduceLeft(_ or _)
}

given Encoder[OnUnion] = Encoder.instance {
    case enc0 : OnDerivedStream => Encoder.AsObject[OnDerivedStream].apply(enc0)
    case enc1 : String => Encoder.encodeString(enc1)
}

case class OnDerivedStream (
    val between : Option[Seq[Stream]] = None,
    val consume : Option[Boolean] = None,
    val debounce : Option[Double] = None,
    val filter : Option[Text] = None,
    val markname : Option[String] = None,
    val marktype : Option[MarkType] = None,
    val source : Option[String] = None,
    val throttle : Option[Double] = None,
    val `type` : Option[String] = None,
    val stream : Option[Stream] = None,
    val merge : Option[Seq[Stream]] = None
) derives Encoder.AsObject, Decoder

/**
 * With layered and multi-view displays, a strategy that determines how selections' data
 * queries are resolved when applied in a filter transform, conditional encoding rule, or
 * scale domain.
 *
 * One of:
 * - `"global"` -- only one brush exists for the entire SPLOM. When the user begins to drag,
 * any previous brushes are cleared, and a new one is constructed.
 * - `"union"` -- each cell contains its own brush, and points are highlighted if they lie
 * within _any_ of these individual brushes.
 * - `"intersect"` -- each cell contains its own brush, and points are highlighted only if
 * they fall within _all_ of these individual brushes.
 *
 * __Default value:__ `global`.
 *
 * __See also:__ [`resolve`
 * examples](https://vega.github.io/vega-lite/docs/selection.html#resolve) in the
 * documentation.
 */

enum SelectionResolution : 
    case global
    case intersect
    case union
given Decoder[SelectionResolution] = Decoder.decodeString.emapTry(x => Try(SelectionResolution.valueOf(x) )) 
given Encoder[SelectionResolution] = Encoder.encodeString.contramap(_.toString())

/**
 * Controls whether data values should be toggled (inserted or removed from a point
 * selection) or only ever inserted into point selections.
 *
 * One of:
 * - `true` -- the default behavior, which corresponds to `"event.shiftKey"`.  As a result,
 * data values are toggled when the user interacts with the shift-key pressed.
 * - `false` -- disables toggling behaviour; the selection will only ever contain a single
 * data value corresponding to the most recent interaction.
 * - A [Vega expression](https://vega.github.io/vega/docs/expressions/) which is
 * re-evaluated as the user interacts. If the expression evaluates to `true`, the data value
 * is toggled into or out of the point selection. If the expression evaluates to `false`,
 * the point selection is first cleared, and the data value is then inserted. For example,
 * setting the value to the Vega expression `"true"` will toggle data values without the
 * user pressing the shift-key.
 *
 * __Default value:__ `true`
 *
 * __See also:__ [`toggle`
 * examples](https://vega.github.io/vega-lite/docs/selection.html#toggle) in the
 * documentation.
 *
 * When truthy, allows a user to interactively move an interval selection back-and-forth.
 * Can be `true`, `false` (to disable panning), or a [Vega event stream
 * definition](https://vega.github.io/vega/docs/event-streams/) which must include a start
 * and end event to trigger continuous panning. Discrete panning (e.g., pressing the
 * left/right arrow keys) will be supported in future versions.
 *
 * __Default value:__ `true`, which corresponds to `[mousedown, window:mouseup] >
 * window:mousemove!`. This default allows users to clicks and drags within an interval
 * selection to reposition it.
 *
 * __See also:__ [`translate`
 * examples](https://vega.github.io/vega-lite/docs/selection.html#translate) in the
 * documentation.
 *
 * When truthy, allows a user to interactively resize an interval selection. Can be `true`,
 * `false` (to disable zooming), or a [Vega event stream
 * definition](https://vega.github.io/vega/docs/event-streams/). Currently, only `wheel`
 * events are supported, but custom event streams can still be used to specify filters,
 * debouncing, and throttling. Future versions will expand the set of events that can
 * trigger this transformation.
 *
 * __Default value:__ `true`, which corresponds to `wheel!`. This default allows users to
 * use the mouse wheel to resize an interval selection.
 *
 * __See also:__ [`zoom`
 * examples](https://vega.github.io/vega-lite/docs/selection.html#zoom) in the documentation.
 */
type Toggle = Boolean | String
given Decoder[Toggle] = {
    List[Decoder[Toggle]](
        Decoder[Boolean].widen,
        Decoder[String].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Toggle] = Encoder.instance {
    case enc0 : Boolean => Encoder.encodeBoolean(enc0)
    case enc1 : String => Encoder.encodeString(enc1)
}

enum SelectionType : 
    case interval
    case point
given Decoder[SelectionType] = Decoder.decodeString.emapTry(x => Try(SelectionType.valueOf(x) )) 
given Encoder[SelectionType] = Encoder.encodeString.contramap(_.toString())

type ParamValue = Boolean | Double | String | Seq[Map[String, SelectionInit]] | Map[String, DateTimeValue] | NullValue
given Decoder[ParamValue] = {
    List[Decoder[ParamValue]](
        Decoder[Boolean].widen,
        Decoder[Double].widen,
        Decoder[String].widen,
        Decoder[Seq[Map[String, SelectionInit]]].widen,
        Decoder[Map[String, DateTimeValue]].widen,
        Decoder[NullValue].widen,
    ).reduceLeft(_ or _)
}

given Encoder[ParamValue] = Encoder.instance {
    case enc0 : Boolean => Encoder.encodeBoolean(enc0)
    case enc1 : Double => Encoder.encodeDouble(enc1)
    case enc2 : String => Encoder.encodeString(enc2)
    case enc3 : Seq[Map[String, SelectionInit]] => Encoder.encodeSeq[Map[String, SelectionInit]].apply(enc3)
    case enc4 : Map[String, DateTimeValue] => Encoder.encodeMap[String,DateTimeValue].apply(enc4)
    case enc5 : NullValue => Encoder.encodeNone(enc5)
}

type SelectionInit = Boolean | DateTime | Double | String | NullValue
given Decoder[SelectionInit] = {
    List[Decoder[SelectionInit]](
        Decoder[Boolean].widen,
        Decoder[DateTime].widen,
        Decoder[Double].widen,
        Decoder[String].widen,
        Decoder[NullValue].widen,
    ).reduceLeft(_ or _)
}

given Encoder[SelectionInit] = Encoder.instance {
    case enc0 : Boolean => Encoder.encodeBoolean(enc0)
    case enc1 : DateTime => Encoder.AsObject[DateTime].apply(enc1)
    case enc2 : Double => Encoder.encodeDouble(enc2)
    case enc3 : String => Encoder.encodeString(enc3)
    case enc4 : NullValue => Encoder.encodeNone(enc4)
}

type DateTimeValue = Boolean | Double | String | Seq[SelectionInitInterval]
given Decoder[DateTimeValue] = {
    List[Decoder[DateTimeValue]](
        Decoder[Boolean].widen,
        Decoder[Double].widen,
        Decoder[String].widen,
        Decoder[Seq[SelectionInitInterval]].widen,
    ).reduceLeft(_ or _)
}

given Encoder[DateTimeValue] = Encoder.instance {
    case enc0 : Boolean => Encoder.encodeBoolean(enc0)
    case enc1 : Double => Encoder.encodeDouble(enc1)
    case enc2 : String => Encoder.encodeString(enc2)
    case enc3 : Seq[SelectionInitInterval] => Encoder.encodeSeq[SelectionInitInterval].apply(enc3)
}

/**
 * Projection configuration, which determines default properties for all
 * [projections](https://vega.github.io/vega-lite/docs/projection.html). For a full list of
 * projection configuration options, please see the [corresponding section of the projection
 * documentation](https://vega.github.io/vega-lite/docs/projection.html#config).
 *
 * Any property of Projection can be in config
 *
 * An object defining properties of geographic projection, which will be applied to `shape`
 * path for `"geoshape"` marks and to `latitude` and `"longitude"` channels for other
 * marks.
 *
 * An object defining properties of the geographic projection shared by underlying layers.
 */
case class Projection (
    val center : Option[StrokeDash] = None,
    val clipAngle : Option[CornerRadius] = None,
    val clipExtent : Option[ClipExtentUnion] = None,
    val coefficient : Option[CornerRadius] = None,
    val distance : Option[CornerRadius] = None,
    val extent : Option[ClipExtentUnion] = None,
    val fit : Option[Fit] = None,
    val fraction : Option[CornerRadius] = None,
    val lobes : Option[CornerRadius] = None,
    val parallel : Option[CornerRadius] = None,
    val parallels : Option[StrokeDash] = None,
    val pointRadius : Option[CornerRadius] = None,
    val precision : Option[CornerRadius] = None,
    val radius : Option[CornerRadius] = None,
    val ratio : Option[CornerRadius] = None,
    val reflectX : Option[Aria] = None,
    val reflectY : Option[Aria] = None,
    val rotate : Option[StrokeDash] = None,

    /**
     * The projection’s scale (zoom) factor, overriding automatic fitting. The default scale is
     * projection-specific. The scale factor corresponds linearly to the distance between
     * projected points; however, scale factor values are not equivalent across projections.
     */
    val scale : Option[CornerRadius] = None,

    val size : Option[StrokeDash] = None,
    val spacing : Option[CornerRadius] = None,
    val tilt : Option[CornerRadius] = None,

    /**
     * The projection’s translation offset as a two-element array `[tx, ty]`.
     */
    val translate : Option[StrokeDash] = None,

    /**
     * The cartographic projection to use. This value is case-insensitive, for example
     * `"albers"` and `"Albers"` indicate the same projection type. You can find all valid
     * projection types [in the
     * documentation](https://vega.github.io/vega-lite/docs/projection.html#projection-types).
     *
     * __Default value:__ `equalEarth`
     */
    val `type` : Option[TypeUnion] = None
) derives Encoder.AsObject, Decoder

type ClipExtentUnion = BackgroundExprRef | Seq[Seq[Double]]
given Decoder[ClipExtentUnion] = {
    List[Decoder[ClipExtentUnion]](
        Decoder[BackgroundExprRef].widen,
        Decoder[Seq[Seq[Double]]].widen,
    ).reduceLeft(_ or _)
}

given Encoder[ClipExtentUnion] = Encoder.instance {
    case enc0 : BackgroundExprRef => Encoder.AsObject[BackgroundExprRef].apply(enc0)
    case enc1 : Seq[Seq[Double]] => Encoder.encodeSeq[Seq[Double]].apply(enc1)
}

type Fit = Seq[Option[Json]] | BackgroundExprRef
given Decoder[Fit] = {
    List[Decoder[Fit]](
        Decoder[Seq[Option[Json]]].widen,
        Decoder[BackgroundExprRef].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Fit] = Encoder.instance {
    case enc0 : Seq[Option[Json]] => Encoder.encodeSeq[Option[Json]].apply(enc0)
    case enc1 : BackgroundExprRef => Encoder.AsObject[BackgroundExprRef].apply(enc1)
}

/**
 * The cartographic projection to use. This value is case-insensitive, for example
 * `"albers"` and `"Albers"` indicate the same projection type. You can find all valid
 * projection types [in the
 * documentation](https://vega.github.io/vega-lite/docs/projection.html#projection-types).
 *
 * __Default value:__ `equalEarth`
 */
type TypeUnion = BackgroundExprRef | ProjectionType
given Decoder[TypeUnion] = {
    List[Decoder[TypeUnion]](
        Decoder[BackgroundExprRef].widen,
        Decoder[ProjectionType].widen,
    ).reduceLeft(_ or _)
}

given Encoder[TypeUnion] = Encoder.instance {
    case enc0 : BackgroundExprRef => Encoder.AsObject[BackgroundExprRef].apply(enc0)
    case enc1 : ProjectionType => summon[Encoder[ProjectionType]].apply(enc1)
}

enum ProjectionType : 
    case albers
    case albersUsa
    case azimuthalEqualArea
    case azimuthalEquidistant
    case conicConformal
    case conicEqualArea
    case conicEquidistant
    case equalEarth
    case equirectangular
    case gnomonic
    case identity
    case mercator
    case naturalEarth1
    case orthographic
    case stereographic
    case transverseMercator
given Decoder[ProjectionType] = Decoder.decodeString.emapTry(x => Try(ProjectionType.valueOf(x) )) 
given Encoder[ProjectionType] = Encoder.encodeString.contramap(_.toString())

/**
 * Scale, axis, and legend resolutions for view composition specifications.
 *
 * Defines how scales, axes, and legends from different specs should be combined. Resolve is
 * a mapping from `scale`, `axis`, and `legend` to a mapping from channels to resolutions.
 * Scales and guides can be resolved to be `"independent"` or `"shared"`.
 */
case class Resolve (
    val axis : Option[AxisResolveMap] = None,
    val legend : Option[LegendResolveMap] = None,
    val scale : Option[ScaleResolveMap] = None
) derives Encoder.AsObject, Decoder

case class AxisResolveMap (
    val x : Option[ResolveMode] = None,
    val y : Option[ResolveMode] = None
) derives Encoder.AsObject, Decoder

enum ResolveMode : 
    case independent
    case shared
given Decoder[ResolveMode] = Decoder.decodeString.emapTry(x => Try(ResolveMode.valueOf(x) )) 
given Encoder[ResolveMode] = Encoder.encodeString.contramap(_.toString())

case class LegendResolveMap (
    val angle : Option[ResolveMode] = None,
    val color : Option[ResolveMode] = None,
    val fill : Option[ResolveMode] = None,
    val fillOpacity : Option[ResolveMode] = None,
    val opacity : Option[ResolveMode] = None,
    val shape : Option[ResolveMode] = None,
    val size : Option[ResolveMode] = None,
    val stroke : Option[ResolveMode] = None,
    val strokeDash : Option[ResolveMode] = None,
    val strokeOpacity : Option[ResolveMode] = None,
    val strokeWidth : Option[ResolveMode] = None
) derives Encoder.AsObject, Decoder

case class ScaleResolveMap (
    val angle : Option[ResolveMode] = None,
    val color : Option[ResolveMode] = None,
    val fill : Option[ResolveMode] = None,
    val fillOpacity : Option[ResolveMode] = None,
    val opacity : Option[ResolveMode] = None,
    val radius : Option[ResolveMode] = None,
    val shape : Option[ResolveMode] = None,
    val size : Option[ResolveMode] = None,
    val stroke : Option[ResolveMode] = None,
    val strokeDash : Option[ResolveMode] = None,
    val strokeOpacity : Option[ResolveMode] = None,
    val strokeWidth : Option[ResolveMode] = None,
    val theta : Option[ResolveMode] = None,
    val x : Option[ResolveMode] = None,
    val xOffset : Option[ResolveMode] = None,
    val y : Option[ResolveMode] = None,
    val yOffset : Option[ResolveMode] = None
) derives Encoder.AsObject, Decoder

/**
 * Title for the plot.
 */
type LayerTitle = Seq[String] | String | TitleParams
given Decoder[LayerTitle] = {
    List[Decoder[LayerTitle]](
        Decoder[Seq[String]].widen,
        Decoder[String].widen,
        Decoder[TitleParams].widen,
    ).reduceLeft(_ or _)
}

given Encoder[LayerTitle] = Encoder.instance {
    case enc0 : Seq[String] => Encoder.encodeSeq[String].apply(enc0)
    case enc1 : String => Encoder.encodeString(enc1)
    case enc2 : TitleParams => Encoder.AsObject[TitleParams].apply(enc2)
}

case class TitleParams (
    /**
     * Horizontal text alignment for title text. One of `"left"`, `"center"`, or `"right"`.
     */
    val align : Option[Align] = None,

    /**
     * The anchor position for placing the title. One of `"start"`, `"middle"`, or `"end"`. For
     * example, with an orientation of top these anchor positions map to a left-, center-, or
     * right-aligned title.
     *
     * __Default value:__ `"middle"` for
     * [single](https://vega.github.io/vega-lite/docs/spec.html) and
     * [layered](https://vega.github.io/vega-lite/docs/layer.html) views. `"start"` for other
     * composite views.
     *
     * __Note:__ [For now](https://github.com/vega/vega-lite/issues/2875), `anchor` is only
     * customizable only for [single](https://vega.github.io/vega-lite/docs/spec.html) and
     * [layered](https://vega.github.io/vega-lite/docs/layer.html) views. For other composite
     * views, `anchor` is always `"start"`.
     */
    val anchor : Option[TitleAnchorEnum] = None,

    val angle : Option[CornerRadius] = None,
    val aria : Option[Aria] = None,

    /**
     * Vertical text baseline for title and subtitle text. One of `"alphabetic"` (default),
     * `"top"`, `"middle"`, `"bottom"`, `"line-top"`, or `"line-bottom"`. The `"line-top"` and
     * `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated
     * relative to the *lineHeight* rather than *fontSize* alone.
     */
    val baseline : Option[String] = None,

    val color : Option[Color] = None,
    val dx : Option[CornerRadius] = None,
    val dy : Option[CornerRadius] = None,
    val font : Option[BackgroundUnion] = None,
    val fontSize : Option[FontSize] = None,
    val fontStyle : Option[BackgroundUnion] = None,
    val fontWeight : Option[FontWeightUnion] = None,
    val frame : Option[BackgroundUnion] = None,
    val limit : Option[FontSize] = None,
    val lineHeight : Option[CornerRadius] = None,
    val offset : Option[CornerRadius] = None,
    val orient : Option[TitleParamsOrient] = None,

    /**
     * A [mark style property](https://vega.github.io/vega-lite/docs/config.html#style) to apply
     * to the title text mark.
     *
     * __Default value:__ `"group-title"`.
     */
    val style : Option[Text] = None,

    /**
     * The subtitle Text.
     */
    val subtitle : Option[Text] = None,

    val subtitleColor : Option[Color] = None,
    val subtitleFont : Option[BackgroundUnion] = None,
    val subtitleFontSize : Option[FontSize] = None,
    val subtitleFontStyle : Option[BackgroundUnion] = None,
    val subtitleFontWeight : Option[FontWeightUnion] = None,
    val subtitleLineHeight : Option[CornerRadius] = None,
    val subtitlePadding : Option[CornerRadius] = None,

    /**
     * The title text.
     */
    val text : TextUnion,

    /**
     * The integer z-index indicating the layering of the title group relative to other axis,
     * mark and legend groups.
     *
     * __Default value:__ `0`.
     */
    val zindex : Option[Double] = None
) derives Encoder.AsObject, Decoder

type TitleParamsOrient = BackgroundExprRef | TitleOrient
given Decoder[TitleParamsOrient] = {
    List[Decoder[TitleParamsOrient]](
        Decoder[BackgroundExprRef].widen,
        Decoder[TitleOrient].widen,
    ).reduceLeft(_ or _)
}

given Encoder[TitleParamsOrient] = Encoder.instance {
    case enc0 : BackgroundExprRef => Encoder.AsObject[BackgroundExprRef].apply(enc0)
    case enc1 : TitleOrient => summon[Encoder[TitleOrient]].apply(enc1)
}

/**
 * Default title orientation (`"top"`, `"bottom"`, `"left"`, or `"right"`)
 */

enum TitleOrient : 
    case bottom
    case left
    case none
    case right
    case top
given Decoder[TitleOrient] = Decoder.decodeString.emapTry(x => Try(TitleOrient.valueOf(x) )) 
given Encoder[TitleOrient] = Encoder.encodeString.contramap(_.toString())

case class Transform (
    /**
     * Array of objects that define fields to aggregate.
     */
    val aggregate : Option[Seq[AggregatedFieldDef]] = None,

    /**
     * The data fields to group by. If not specified, a single group containing all data objects
     * will be used.
     *
     * An optional array of fields by which to group the values. Imputation will then be
     * performed on a per-group basis.
     *
     * The data fields for partitioning the data objects into separate groups. If unspecified,
     * all data points will be in a single group.
     *
     * The data fields to group by.
     *
     * The data fields for partitioning the data objects into separate windows. If unspecified,
     * all data points will be in a single window.
     *
     * The optional data fields to group by. If not specified, a single group containing all
     * data objects will be used.
     */
    val groupby : Option[Seq[String]] = None,

    /**
     * The output fields at which to write the start and end bin values. This can be either a
     * string or an array of strings with two elements denoting the name for the fields for bin
     * start and bin end respectively. If a single string (e.g., `"val"`) is provided, the end
     * field will be `"val_end"`.
     *
     * The field for storing the computed formula value.
     *
     * The output fields for the sample value and corresponding density estimate.
     *
     * __Default value:__ `["value", "density"]`
     *
     * The output field names for extracted array values.
     *
     * __Default value:__ The field name of the corresponding array field
     *
     * The output field names for the key and value properties produced by the fold transform.
     * __Default value:__ `["key", "value"]`
     *
     * The output field names for the smoothed points generated by the loess transform.
     *
     * __Default value:__ The field names of the input x and y values.
     *
     * The output fields on which to store the looked up data values.
     *
     * For data lookups, this property may be left blank if `from.fields` has been specified
     * (those field names will be used); if `from.fields` has not been specified, `as` must be a
     * string.
     *
     * For selection lookups, this property is optional: if unspecified, looked up values will
     * be stored under a property named for the selection; and if specified, it must correspond
     * to `from.fields`.
     *
     * The output field names for the probability and quantile values.
     *
     * __Default value:__ `["prob", "value"]`
     *
     * The output field names for the smoothed points generated by the regression transform.
     *
     * __Default value:__ The field names of the input x and y values.
     *
     * The output field to write the timeUnit value.
     *
     * Output field names. This can be either a string or an array of strings with two elements
     * denoting the name for the fields for stack start and stack end respectively. If a single
     * string(e.g., `"val"`) is provided, the end field will be `"val_end"`.
     */
    val as : Option[Text] = None,

    /**
     * An object indicating bin properties, or simply `true` for using default bin parameters.
     */
    val bin : Option[TransformBin] = None,

    /**
     * The data field to bin.
     *
     * The data field to apply time unit.
     */
    val field : Option[String] = None,

    /**
     * A [expression](https://vega.github.io/vega-lite/docs/types.html#expression) string. Use
     * the variable `datum` to refer to the current data object.
     */
    val calculate : Option[String] = None,

    /**
     * The bandwidth (standard deviation) of the Gaussian kernel. If unspecified or set to zero,
     * the bandwidth value is automatically estimated from the input data using Scott’s rule.
     *
     * A bandwidth parameter in the range `[0, 1]` that determines the amount of smoothing.
     *
     * __Default value:__ `0.3`
     */
    val bandwidth : Option[Double] = None,

    /**
     * A boolean flag indicating if the output values should be probability estimates (false) or
     * smoothed counts (true).
     *
     * __Default value:__ `false`
     */
    val counts : Option[Boolean] = None,

    /**
     * A boolean flag indicating whether to produce density estimates (false) or cumulative
     * density estimates (true).
     *
     * __Default value:__ `false`
     */
    val cumulative : Option[Boolean] = None,

    /**
     * The data field for which to perform density estimation.
     */
    val density : Option[String] = None,

    /**
     * A [min, max] domain from which to sample the distribution. If unspecified, the extent
     * will be determined by the observed minimum and maximum values of the density value
     * field.
     *
     * A [min, max] domain over the independent (x) field for the starting and ending points of
     * the generated trend line.
     */
    val extent : Option[Seq[Double]] = None,

    /**
     * The maximum number of samples to take along the extent domain for plotting the density.
     *
     * __Default value:__ `200`
     */
    val maxsteps : Option[Double] = None,

    /**
     * The minimum number of samples to take along the extent domain for plotting the density.
     *
     * __Default value:__ `25`
     */
    val minsteps : Option[Double] = None,

    /**
     * The exact number of samples to take along the extent domain for plotting the density. If
     * specified, overrides both minsteps and maxsteps to set an exact number of uniform
     * samples. Potentially useful in conjunction with a fixed extent to ensure consistent
     * sample points for stacked densities.
     */
    val steps : Option[Double] = None,

    /**
     * The `filter` property must be a predication definition, which can take one of the
     * following forms:
     *
     * 1) an [expression](https://vega.github.io/vega-lite/docs/types.html#expression) string,
     * where `datum` can be used to refer to the current data object. For example, `{filter:
     * "datum.b2 > 60"}` would make the output data includes only items that have values in the
     * field `b2` over 60.
     *
     * 2) one of the [field
     * predicates](https://vega.github.io/vega-lite/docs/predicate.html#field-predicate):
     * [`equal`](https://vega.github.io/vega-lite/docs/predicate.html#field-equal-predicate),
     * [`lt`](https://vega.github.io/vega-lite/docs/predicate.html#lt-predicate),
     * [`lte`](https://vega.github.io/vega-lite/docs/predicate.html#lte-predicate),
     * [`gt`](https://vega.github.io/vega-lite/docs/predicate.html#gt-predicate),
     * [`gte`](https://vega.github.io/vega-lite/docs/predicate.html#gte-predicate),
     * [`range`](https://vega.github.io/vega-lite/docs/predicate.html#range-predicate),
     * [`oneOf`](https://vega.github.io/vega-lite/docs/predicate.html#one-of-predicate), or
     * [`valid`](https://vega.github.io/vega-lite/docs/predicate.html#valid-predicate),
     *
     * 3) a [selection
     * predicate](https://vega.github.io/vega-lite/docs/predicate.html#selection-predicate),
     * which define the names of a selection that the data point should belong to (or a logical
     * composition of selections).
     *
     * 4) a [logical
     * composition](https://vega.github.io/vega-lite/docs/predicate.html#composition) of (1),
     * (2), or (3).
     */
    val filter : Option[PredicateComposition] = None,

    /**
     * An array of one or more data fields containing arrays to flatten. If multiple fields are
     * specified, their array values should have a parallel structure, ideally with the same
     * length. If the lengths of parallel arrays do not match, the longest array will be used
     * with `null` values added for missing entries.
     */
    val flatten : Option[Seq[String]] = None,

    /**
     * An array of data fields indicating the properties to fold.
     */
    val fold : Option[Seq[String]] = None,

    /**
     * A frame specification as a two-element array used to control the window over which the
     * specified method is applied. The array entries should either be a number indicating the
     * offset from the current data object, or null to indicate unbounded rows preceding or
     * following the current data object. For example, the value `[-5, 5]` indicates that the
     * window should include five objects preceding and five objects following the current
     * object.
     *
     * __Default value:__:  `[null, null]` indicating that the window includes all objects.
     *
     * A frame specification as a two-element array indicating how the sliding window should
     * proceed. The array entries should either be a number indicating the offset from the
     * current data object, or null to indicate unbounded rows preceding or following the
     * current data object. The default value is `[null, 0]`, indicating that the sliding window
     * includes the current object and all preceding objects. The value `[-5, 5]` indicates that
     * the window should include five objects preceding and five objects following the current
     * object. Finally, `[null, null]` indicates that the window frame should always include all
     * data objects. If you this frame and want to assign the same value to add objects, you can
     * use the simpler [join aggregate
     * transform](https://vega.github.io/vega-lite/docs/joinaggregate.html). The only operators
     * affected are the aggregation operations and the `first_value`, `last_value`, and
     * `nth_value` window operations. The other window operations are not affected by this.
     *
     * __Default value:__:  `[null, 0]` (includes the current object and all preceding objects)
     */
    val frame : Option[Seq[Option[Double]]] = None,

    /**
     * The data field for which the missing values should be imputed.
     */
    val impute : Option[String] = None,

    /**
     * A key field that uniquely identifies data objects within a group. Missing key values
     * (those occurring in the data but not in the current group) will be imputed.
     */
    val key : Option[String] = None,

    /**
     * Defines the key values that should be considered for imputation. An array of key values
     * or an object defining a [number
     * sequence](https://vega.github.io/vega-lite/docs/impute.html#sequence-def).
     *
     * If provided, this will be used in addition to the key values observed within the input
     * data. If not provided, the values will be derived from all unique values of the `key`
     * field. For `impute` in `encoding`, the key field is the x-field if the y-field is
     * imputed, or vice versa.
     *
     * If there is no impute grouping, this property _must_ be specified.
     */
    val keyvals : Option[Keyvals] = None,

    /**
     * The imputation method to use for the field value of imputed data objects. One of
     * `"value"`, `"mean"`, `"median"`, `"max"` or `"min"`.
     *
     * __Default value:__  `"value"`
     *
     * The functional form of the regression model. One of `"linear"`, `"log"`, `"exp"`,
     * `"pow"`, `"quad"`, or `"poly"`.
     *
     * __Default value:__ `"linear"`
     */
    val method : Option[TransformMethod] = None,

    /**
     * The field value to use when the imputation `method` is `"value"`.
     *
     * The data field to populate pivoted fields. The aggregate values of this field become the
     * values of the new pivoted fields.
     */
    val value : Option[Json] = None,

    /**
     * The definition of the fields in the join aggregate, and what calculations to use.
     */
    val joinaggregate : Option[Seq[JoinAggregateFieldDef]] = None,

    /**
     * The data field of the dependent variable to smooth.
     */
    val loess : Option[String] = None,

    /**
     * The data field of the independent variable to use a predictor.
     */
    val on : Option[String] = None,

    /**
     * The default value to use if lookup fails.
     *
     * __Default value:__ `null`
     */
    val default : Option[Json] = None,

    /**
     * Data source or selection for secondary data reference.
     */
    val from : Option[Lookup] = None,

    /**
     * Key in primary data source.
     */
    val lookup : Option[String] = None,

    /**
     * An array of probabilities in the range (0, 1) for which to compute quantile values. If
     * not specified, the *step* parameter will be used.
     */
    val probs : Option[Seq[Double]] = None,

    /**
     * The data field for which to perform quantile estimation.
     */
    val quantile : Option[String] = None,

    /**
     * A probability step size (default 0.01) for sampling quantile values. All values from
     * one-half the step size up to 1 (exclusive) will be sampled. This parameter is only used
     * if the *probs* parameter is not provided.
     */
    val step : Option[Double] = None,

    /**
     * The polynomial order (number of coefficients) for the 'poly' method.
     *
     * __Default value:__ `3`
     */
    val order : Option[Double] = None,

    /**
     * A boolean flag indicating if the transform should return the regression model parameters
     * (one object per group), rather than trend line points. The resulting objects include a
     * `coef` array of fitted coefficient values (starting with the intercept term and then
     * including terms of increasing order) and an `rSquared` value (indicating the total
     * variance explained by the model).
     *
     * __Default value:__ `false`
     */
    val params : Option[Boolean] = None,

    /**
     * The data field of the dependent variable to predict.
     */
    val regression : Option[String] = None,

    /**
     * The timeUnit.
     */
    val timeUnit : Option[TimeUnitUnion] = None,

    /**
     * The maximum number of data objects to include in the sample.
     *
     * __Default value:__ `1000`
     */
    val sample : Option[Double] = None,

    /**
     * Mode for stacking marks. One of `"zero"` (default), `"center"`, or `"normalize"`. The
     * `"zero"` offset will stack starting at `0`. The `"center"` offset will center the stacks.
     * The `"normalize"` offset will compute percentage values for each stack point, with output
     * values in the range `[0,1]`.
     *
     * __Default value:__ `"zero"`
     */
    val offset : Option[StackOffset] = None,

    /**
     * Field that determines the order of leaves in the stacked charts.
     *
     * A sort field definition for sorting data objects within a window. If two data objects are
     * considered equal by the comparator, they are considered "peer" values of equal rank. If
     * sort is not specified, the order is undefined: data objects are processed in the order
     * they are observed and none are considered peers (the ignorePeers parameter is ignored and
     * treated as if set to `true`).
     */
    val sort : Option[Seq[SortField]] = None,

    /**
     * The field which is stacked.
     */
    val stack : Option[String] = None,

    /**
     * Indicates if the sliding window frame should ignore peer values (data that are considered
     * identical by the sort criteria). The default is false, causing the window frame to expand
     * to include all peer values. If set to true, the window frame will be defined by offset
     * values only. This setting only affects those operations that depend on the window frame,
     * namely aggregation operations and the first_value, last_value, and nth_value window
     * operations.
     *
     * __Default value:__ `false`
     */
    val ignorePeers : Option[Boolean] = None,

    /**
     * The definition of the fields in the window, and what calculations to use.
     */
    val window : Option[Seq[WindowFieldDef]] = None,

    /**
     * An optional parameter indicating the maximum number of pivoted fields to generate. The
     * default (`0`) applies no limit. The pivoted `pivot` names are sorted in ascending order
     * prior to enforcing the limit. __Default value:__ `0`
     */
    val limit : Option[Double] = None,

    /**
     * The aggregation operation to apply to grouped `value` field values. __Default value:__
     * `sum`
     */
    val op : Option[AggregateOp] = None,

    /**
     * The data field to pivot on. The unique values of this field become new field names in the
     * output stream.
     */
    val pivot : Option[String] = None
) derives Encoder.AsObject, Decoder

case class AggregatedFieldDef (
    /**
     * The output field names to use for each aggregated field.
     */
    val as : String,

    /**
     * The data field for which to compute aggregate function. This is required for all
     * aggregation operations except `"count"`.
     */
    val field : Option[String] = None,

    /**
     * The aggregation operation to apply to the fields (e.g., `"sum"`, `"average"`, or
     * `"count"`). See the [full list of supported aggregation
     * operations](https://vega.github.io/vega-lite/docs/aggregate.html#ops) for more
     * information.
     */
    val op : AggregateOp
) derives Encoder.AsObject, Decoder

/**
 * The aggregation operation to apply to the fields (e.g., `"sum"`, `"average"`, or
 * `"count"`). See the [full list of supported aggregation
 * operations](https://vega.github.io/vega-lite/docs/aggregate.html#ops) for more
 * information.
 *
 * The aggregation operation to apply (e.g., `"sum"`, `"average"` or `"count"`). See the
 * list of all supported operations
 * [here](https://vega.github.io/vega-lite/docs/aggregate.html#ops).
 *
 * The aggregation operation to apply to grouped `value` field values. __Default value:__
 * `sum`
 */

enum AggregateOp : 
    case argmax
    case argmin
    case average
    case ci0
    case ci1
    case count
    case distinct
    case max
    case mean
    case median
    case min
    case missing
    case product
    case q1
    case q3
    case stderr
    case stdev
    case stdevp
    case sum
    case valid
    //case `values`
    case variance
    case variancep
given Decoder[AggregateOp] = Decoder.decodeString.emapTry(x => Try(AggregateOp.valueOf(x) )) 
given Encoder[AggregateOp] = Encoder.encodeString.contramap(_.toString())

/**
 * An object indicating bin properties, or simply `true` for using default bin parameters.
 */
type TransformBin = BinParams | Boolean
given Decoder[TransformBin] = {
    List[Decoder[TransformBin]](
        Decoder[BinParams].widen,
        Decoder[Boolean].widen,
    ).reduceLeft(_ or _)
}

given Encoder[TransformBin] = Encoder.instance {
    case enc0 : BinParams => Encoder.AsObject[BinParams].apply(enc0)
    case enc1 : Boolean => Encoder.encodeBoolean(enc1)
}

/**
 * Data source or selection for secondary data reference.
 */
case class Lookup (
    /**
     * Secondary data source to lookup in.
     */
    val data : Option[Data] = None,

    /**
     * Fields in foreign data or selection to lookup. If not specified, the entire object is
     * queried.
     */
    val fields : Option[Seq[String]] = None,

    /**
     * Key in data to lookup.
     */
    val key : String,

    /**
     * Selection parameter name to look up.
     */
    val param : Option[String] = None
) derives Encoder.AsObject, Decoder

/**
 * Secondary data source to lookup in.
 */
case class Data (
    /**
     * An object that specifies the format for parsing the data.
     */
    val format : Option[DataFormat] = None,

    /**
     * Provide a placeholder name and bind data at runtime.
     *
     * Provide a placeholder name and bind data at runtime.
     *
     * New data may change the layout but Vega does not always resize the chart. To update the
     * layout when the data updates, set
     * [autosize](https://vega.github.io/vega-lite/docs/size.html#autosize) or explicitly use
     * [view.resize](https://vega.github.io/vega/docs/api/view/#view_resize).
     */
    val name : Option[String] = None,

    /**
     * An URL from which to load the data set. Use the `format.type` property to ensure the
     * loaded data is correctly parsed.
     */
    val url : Option[String] = None,

    /**
     * The full data set, included inline. This can be an array of objects or primitive values,
     * an object, or a string. Arrays of primitive values are ingested as objects with a `data`
     * property. Strings are parsed according to the specified format type.
     */
    val values : Option[InlineDataset] = None,

    /**
     * Generate a sequence of numbers.
     */
    val sequence : Option[SequenceParams] = None,

    /**
     * Generate sphere GeoJSON data for the full globe.
     */
    val sphere : Option[SphereUnion] = None,

    /**
     * Generate graticule GeoJSON data for geographic reference lines.
     */
    val graticule : Option[Graticule] = None
) derives Encoder.AsObject, Decoder

case class JoinAggregateFieldDef (
    /**
     * The output name for the join aggregate operation.
     */
    val as : String,

    /**
     * The data field for which to compute the aggregate function. This can be omitted for
     * functions that do not operate over a field such as `"count"`.
     */
    val field : Option[String] = None,

    /**
     * The aggregation operation to apply (e.g., `"sum"`, `"average"` or `"count"`). See the
     * list of all supported operations
     * [here](https://vega.github.io/vega-lite/docs/aggregate.html#ops).
     */
    val op : AggregateOp
) derives Encoder.AsObject, Decoder

/**
 * The imputation method to use for the field value of imputed data objects. One of
 * `"value"`, `"mean"`, `"median"`, `"max"` or `"min"`.
 *
 * __Default value:__  `"value"`
 *
 * The functional form of the regression model. One of `"linear"`, `"log"`, `"exp"`,
 * `"pow"`, `"quad"`, or `"poly"`.
 *
 * __Default value:__ `"linear"`
 */

enum TransformMethod : 
    case exp
    case linear
    case log
    case max
    case mean
    case median
    case min
    case poly
    case pow
    case quad
    case value
given Decoder[TransformMethod] = Decoder.decodeString.emapTry(x => Try(TransformMethod.valueOf(x) )) 
given Encoder[TransformMethod] = Encoder.encodeString.contramap(_.toString())

/**
 * A sort definition for transform
 */
case class SortField (
    /**
     * The name of the field to sort.
     */
    val field : String,

    /**
     * Whether to sort the field in ascending or descending order. One of `"ascending"`
     * (default), `"descending"`, or `null` (no not sort).
     */
    val order : Option[SortOrder] = None
) derives Encoder.AsObject, Decoder

case class WindowFieldDef (
    /**
     * The output name for the window operation.
     */
    val as : String,

    /**
     * The data field for which to compute the aggregate or window function. This can be omitted
     * for window functions that do not operate over a field such as `"count"`, `"rank"`,
     * `"dense_rank"`.
     */
    val field : Option[String] = None,

    /**
     * The window or aggregation operation to apply within a window (e.g., `"rank"`, `"lead"`,
     * `"sum"`, `"average"` or `"count"`). See the list of all supported operations
     * [here](https://vega.github.io/vega-lite/docs/window.html#ops).
     */
    val op : Op,

    /**
     * Parameter values for the window functions. Parameter values can be omitted for operations
     * that do not accept a parameter.
     *
     * See the list of all supported operations and their parameters
     * [here](https://vega.github.io/vega-lite/docs/transforms/window.html).
     */
    val param : Option[Double] = None
) derives Encoder.AsObject, Decoder

/**
 * The window or aggregation operation to apply within a window (e.g., `"rank"`, `"lead"`,
 * `"sum"`, `"average"` or `"count"`). See the list of all supported operations
 * [here](https://vega.github.io/vega-lite/docs/window.html#ops).
 *
 * The aggregation operation to apply to the fields (e.g., `"sum"`, `"average"`, or
 * `"count"`). See the [full list of supported aggregation
 * operations](https://vega.github.io/vega-lite/docs/aggregate.html#ops) for more
 * information.
 *
 * The aggregation operation to apply (e.g., `"sum"`, `"average"` or `"count"`). See the
 * list of all supported operations
 * [here](https://vega.github.io/vega-lite/docs/aggregate.html#ops).
 *
 * The aggregation operation to apply to grouped `value` field values. __Default value:__
 * `sum`
 */

enum Op : 
    case argmax
    case argmin
    case average
    case ci0
    case ci1
    case count
    case cume_dist
    case dense_rank
    case distinct
    case first_value
    case lag
    case last_value
    case lead
    case max
    case mean
    case median
    case min
    case missing
    case nth_value
    case ntile
    case percent_rank
    case product
    case q1
    case q3
    case rank
    case row_number
    case stderr
    case stdev
    case stdevp
    case sum
    case valid
    //case `values`
    case variance
    case variancep
given Decoder[Op] = Decoder.decodeString.emapTry(x => Try(Op.valueOf(x) )) 
given Encoder[Op] = Encoder.encodeString.contramap(_.toString())

/**
 * An object defining the view background's fill and stroke.
 *
 * __Default value:__ none (transparent)
 */
case class ViewBackground (
    val cornerRadius : Option[CornerRadius] = None,

    /**
     * The mouse cursor used over the view. Any valid [CSS cursor
     * type](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Values) can be used.
     */
    val cursor : Option[Cursor] = None,

    /**
     * The fill color.
     *
     * __Default value:__ `undefined`
     */
    val fill : Option[Color] = None,

    val fillOpacity : Option[Opacity] = None,

    /**
     * The overall opacity (value between [0,1]).
     *
     * __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or
     * `square` marks or layered `bar` charts and `1` otherwise.
     */
    val opacity : Option[CornerRadius] = None,

    /**
     * The stroke color.
     *
     * __Default value:__ `"#ddd"`
     */
    val stroke : Option[Color] = None,

    val strokeCap : Option[Cap] = None,
    val strokeDash : Option[StrokeDash] = None,
    val strokeDashOffset : Option[CornerRadius] = None,
    val strokeJoin : Option[StrokeJoinUnion] = None,
    val strokeMiterLimit : Option[CornerRadius] = None,
    val strokeOpacity : Option[Opacity] = None,
    val strokeWidth : Option[FontSize] = None,

    /**
     * A string or array of strings indicating the name of custom styles to apply to the view
     * background. A style is a named collection of mark property defaults defined within the
     * [style configuration](https://vega.github.io/vega-lite/docs/mark.html#style-config). If
     * style is an array, later styles will override earlier styles.
     *
     * __Default value:__ `"cell"` __Note:__ Any specified view background properties will
     * augment the default style.
     */
    val style : Option[Text] = None
) derives Encoder.AsObject, Decoder

type RepeatUnion = RepeatMapping | Seq[String]
given Decoder[RepeatUnion] = {
    List[Decoder[RepeatUnion]](
        Decoder[RepeatMapping].widen,
        Decoder[Seq[String]].widen,
    ).reduceLeft(_ or _)
}

given Encoder[RepeatUnion] = Encoder.instance {
    case enc0 : RepeatMapping => Encoder.AsObject[RepeatMapping].apply(enc0)
    case enc1 : Seq[String] => Encoder.encodeSeq[String].apply(enc1)
}

/**
 * Definition for fields to be repeated. One of: 1) An array of fields to be repeated. If
 * `"repeat"` is an array, the field can be referred to as `{"repeat": "repeat"}`. The
 * repeated views are laid out in a wrapped row. You can set the number of columns to
 * control the wrapping. 2) An object that maps `"row"` and/or `"column"` to the listed
 * fields to be repeated along the particular orientations. The objects `{"repeat": "row"}`
 * and `{"repeat": "column"}` can be used to refer to the repeated field respectively.
 */
case class RepeatMapping (
    /**
     * An array of fields to be repeated horizontally.
     */
    val column : Option[Seq[String]] = None,

    /**
     * An array of fields to be repeated vertically.
     */
    val row : Option[Seq[String]] = None,

    /**
     * An array of fields to be repeated as layers.
     */
    val layer : Option[Seq[String]] = None
) derives Encoder.AsObject, Decoder

/**
 * A key-value mapping between encoding channels and definition of fields.
 *
 * A shared key-value mapping between encoding channels and definition of fields in the
 * underlying layers.
 */
case class EdEncoding (
    /**
     * Rotation angle of point and text marks.
     */
    val angle : Option[AngleClass] = None,

    /**
     * Color of the marks – either fill or stroke color based on  the `filled` property of mark
     * definition. By default, `color` represents fill color for `"area"`, `"bar"`, `"tick"`,
     * `"text"`, `"trail"`, `"circle"`, and `"square"` / stroke color for `"line"` and
     * `"point"`.
     *
     * __Default value:__ If undefined, the default color depends on [mark
     * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color`
     * property.
     *
     * _Note:_ 1) For fine-grained control over both fill and stroke colors of the marks, please
     * use the `fill` and `stroke` channels. The `fill` or `stroke` encodings have higher
     * precedence than `color`, thus may override the `color` encoding if conflicting encodings
     * are specified. 2) See the scale documentation for more information about customizing
     * [color scheme](https://vega.github.io/vega-lite/docs/scale.html#scheme).
     */
    val color : Option[ColorClass] = None,

    /**
     * A field definition for the horizontal facet of trellis plots.
     */
    val column : Option[RowColumnEncodingFieldDef] = None,

    /**
     * A text description of this mark for ARIA accessibility (SVG output only). For SVG output
     * the `"aria-label"` attribute will be set to this description.
     */
    val description : Option[DescriptionClass] = None,

    /**
     * Additional levels of detail for grouping data in aggregate views and in line, trail, and
     * area marks without mapping data to a specific visual channel.
     */
    val detail : Option[Detail] = None,

    /**
     * A field definition for the (flexible) facet of trellis plots.
     *
     * If either `row` or `column` is specified, this channel will be ignored.
     */
    val facet : Option[FacetEncodingFieldDef] = None,

    /**
     * Fill color of the marks. __Default value:__ If undefined, the default color depends on
     * [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color`
     * property.
     *
     * _Note:_ The `fill` encoding has higher precedence than `color`, thus may override the
     * `color` encoding if conflicting encodings are specified.
     */
    val fill : Option[FillClass] = None,

    /**
     * Fill opacity of the marks.
     *
     * __Default value:__ If undefined, the default opacity depends on [mark
     * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `fillOpacity`
     * property.
     */
    val fillOpacity : Option[FillOpacityClass] = None,

    /**
     * A URL to load upon mouse click.
     */
    val href : Option[HrefClass] = None,

    /**
     * A data field to use as a unique key for data binding. When a visualization’s data is
     * updated, the key value will be used to match data elements to existing mark instances.
     * Use a key channel to enable object constancy for transitions over dynamic data.
     */
    val key : Option[KeyClass] = None,

    /**
     * Latitude position of geographically projected marks.
     */
    val latitude : Option[LatitudeClass] = None,

    /**
     * Latitude-2 position for geographically projected ranged `"area"`, `"bar"`, `"rect"`, and
     * `"rule"`.
     */
    val latitude2 : Option[Latitude2Class] = None,

    /**
     * Longitude position of geographically projected marks.
     */
    val longitude : Option[LongitudeClass] = None,

    /**
     * Longitude-2 position for geographically projected ranged `"area"`, `"bar"`, `"rect"`,
     * and  `"rule"`.
     */
    val longitude2 : Option[Longitude2Class] = None,

    /**
     * Opacity of the marks.
     *
     * __Default value:__ If undefined, the default opacity depends on [mark
     * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `opacity`
     * property.
     */
    val opacity : Option[OpacityClass] = None,

    /**
     * Order of the marks.
     * - For stacked marks, this `order` channel encodes [stack
     * order](https://vega.github.io/vega-lite/docs/stack.html#order).
     * - For line and trail marks, this `order` channel encodes order of data points in the
     * lines. This can be useful for creating [a connected
     * scatterplot](https://vega.github.io/vega-lite/examples/connected_scatterplot.html).
     * Setting `order` to `{"value": null}` makes the line marks use the original order in the
     * data sources.
     * - Otherwise, this `order` channel encodes layer order of the marks.
     *
     * __Note__: In aggregate plots, `order` field should be `aggregate`d to avoid creating
     * additional aggregation grouping.
     */
    val order : Option[Order] = None,

    /**
     * The outer radius in pixels of arc marks.
     */
    val radius : Option[RadiusClass] = None,

    /**
     * The inner radius in pixels of arc marks.
     */
    val radius2 : Option[Radius2Class] = None,

    /**
     * A field definition for the vertical facet of trellis plots.
     */
    val row : Option[RowColumnEncodingFieldDef] = None,

    /**
     * Shape of the mark.
     *
     * 1. For `point` marks the supported values include:   - plotting shapes: `"circle"`,
     * `"square"`, `"cross"`, `"diamond"`, `"triangle-up"`, `"triangle-down"`,
     * `"triangle-right"`, or `"triangle-left"`.   - the line symbol `"stroke"`   - centered
     * directional shapes `"arrow"`, `"wedge"`, or `"triangle"`   - a custom [SVG path
     * string](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths) (For correct
     * sizing, custom shape paths should be defined within a square bounding box with
     * coordinates ranging from -1 to 1 along both the x and y dimensions.)
     *
     * 2. For `geoshape` marks it should be a field definition of the geojson data
     *
     * __Default value:__ If undefined, the default shape depends on [mark
     * config](https://vega.github.io/vega-lite/docs/config.html#point-config)'s `shape`
     * property. (`"circle"` if unset.)
     */
    val shape : Option[MarkPropDefStringNullTypeForShape] = None,

    /**
     * Size of the mark.
     * - For `"point"`, `"square"` and `"circle"`, – the symbol size, or pixel area of the mark.
     * - For `"bar"` and `"tick"` – the bar and tick's size.
     * - For `"text"` – the text's font size.
     * - Size is unsupported for `"line"`, `"area"`, and `"rect"`. (Use `"trail"` instead of
     * line with varying size)
     */
    val size : Option[SizeClass] = None,

    /**
     * Stroke color of the marks. __Default value:__ If undefined, the default color depends on
     * [mark config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `color`
     * property.
     *
     * _Note:_ The `stroke` encoding has higher precedence than `color`, thus may override the
     * `color` encoding if conflicting encodings are specified.
     */
    val stroke : Option[StrokeClass] = None,

    /**
     * Stroke dash of the marks.
     *
     * __Default value:__ `[1,0]` (No dash).
     */
    val strokeDash : Option[MarkPropDefNumber] = None,

    /**
     * Stroke opacity of the marks.
     *
     * __Default value:__ If undefined, the default opacity depends on [mark
     * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `strokeOpacity`
     * property.
     */
    val strokeOpacity : Option[StrokeOpacityClass] = None,

    /**
     * Stroke width of the marks.
     *
     * __Default value:__ If undefined, the default stroke width depends on [mark
     * config](https://vega.github.io/vega-lite/docs/config.html#mark-config)'s `strokeWidth`
     * property.
     */
    val strokeWidth : Option[StrokeWidthClass] = None,

    /**
     * Text of the `text` mark.
     */
    val text : Option[TextDef] = None,

    /**
     * - For arc marks, the arc length in radians if theta2 is not specified, otherwise the
     * start arc angle. (A value of 0 indicates up or “north”, increasing values proceed
     * clockwise.)
     *
     * - For text marks, polar coordinate angle in radians.
     */
    val theta : Option[ThetaClass] = None,

    /**
     * The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing
     * values proceed clockwise.
     */
    val theta2 : Option[Theta2Class] = None,

    /**
     * The tooltip text to show upon mouse hover. Specifying `tooltip` encoding overrides [the
     * `tooltip` property in the mark
     * definition](https://vega.github.io/vega-lite/docs/mark.html#mark-def).
     *
     * See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for
     * a detailed discussion about tooltip in Vega-Lite.
     */
    val tooltip : Option[EncodingTooltip] = None,

    /**
     * The URL of an image mark.
     */
    val url : Option[URLClass] = None,

    /**
     * X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified
     * `x2` or `width`.
     *
     * The `value` of this channel can be a number or a string `"width"` for the width of the
     * plot.
     */
    val x : Option[XClass] = None,

    /**
     * X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
     *
     * The `value` of this channel can be a number or a string `"width"` for the width of the
     * plot.
     */
    val x2 : Option[X2Class] = None,

    /**
     * Error value of x coordinates for error specified `"errorbar"` and `"errorband"`.
     */
    val xError : Option[XErrorClass] = None,

    /**
     * Secondary error value of x coordinates for error specified `"errorbar"` and `"errorband"`.
     */
    val xError2 : Option[XError2Class] = None,

    /**
     * Offset of x-position of the marks
     */
    val xOffset : Option[XOffsetClass] = None,

    /**
     * Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified
     * `y2` or `height`.
     *
     * The `value` of this channel can be a number or a string `"height"` for the height of the
     * plot.
     */
    val y : Option[YClass] = None,

    /**
     * Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
     *
     * The `value` of this channel can be a number or a string `"height"` for the height of the
     * plot.
     */
    val y2 : Option[Y2Class] = None,

    /**
     * Error value of y coordinates for error specified `"errorbar"` and `"errorband"`.
     */
    val yError : Option[YErrorClass] = None,

    /**
     * Secondary error value of y coordinates for error specified `"errorbar"` and `"errorband"`.
     */
    val yError2 : Option[YError2Class] = None,

    /**
     * Offset of y-position of the marks
     */
    val yOffset : Option[YOffsetClass] = None
) derives Encoder.AsObject, Decoder

/**
 * Vega-Lite configuration object. This property can only be defined at the top-level of a
 * specification.
 */
case class ConfigClass (
    /**
     * Arc-specific Config
     */
    val arc : Option[RectConfig] = None,

    /**
     * Area-Specific Config
     */
    val area : Option[AreaConfig] = None,

    /**
     * A boolean flag indicating if ARIA default attributes should be included for marks and
     * guides (SVG output only). If false, the `"aria-hidden"` attribute will be set for all
     * guides, removing them from the ARIA accessibility tree and Vega-Lite will not generate
     * default descriptions for marks.
     *
     * __Default value:__ `true`.
     */
    val aria : Option[Boolean] = None,

    /**
     * How the visualization size should be determined. If a string, should be one of `"pad"`,
     * `"fit"` or `"none"`. Object values can additionally specify parameters for content sizing
     * and automatic resizing.
     *
     * __Default value__: `pad`
     */
    val autosize : Option[Autosize] = None,

    /**
     * Axis configuration, which determines default properties for all `x` and `y`
     * [axes](https://vega.github.io/vega-lite/docs/axis.html). For a full list of axis
     * configuration options, please see the [corresponding section of the axis
     * documentation](https://vega.github.io/vega-lite/docs/axis.html#config).
     */
    val axis : Option[AxisConfig] = None,

    /**
     * Config for axes with "band" scales.
     */
    val axisBand : Option[AxisConfig] = None,

    /**
     * Config for x-axis along the bottom edge of the chart.
     */
    val axisBottom : Option[AxisConfig] = None,

    /**
     * Config for axes with "point" or "band" scales.
     */
    val axisDiscrete : Option[AxisConfig] = None,

    /**
     * Config for y-axis along the left edge of the chart.
     */
    val axisLeft : Option[AxisConfig] = None,

    /**
     * Config for axes with "point" scales.
     */
    val axisPoint : Option[AxisConfig] = None,

    /**
     * Config for quantitative axes.
     */
    val axisQuantitative : Option[AxisConfig] = None,

    /**
     * Config for y-axis along the right edge of the chart.
     */
    val axisRight : Option[AxisConfig] = None,

    /**
     * Config for temporal axes.
     */
    val axisTemporal : Option[AxisConfig] = None,

    /**
     * Config for x-axis along the top edge of the chart.
     */
    val axisTop : Option[AxisConfig] = None,

    /**
     * X-axis specific config.
     */
    val axisX : Option[AxisConfig] = None,

    /**
     * Config for x-axes with "band" scales.
     */
    val axisXBand : Option[AxisConfig] = None,

    /**
     * Config for x-axes with "point" or "band" scales.
     */
    val axisXDiscrete : Option[AxisConfig] = None,

    /**
     * Config for x-axes with "point" scales.
     */
    val axisXPoint : Option[AxisConfig] = None,

    /**
     * Config for x-quantitative axes.
     */
    val axisXQuantitative : Option[AxisConfig] = None,

    /**
     * Config for x-temporal axes.
     */
    val axisXTemporal : Option[AxisConfig] = None,

    /**
     * Y-axis specific config.
     */
    val axisY : Option[AxisConfig] = None,

    /**
     * Config for y-axes with "band" scales.
     */
    val axisYBand : Option[AxisConfig] = None,

    /**
     * Config for y-axes with "point" or "band" scales.
     */
    val axisYDiscrete : Option[AxisConfig] = None,

    /**
     * Config for y-axes with "point" scales.
     */
    val axisYPoint : Option[AxisConfig] = None,

    /**
     * Config for y-quantitative axes.
     */
    val axisYQuantitative : Option[AxisConfig] = None,

    /**
     * Config for y-temporal axes.
     */
    val axisYTemporal : Option[AxisConfig] = None,

    /**
     * CSS color property to use as the background of the entire view.
     *
     * __Default value:__ `"white"`
     */
    val background : Option[BackgroundUnion] = None,

    /**
     * Bar-Specific Config
     */
    val bar : Option[BarConfig] = None,

    /**
     * Box Config
     */
    val boxplot : Option[BoxPlotConfig] = None,

    /**
     * Circle-Specific Config
     */
    val circle : Option[MarkConfig] = None,

    /**
     * Default configuration for all concatenation and repeat view composition operators
     * (`concat`, `hconcat`, `vconcat`, and `repeat`)
     */
    val concat : Option[CompositionConfig] = None,

    /**
     * Default axis and legend title for count fields.
     *
     * __Default value:__ `'Count of Records`.
     */
    val countTitle : Option[String] = None,

    /**
     * Allow the `formatType` property for text marks and guides to accept a custom formatter
     * function [registered as a Vega
     * expression](https://vega.github.io/vega-lite/usage/compile.html#format-type).
     */
    val customFormatTypes : Option[Boolean] = None,

    /**
     * ErrorBand Config
     */
    val errorband : Option[ErrorBandConfig] = None,

    /**
     * ErrorBar Config
     */
    val errorbar : Option[ErrorBarConfig] = None,

    /**
     * Default configuration for the `facet` view composition operator
     */
    val facet : Option[CompositionConfig] = None,

    /**
     * Defines how Vega-Lite generates title for fields. There are three possible styles:
     * - `"verbal"` (Default) - displays function in a verbal style (e.g., "Sum of field",
     * "Year-month of date", "field (binned)").
     * - `"function"` - displays function using parentheses and capitalized texts (e.g.,
     * "SUM(field)", "YEARMONTH(date)", "BIN(field)").
     * - `"plain"` - displays only the field name without functions (e.g., "field", "date",
     * "field").
     */
    val fieldTitle : Option[FieldTitle] = None,

    /**
     * Default font for all text marks, titles, and labels.
     */
    val font : Option[String] = None,

    /**
     * Geoshape-Specific Config
     */
    val geoshape : Option[MarkConfig] = None,

    /**
     * Header configuration, which determines default properties for all
     * [headers](https://vega.github.io/vega-lite/docs/header.html).
     *
     * For a full list of header configuration options, please see the [corresponding section of
     * in the header documentation](https://vega.github.io/vega-lite/docs/header.html#config).
     */
    val header : Option[HeaderConfig] = None,

    /**
     * Header configuration, which determines default properties for column
     * [headers](https://vega.github.io/vega-lite/docs/header.html).
     *
     * For a full list of header configuration options, please see the [corresponding section of
     * in the header documentation](https://vega.github.io/vega-lite/docs/header.html#config).
     */
    val headerColumn : Option[HeaderConfig] = None,

    /**
     * Header configuration, which determines default properties for non-row/column facet
     * [headers](https://vega.github.io/vega-lite/docs/header.html).
     *
     * For a full list of header configuration options, please see the [corresponding section of
     * in the header documentation](https://vega.github.io/vega-lite/docs/header.html#config).
     */
    val headerFacet : Option[HeaderConfig] = None,

    /**
     * Header configuration, which determines default properties for row
     * [headers](https://vega.github.io/vega-lite/docs/header.html).
     *
     * For a full list of header configuration options, please see the [corresponding section of
     * in the header documentation](https://vega.github.io/vega-lite/docs/header.html#config).
     */
    val headerRow : Option[HeaderConfig] = None,

    /**
     * Image-specific Config
     */
    val image : Option[RectConfig] = None,

    /**
     * Legend configuration, which determines default properties for all
     * [legends](https://vega.github.io/vega-lite/docs/legend.html). For a full list of legend
     * configuration options, please see the [corresponding section of in the legend
     * documentation](https://vega.github.io/vega-lite/docs/legend.html#config).
     */
    val legend : Option[LegendConfig] = None,

    /**
     * Line-Specific Config
     */
    val line : Option[LineConfig] = None,

    /**
     * A delimiter, such as a newline character, upon which to break text strings into multiple
     * lines. This property provides a global default for text marks, which is overridden by
     * mark or style config settings, and by the lineBreak mark encoding channel. If
     * signal-valued, either string or regular expression (regexp) values are valid.
     */
    val lineBreak : Option[BackgroundUnion] = None,

    /**
     * Locale definitions for string parsing and formatting of number and date values. The
     * locale object should contain `number` and/or `time` properties with [locale
     * definitions](https://vega.github.io/vega/docs/api/locale/). Locale definitions provided
     * in the config block may be overridden by the View constructor locale option.
     */
    val locale : Option[Locale] = None,

    /**
     * Mark Config
     */
    val mark : Option[MarkConfig] = None,

    /**
     * If normalizedNumberFormatType is not specified, D3 number format for axis labels, text
     * marks, and tooltips of normalized stacked fields (fields with `stack: "normalize"`). For
     * example `"s"` for SI units. Use [D3's number format
     * pattern](https://github.com/d3/d3-format#locale_format).
     *
     * If `config.normalizedNumberFormatType` is specified and `config.customFormatTypes` is
     * `true`, this value will be passed as `format` alongside `datum.value` to the
     * `config.numberFormatType` function. __Default value:__ `%`
     */
    val normalizedNumberFormat : Option[String] = None,

    /**
     * [Custom format
     * type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type) for
     * `config.normalizedNumberFormat`.
     *
     * __Default value:__ `undefined` -- This is equilvalent to call D3-format, which is exposed
     * as [`format` in Vega-Expression](https://vega.github.io/vega/docs/expressions/#format).
     * __Note:__ You must also set `customFormatTypes` to `true` to use this feature.
     */
    val normalizedNumberFormatType : Option[String] = None,

    /**
     * If numberFormatType is not specified, D3 number format for guide labels, text marks, and
     * tooltips of non-normalized fields (fields *without* `stack: "normalize"`). For example
     * `"s"` for SI units. Use [D3's number format
     * pattern](https://github.com/d3/d3-format#locale_format).
     *
     * If `config.numberFormatType` is specified and `config.customFormatTypes` is `true`, this
     * value will be passed as `format` alongside `datum.value` to the `config.numberFormatType`
     * function.
     */
    val numberFormat : Option[String] = None,

    /**
     * [Custom format
     * type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type) for
     * `config.numberFormat`.
     *
     * __Default value:__ `undefined` -- This is equilvalent to call D3-format, which is exposed
     * as [`format` in Vega-Expression](https://vega.github.io/vega/docs/expressions/#format).
     * __Note:__ You must also set `customFormatTypes` to `true` to use this feature.
     */
    val numberFormatType : Option[String] = None,

    /**
     * The default visualization padding, in pixels, from the edge of the visualization canvas
     * to the data rectangle. If a number, specifies padding for all sides. If an object, the
     * value should have the format `{"left": 5, "top": 5, "right": 5, "bottom": 5}` to specify
     * padding for each side of the visualization.
     *
     * __Default value__: `5`
     */
    val padding : Option[Padding] = None,

    /**
     * Dynamic variables or selections that parameterize a visualization.
     */
    val params : Option[Seq[TopLevelParameter]] = None,

    /**
     * Point-Specific Config
     */
    val point : Option[MarkConfig] = None,

    /**
     * Projection configuration, which determines default properties for all
     * [projections](https://vega.github.io/vega-lite/docs/projection.html). For a full list of
     * projection configuration options, please see the [corresponding section of the projection
     * documentation](https://vega.github.io/vega-lite/docs/projection.html#config).
     */
    val projection : Option[Projection] = None,

    /**
     * An object hash that defines default range arrays or schemes for using with scales. For a
     * full list of scale range configuration options, please see the [corresponding section of
     * the scale documentation](https://vega.github.io/vega-lite/docs/scale.html#config).
     */
    val range : Option[Map[String, RangeValue]] = None,

    /**
     * Rect-Specific Config
     */
    val rect : Option[RectConfig] = None,

    /**
     * Rule-Specific Config
     */
    val rule : Option[MarkConfig] = None,

    /**
     * Scale configuration determines default properties for all
     * [scales](https://vega.github.io/vega-lite/docs/scale.html). For a full list of scale
     * configuration options, please see the [corresponding section of the scale
     * documentation](https://vega.github.io/vega-lite/docs/scale.html#config).
     */
    val scale : Option[ScaleConfig] = None,

    /**
     * An object hash for defining default properties for each type of selections.
     */
    val selection : Option[SelectionClass] = None,

    /**
     * Square-Specific Config
     */
    val square : Option[MarkConfig] = None,

    /**
     * An object hash that defines key-value mappings to determine default properties for marks
     * with a given [style](https://vega.github.io/vega-lite/docs/mark.html#mark-def). The keys
     * represent styles names; the values have to be valid [mark configuration
     * objects](https://vega.github.io/vega-lite/docs/mark.html#config).
     */
    val style : Option[Map[String, StyleValue]] = None,

    /**
     * Text-Specific Config
     */
    val text : Option[MarkConfig] = None,

    /**
     * Tick-Specific Config
     */
    val tick : Option[TickConfig] = None,

    /**
     * Default time format for raw time values (without time units) in text marks, legend labels
     * and header labels.
     *
     * __Default value:__ `"%b %d, %Y"` __Note:__ Axes automatically determine the format for
     * each label automatically so this config does not affect axes.
     */
    val timeFormat : Option[String] = None,

    /**
     * [Custom format
     * type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type) for
     * `config.timeFormat`.
     *
     * __Default value:__ `undefined` -- This is equilvalent to call D3-time-format, which is
     * exposed as [`timeFormat` in
     * Vega-Expression](https://vega.github.io/vega/docs/expressions/#timeFormat). __Note:__ You
     * must also set `customFormatTypes` to `true` and there must *not* be a `timeUnit` defined
     * to use this feature.
     */
    val timeFormatType : Option[String] = None,

    /**
     * Title configuration, which determines default properties for all
     * [titles](https://vega.github.io/vega-lite/docs/title.html). For a full list of title
     * configuration options, please see the [corresponding section of the title
     * documentation](https://vega.github.io/vega-lite/docs/title.html#config).
     */
    val title : Option[BaseTitleNoValueRefs] = None,

    /**
     * Trail-Specific Config
     */
    val trail : Option[LineConfig] = None,

    /**
     * Default properties for [single view
     * plots](https://vega.github.io/vega-lite/docs/spec.html#single).
     */
    val view : Option[ViewConfig] = None
) derives Encoder.AsObject, Decoder

/**
 * Arc-specific Config
 *
 * Image-specific Config
 *
 * Rect-Specific Config
 */
case class RectConfig (
    /**
     * The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One
     * of `"left"`, `"right"`, `"center"`.
     *
     * __Note:__ Expression reference is *not* supported for range marks.
     */
    val align : Option[TitleAlignUnion] = None,

    val angle : Option[Angle] = None,
    val aria : Option[Aria] = None,
    val ariaRole : Option[BackgroundUnion] = None,
    val ariaRoleDescription : Option[BackgroundUnion] = None,
    val aspect : Option[Aria] = None,

    /**
     * For text marks, the vertical text baseline. One of `"alphabetic"` (default), `"top"`,
     * `"middle"`, `"bottom"`, `"line-top"`, `"line-bottom"`, or an expression reference that
     * provides one of the valid values. The `"line-top"` and `"line-bottom"` values operate
     * similarly to `"top"` and `"bottom"`, but are calculated relative to the `lineHeight`
     * rather than `fontSize` alone.
     *
     * For range marks, the vertical alignment of the marks. One of `"top"`, `"middle"`,
     * `"bottom"`.
     *
     * __Note:__ Expression reference is *not* supported for range marks.
     */
    val baseline : Option[BackgroundUnion] = None,

    /**
     * Offset between bars for binned field. The ideal value for this is either 0 (preferred by
     * statisticians) or 1 (Vega-Lite default, D3 example style).
     *
     * __Default value:__ `1`
     */
    val binSpacing : Option[Double] = None,

    val blend : Option[BlendUnion] = None,

    /**
     * Default color.
     *
     * __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
     *
     * __Note:__
     * - This property cannot be used in a [style
     * config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
     * - The `fill` and `stroke` properties have higher precedence than `color` and will
     * override `color`.
     */
    val color : Option[MarkConfigColor] = None,

    /**
     * The default size of the bars on continuous scales.
     *
     * __Default value:__ `5`
     */
    val continuousBandSize : Option[Double] = None,

    val cornerRadius : Option[CornerRadius] = None,
    val cornerRadiusBottomLeft : Option[CornerRadius] = None,
    val cornerRadiusBottomRight : Option[CornerRadius] = None,
    val cornerRadiusTopLeft : Option[CornerRadius] = None,
    val cornerRadiusTopRight : Option[CornerRadius] = None,
    val cursor : Option[CursorUnion] = None,
    val description : Option[BackgroundUnion] = None,
    val dir : Option[Dir] = None,

    /**
     * The default size of the bars with discrete dimensions. If unspecified, the default size
     * is  `step-2`, which provides 2 pixel offset between bars.
     */
    val discreteBandSize : Option[DiscreteBandSize] = None,

    val dx : Option[CornerRadius] = None,
    val dy : Option[CornerRadius] = None,
    val ellipsis : Option[BackgroundUnion] = None,
    val endAngle : Option[CornerRadius] = None,

    /**
     * Default fill color. This property has higher precedence than `config.color`. Set to
     * `null` to remove fill.
     *
     * __Default value:__ (None)
     */
    val fill : Option[MarkConfigFill] = None,

    /**
     * Whether the mark's color should be used as fill color instead of stroke color.
     *
     * __Default value:__ `false` for all `point`, `line`, and `rule` marks as well as
     * `geoshape` marks for
     * [`graticule`](https://vega.github.io/vega-lite/docs/data.html#graticule) data sources;
     * otherwise, `true`.
     *
     * __Note:__ This property cannot be used in a [style
     * config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
     */
    val filled : Option[Boolean] = None,

    val fillOpacity : Option[Opacity] = None,
    val font : Option[BackgroundUnion] = None,
    val fontSize : Option[FontSize] = None,
    val fontStyle : Option[BackgroundUnion] = None,
    val fontWeight : Option[FontWeightUnion] = None,
    val height : Option[CornerRadius] = None,
    val href : Option[BackgroundUnion] = None,

    /**
     * The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`.
     *
     * __Default value:__ `0`
     */
    val innerRadius : Option[CornerRadius] = None,

    val interpolate : Option[MarkConfigInterpolate] = None,

    /**
     * Defines how Vega-Lite should handle marks for invalid values (`null` and `NaN`).
     * - If set to `"filter"` (default), all data items with null values will be skipped (for
     * line, trail, and area marks) or filtered (for other marks).
     * - If `null`, all data items are included. In this case, invalid values will be
     * interpreted as zeroes.
     */
    val invalid : Option[Invalid] = None,

    val limit : Option[CornerRadius] = None,
    val lineBreak : Option[BackgroundUnion] = None,
    val lineHeight : Option[CornerRadius] = None,

    /**
     * The overall opacity (value between [0,1]).
     *
     * __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or
     * `square` marks or layered `bar` charts and `1` otherwise.
     */
    val opacity : Option[CornerRadius] = None,

    /**
     * For line and trail marks, this `order` property can be set to `null` or `false` to make
     * the lines use the original order in the data sources.
     */
    val order : Option[Boolean] = None,

    /**
     * The orientation of a non-stacked bar, tick, area, and line charts. The value is either
     * horizontal (default) or vertical.
     * - For bar, rule and tick, this determines whether the size of the bar and tick should be
     * applied to x or y dimension.
     * - For area, this property determines the orient property of the Vega output.
     * - For line and trail marks, this property determines the sort order of the points in the
     * line if `config.sortLineBy` is not specified. For stacked charts, this is always
     * determined by the orientation of the stack; therefore explicitly specified value will be
     * ignored.
     */
    val orient : Option[Orientation] = None,

    /**
     * The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`.
     *
     * __Default value:__ `0`
     */
    val outerRadius : Option[CornerRadius] = None,

    val padAngle : Option[CornerRadius] = None,

    /**
     * For arc mark, the primary (outer) radius in pixels.
     *
     * For text marks, polar coordinate radial offset, in pixels, of the text from the origin
     * determined by the `x` and `y` properties.
     *
     * __Default value:__ `min(plot_width, plot_height)/2`
     */
    val radius : Option[CornerRadius] = None,

    /**
     * The secondary (inner) radius in pixels of arc marks.
     *
     * __Default value:__ `0`
     */
    val radius2 : Option[CornerRadius] = None,

    val shape : Option[BackgroundUnion] = None,

    /**
     * Default size for marks.
     * - For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that
     * this value sets the area of the symbol; the side lengths will increase with the square
     * root of this value.
     * - For `bar`, this represents the band size of the bar, in pixels.
     * - For `text`, this represents the font size, in pixels.
     *
     * __Default value:__
     * - `30` for point, circle, square marks; width/height's `step`
     * - `2` for bar marks with discrete dimensions;
     * - `5` for bar marks with continuous dimensions;
     * - `11` for text marks.
     */
    val size : Option[CornerRadius] = None,

    val smooth : Option[Aria] = None,
    val startAngle : Option[CornerRadius] = None,

    /**
     * Default stroke color. This property has higher precedence than `config.color`. Set to
     * `null` to remove stroke.
     *
     * __Default value:__ (None)
     */
    val stroke : Option[MarkConfigFill] = None,

    val strokeCap : Option[Cap] = None,
    val strokeDash : Option[StrokeDash] = None,
    val strokeDashOffset : Option[CornerRadius] = None,
    val strokeJoin : Option[StrokeJoinUnion] = None,
    val strokeMiterLimit : Option[CornerRadius] = None,
    val strokeOffset : Option[CornerRadius] = None,
    val strokeOpacity : Option[Opacity] = None,
    val strokeWidth : Option[FontSize] = None,
    val tension : Option[CornerRadius] = None,
    val text : Option[TextUnion] = None,

    /**
     * - For arc marks, the arc length in radians if theta2 is not specified, otherwise the
     * start arc angle. (A value of 0 indicates up or “north”, increasing values proceed
     * clockwise.)
     *
     * - For text marks, polar coordinate angle in radians.
     */
    val theta : Option[CornerRadius] = None,

    /**
     * The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing
     * values proceed clockwise.
     */
    val theta2 : Option[CornerRadius] = None,

    /**
     * Default relative band position for a time unit. If set to `0`, the marks will be
     * positioned at the beginning of the time unit band step. If set to `0.5`, the marks will
     * be positioned in the middle of the time unit band step.
     */
    val timeUnitBandPosition : Option[Double] = None,

    /**
     * Default relative band size for a time unit. If set to `1`, the bandwidth of the marks
     * will be equal to the time unit band step. If set to `0.5`, bandwidth of the marks will be
     * half of the time unit band step.
     */
    val timeUnitBandSize : Option[Double] = None,

    /**
     * The tooltip text string to show upon mouse hover or an object defining which fields
     * should the tooltip be derived from.
     *
     * - If `tooltip` is `true` or `{"content": "encoding"}`, then all fields from `encoding`
     * will be used.
     * - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted
     * data point will be used.
     * - If set to `null` or `false`, then no tooltip will be used.
     *
     * See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for
     * a detailed discussion about tooltip  in Vega-Lite.
     *
     * __Default value:__ `null`
     */
    val tooltip : Option[OverlayMarkDefTooltip] = None,

    val url : Option[BackgroundUnion] = None,
    val width : Option[CornerRadius] = None,

    /**
     * X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified
     * `x2` or `width`.
     *
     * The `value` of this channel can be a number or a string `"width"` for the width of the
     * plot.
     */
    val x : Option[X] = None,

    /**
     * X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
     *
     * The `value` of this channel can be a number or a string `"width"` for the width of the
     * plot.
     */
    val x2 : Option[X] = None,

    /**
     * Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified
     * `y2` or `height`.
     *
     * The `value` of this channel can be a number or a string `"height"` for the height of the
     * plot.
     */
    val y : Option[X] = None,

    /**
     * Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
     *
     * The `value` of this channel can be a number or a string `"height"` for the height of the
     * plot.
     */
    val y2 : Option[X] = None
) derives Encoder.AsObject, Decoder

/**
 * Area-Specific Config
 */
case class AreaConfig (
    /**
     * The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One
     * of `"left"`, `"right"`, `"center"`.
     *
     * __Note:__ Expression reference is *not* supported for range marks.
     */
    val align : Option[TitleAlignUnion] = None,

    val angle : Option[Angle] = None,
    val aria : Option[Aria] = None,
    val ariaRole : Option[BackgroundUnion] = None,
    val ariaRoleDescription : Option[BackgroundUnion] = None,
    val aspect : Option[Aria] = None,

    /**
     * For text marks, the vertical text baseline. One of `"alphabetic"` (default), `"top"`,
     * `"middle"`, `"bottom"`, `"line-top"`, `"line-bottom"`, or an expression reference that
     * provides one of the valid values. The `"line-top"` and `"line-bottom"` values operate
     * similarly to `"top"` and `"bottom"`, but are calculated relative to the `lineHeight`
     * rather than `fontSize` alone.
     *
     * For range marks, the vertical alignment of the marks. One of `"top"`, `"middle"`,
     * `"bottom"`.
     *
     * __Note:__ Expression reference is *not* supported for range marks.
     */
    val baseline : Option[BackgroundUnion] = None,

    val blend : Option[BlendUnion] = None,

    /**
     * Default color.
     *
     * __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
     *
     * __Note:__
     * - This property cannot be used in a [style
     * config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
     * - The `fill` and `stroke` properties have higher precedence than `color` and will
     * override `color`.
     */
    val color : Option[MarkConfigColor] = None,

    val cornerRadius : Option[CornerRadius] = None,
    val cornerRadiusBottomLeft : Option[CornerRadius] = None,
    val cornerRadiusBottomRight : Option[CornerRadius] = None,
    val cornerRadiusTopLeft : Option[CornerRadius] = None,
    val cornerRadiusTopRight : Option[CornerRadius] = None,
    val cursor : Option[CursorUnion] = None,
    val description : Option[BackgroundUnion] = None,
    val dir : Option[Dir] = None,
    val dx : Option[CornerRadius] = None,
    val dy : Option[CornerRadius] = None,
    val ellipsis : Option[BackgroundUnion] = None,
    val endAngle : Option[CornerRadius] = None,

    /**
     * Default fill color. This property has higher precedence than `config.color`. Set to
     * `null` to remove fill.
     *
     * __Default value:__ (None)
     */
    val fill : Option[MarkConfigFill] = None,

    /**
     * Whether the mark's color should be used as fill color instead of stroke color.
     *
     * __Default value:__ `false` for all `point`, `line`, and `rule` marks as well as
     * `geoshape` marks for
     * [`graticule`](https://vega.github.io/vega-lite/docs/data.html#graticule) data sources;
     * otherwise, `true`.
     *
     * __Note:__ This property cannot be used in a [style
     * config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
     */
    val filled : Option[Boolean] = None,

    val fillOpacity : Option[Opacity] = None,
    val font : Option[BackgroundUnion] = None,
    val fontSize : Option[FontSize] = None,
    val fontStyle : Option[BackgroundUnion] = None,
    val fontWeight : Option[FontWeightUnion] = None,
    val height : Option[CornerRadius] = None,
    val href : Option[BackgroundUnion] = None,

    /**
     * The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`.
     *
     * __Default value:__ `0`
     */
    val innerRadius : Option[CornerRadius] = None,

    val interpolate : Option[MarkConfigInterpolate] = None,

    /**
     * Defines how Vega-Lite should handle marks for invalid values (`null` and `NaN`).
     * - If set to `"filter"` (default), all data items with null values will be skipped (for
     * line, trail, and area marks) or filtered (for other marks).
     * - If `null`, all data items are included. In this case, invalid values will be
     * interpreted as zeroes.
     */
    val invalid : Option[Invalid] = None,

    val limit : Option[CornerRadius] = None,

    /**
     * A flag for overlaying line on top of area marks, or an object defining the properties of
     * the overlayed lines.
     *
     * - If this value is an empty object (`{}`) or `true`, lines with default properties will
     * be used.
     *
     * - If this value is `false`, no lines would be automatically added to area marks.
     *
     * __Default value:__ `false`.
     */
    val line : Option[Line] = None,

    val lineBreak : Option[BackgroundUnion] = None,
    val lineHeight : Option[CornerRadius] = None,

    /**
     * The overall opacity (value between [0,1]).
     *
     * __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or
     * `square` marks or layered `bar` charts and `1` otherwise.
     */
    val opacity : Option[CornerRadius] = None,

    /**
     * For line and trail marks, this `order` property can be set to `null` or `false` to make
     * the lines use the original order in the data sources.
     */
    val order : Option[Boolean] = None,

    /**
     * The orientation of a non-stacked bar, tick, area, and line charts. The value is either
     * horizontal (default) or vertical.
     * - For bar, rule and tick, this determines whether the size of the bar and tick should be
     * applied to x or y dimension.
     * - For area, this property determines the orient property of the Vega output.
     * - For line and trail marks, this property determines the sort order of the points in the
     * line if `config.sortLineBy` is not specified. For stacked charts, this is always
     * determined by the orientation of the stack; therefore explicitly specified value will be
     * ignored.
     */
    val orient : Option[Orientation] = None,

    /**
     * The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`.
     *
     * __Default value:__ `0`
     */
    val outerRadius : Option[CornerRadius] = None,

    val padAngle : Option[CornerRadius] = None,

    /**
     * A flag for overlaying points on top of line or area marks, or an object defining the
     * properties of the overlayed points.
     *
     * - If this property is `"transparent"`, transparent points will be used (for enhancing
     * tooltips and selections).
     *
     * - If this property is an empty object (`{}`) or `true`, filled points with default
     * properties will be used.
     *
     * - If this property is `false`, no points would be automatically added to line or area
     * marks.
     *
     * __Default value:__ `false`.
     */
    val point : Option[Point] = None,

    /**
     * For arc mark, the primary (outer) radius in pixels.
     *
     * For text marks, polar coordinate radial offset, in pixels, of the text from the origin
     * determined by the `x` and `y` properties.
     *
     * __Default value:__ `min(plot_width, plot_height)/2`
     */
    val radius : Option[CornerRadius] = None,

    /**
     * The secondary (inner) radius in pixels of arc marks.
     *
     * __Default value:__ `0`
     */
    val radius2 : Option[CornerRadius] = None,

    val shape : Option[BackgroundUnion] = None,

    /**
     * Default size for marks.
     * - For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that
     * this value sets the area of the symbol; the side lengths will increase with the square
     * root of this value.
     * - For `bar`, this represents the band size of the bar, in pixels.
     * - For `text`, this represents the font size, in pixels.
     *
     * __Default value:__
     * - `30` for point, circle, square marks; width/height's `step`
     * - `2` for bar marks with discrete dimensions;
     * - `5` for bar marks with continuous dimensions;
     * - `11` for text marks.
     */
    val size : Option[CornerRadius] = None,

    val smooth : Option[Aria] = None,
    val startAngle : Option[CornerRadius] = None,

    /**
     * Default stroke color. This property has higher precedence than `config.color`. Set to
     * `null` to remove stroke.
     *
     * __Default value:__ (None)
     */
    val stroke : Option[MarkConfigFill] = None,

    val strokeCap : Option[Cap] = None,
    val strokeDash : Option[StrokeDash] = None,
    val strokeDashOffset : Option[CornerRadius] = None,
    val strokeJoin : Option[StrokeJoinUnion] = None,
    val strokeMiterLimit : Option[CornerRadius] = None,
    val strokeOffset : Option[CornerRadius] = None,
    val strokeOpacity : Option[Opacity] = None,
    val strokeWidth : Option[FontSize] = None,
    val tension : Option[CornerRadius] = None,
    val text : Option[TextUnion] = None,

    /**
     * - For arc marks, the arc length in radians if theta2 is not specified, otherwise the
     * start arc angle. (A value of 0 indicates up or “north”, increasing values proceed
     * clockwise.)
     *
     * - For text marks, polar coordinate angle in radians.
     */
    val theta : Option[CornerRadius] = None,

    /**
     * The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing
     * values proceed clockwise.
     */
    val theta2 : Option[CornerRadius] = None,

    /**
     * Default relative band position for a time unit. If set to `0`, the marks will be
     * positioned at the beginning of the time unit band step. If set to `0.5`, the marks will
     * be positioned in the middle of the time unit band step.
     */
    val timeUnitBandPosition : Option[Double] = None,

    /**
     * Default relative band size for a time unit. If set to `1`, the bandwidth of the marks
     * will be equal to the time unit band step. If set to `0.5`, bandwidth of the marks will be
     * half of the time unit band step.
     */
    val timeUnitBandSize : Option[Double] = None,

    /**
     * The tooltip text string to show upon mouse hover or an object defining which fields
     * should the tooltip be derived from.
     *
     * - If `tooltip` is `true` or `{"content": "encoding"}`, then all fields from `encoding`
     * will be used.
     * - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted
     * data point will be used.
     * - If set to `null` or `false`, then no tooltip will be used.
     *
     * See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for
     * a detailed discussion about tooltip  in Vega-Lite.
     *
     * __Default value:__ `null`
     */
    val tooltip : Option[OverlayMarkDefTooltip] = None,

    val url : Option[BackgroundUnion] = None,
    val width : Option[CornerRadius] = None,

    /**
     * X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified
     * `x2` or `width`.
     *
     * The `value` of this channel can be a number or a string `"width"` for the width of the
     * plot.
     */
    val x : Option[X] = None,

    /**
     * X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
     *
     * The `value` of this channel can be a number or a string `"width"` for the width of the
     * plot.
     */
    val x2 : Option[X] = None,

    /**
     * Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified
     * `y2` or `height`.
     *
     * The `value` of this channel can be a number or a string `"height"` for the height of the
     * plot.
     */
    val y : Option[X] = None,

    /**
     * Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
     *
     * The `value` of this channel can be a number or a string `"height"` for the height of the
     * plot.
     */
    val y2 : Option[X] = None
) derives Encoder.AsObject, Decoder

/**
 * Axis configuration, which determines default properties for all `x` and `y`
 * [axes](https://vega.github.io/vega-lite/docs/axis.html). For a full list of axis
 * configuration options, please see the [corresponding section of the axis
 * documentation](https://vega.github.io/vega-lite/docs/axis.html#config).
 *
 * Config for axes with "band" scales.
 *
 * Config for x-axis along the bottom edge of the chart.
 *
 * Config for axes with "point" or "band" scales.
 *
 * Config for y-axis along the left edge of the chart.
 *
 * Config for axes with "point" scales.
 *
 * Config for quantitative axes.
 *
 * Config for y-axis along the right edge of the chart.
 *
 * Config for temporal axes.
 *
 * Config for x-axis along the top edge of the chart.
 *
 * X-axis specific config.
 *
 * Config for x-axes with "band" scales.
 *
 * Config for x-axes with "point" or "band" scales.
 *
 * Config for x-axes with "point" scales.
 *
 * Config for x-quantitative axes.
 *
 * Config for x-temporal axes.
 *
 * Y-axis specific config.
 *
 * Config for y-axes with "band" scales.
 *
 * Config for y-axes with "point" or "band" scales.
 *
 * Config for y-axes with "point" scales.
 *
 * Config for y-quantitative axes.
 *
 * Config for y-temporal axes.
 */
case class AxisConfig (
    val aria : Option[Aria] = None,
    val bandPosition : Option[CornerRadius] = None,
    val description : Option[BackgroundUnion] = None,

    /**
     * Disable axis by default.
     */
    val disable : Option[Boolean] = None,

    /**
     * A boolean flag indicating if the domain (the axis baseline) should be included as part of
     * the axis.
     *
     * __Default value:__ `true`
     */
    val domain : Option[Boolean] = None,

    val domainCap : Option[Cap] = None,
    val domainColor : Option[Color] = None,
    val domainDash : Option[StrokeDash] = None,
    val domainDashOffset : Option[CornerRadius] = None,
    val domainOpacity : Option[CornerRadius] = None,
    val domainWidth : Option[CornerRadius] = None,

    /**
     * When used with the default `"number"` and `"time"` format type, the text formatting
     * pattern for labels of guides (axes, legends, headers) and text marks.
     *
     * - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number
     * format pattern](https://github.com/d3/d3-format#locale_format).
     * - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format
     * pattern](https://github.com/d3/d3-time-format#locale_format).
     *
     * See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for
     * more examples.
     *
     * When used with a [custom
     * `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this
     * value will be passed as `format` alongside `datum.value` to the registered function.
     *
     * __Default value:__  Derived from
     * [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for
     * number format and from
     * [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time
     * format.
     */
    val format : Option[Format] = None,

    /**
     * The format type for labels. One of `"number"`, `"time"`, or a [registered custom format
     * type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).
     *
     * __Default value:__
     * - `"time"` for temporal fields and ordinal and nominal fields with `timeUnit`.
     * - `"number"` for quantitative fields as well as ordinal and nominal fields without
     * `timeUnit`.
     */
    val formatType : Option[String] = None,

    /**
     * A boolean flag indicating if grid lines should be included as part of the axis
     *
     * __Default value:__ `true` for [continuous
     * scales](https://vega.github.io/vega-lite/docs/scale.html#continuous) that are not binned;
     * otherwise, `false`.
     */
    val grid : Option[Boolean] = None,

    val gridCap : Option[Cap] = None,
    val gridColor : Option[GridColorUnion] = None,
    val gridDash : Option[AxisBandGridDash] = None,
    val gridDashOffset : Option[GridDashOffsetUnion] = None,
    val gridOpacity : Option[GridOpacityUnion] = None,
    val gridWidth : Option[GridWidthUnion] = None,
    val labelAlign : Option[ConditionalAxisPropertyAlignNull] = None,
    val labelAngle : Option[LabelAngle] = None,
    val labelBaseline : Option[TextBaseline] = None,
    val labelBound : Option[Label] = None,
    val labelColor : Option[GridColorUnion] = None,

    /**
     * [Vega expression](https://vega.github.io/vega/docs/expressions/) for customizing labels.
     *
     * __Note:__ The label text and value can be assessed via the `label` and `value` properties
     * of the axis's backing `datum` object.
     */
    val labelExpr : Option[String] = None,

    /**
     * Indicates if the first and last axis labels should be aligned flush with the scale range.
     * Flush alignment for a horizontal axis will left-align the first label and right-align the
     * last label. For vertical axes, bottom and top text baselines are applied instead. If this
     * property is a number, it also indicates the number of pixels by which to offset the first
     * and last labels; for example, a value of 2 will flush-align the first and last labels and
     * also push them 2 pixels outward from the center of the axis. The additional adjustment
     * can sometimes help the labels better visually group with corresponding axis ticks.
     *
     * __Default value:__ `true` for axis of a continuous x-scale. Otherwise, `false`.
     */
    val labelFlush : Option[LabelFlush] = None,

    val labelFlushOffset : Option[CornerRadius] = None,
    val labelFont : Option[ConditionalAxisPropertyStringNull] = None,
    val labelFontSize : Option[GridWidthUnion] = None,
    val labelFontStyle : Option[ConditionalAxisPropertyFontStyleNull] = None,
    val labelFontWeight : Option[FontWeight] = None,
    val labelLimit : Option[CornerRadius] = None,
    val labelLineHeight : Option[CornerRadius] = None,
    val labelOffset : Option[GridDashOffsetUnion] = None,
    val labelOpacity : Option[GridDashOffsetUnion] = None,

    /**
     * The strategy to use for resolving overlap of axis labels. If `false` (the default), no
     * overlap reduction is attempted. If set to `true` or `"parity"`, a strategy of removing
     * every other label is used (this works well for standard linear axes). If set to
     * `"greedy"`, a linear scan of the labels is performed, removing any labels that overlaps
     * with the last visible label (this often works better for log-scaled axes).
     *
     * __Default value:__ `true` for non-nominal fields with non-log scales; `"greedy"` for log
     * scales; otherwise `false`.
     */
    val labelOverlap : Option[LabelOverlap] = None,

    val labelPadding : Option[GridDashOffsetUnion] = None,

    /**
     * A boolean flag indicating if labels should be included as part of the axis.
     *
     * __Default value:__ `true`.
     */
    val labels : Option[Boolean] = None,

    val labelSeparation : Option[CornerRadius] = None,
    val maxExtent : Option[CornerRadius] = None,
    val minExtent : Option[CornerRadius] = None,

    /**
     * The offset, in pixels, by which to displace the axis from the edge of the enclosing group
     * or data rectangle.
     *
     * __Default value:__ derived from the [axis
     * config](https://vega.github.io/vega-lite/docs/config.html#facet-scale-config)'s `offset`
     * (`0` by default)
     */
    val offset : Option[CornerRadius] = None,

    /**
     * The orientation of the axis. One of `"top"`, `"bottom"`, `"left"` or `"right"`. The
     * orientation can be used to further specialize the axis type (e.g., a y-axis oriented
     * towards the right edge of the chart).
     *
     * __Default value:__ `"bottom"` for x-axes and `"left"` for y-axes.
     */
    val orient : Option[TitleOrientUnion] = None,

    /**
     * The anchor position of the axis in pixels. For x-axes with top or bottom orientation,
     * this sets the axis group x coordinate. For y-axes with left or right orientation, this
     * sets the axis group y coordinate.
     *
     * __Default value__: `0`
     */
    val position : Option[CornerRadius] = None,

    /**
     * A string or array of strings indicating the name of custom styles to apply to the axis. A
     * style is a named collection of axis property defined within the [style
     * configuration](https://vega.github.io/vega-lite/docs/mark.html#style-config). If style is
     * an array, later styles will override earlier styles.
     *
     * __Default value:__ (none) __Note:__ Any specified style will augment the default style.
     * For example, an x-axis mark with `"style": "foo"` will use `config.axisX` and
     * `config.style.foo` (the specified style `"foo"` has higher precedence).
     */
    val style : Option[Text] = None,

    val tickBand : Option[TickBandUnion] = None,
    val tickCap : Option[Cap] = None,
    val tickColor : Option[GridColorUnion] = None,

    /**
     * A desired number of ticks, for axes visualizing quantitative scales. The resulting number
     * may be different so that values are "nice" (multiples of 2, 5, 10) and lie within the
     * underlying scale's range.
     *
     * For scales of type `"time"` or `"utc"`, the tick count can instead be a time interval
     * specifier. Legal string values are `"millisecond"`, `"second"`, `"minute"`, `"hour"`,
     * `"day"`, `"week"`, `"month"`, and `"year"`. Alternatively, an object-valued interval
     * specifier of the form `{"interval": "month", "step": 3}` includes a desired number of
     * interval steps. Here, ticks are generated for each quarter (Jan, Apr, Jul, Oct)
     * boundary.
     *
     * __Default value__: Determine using a formula `ceil(width/40)` for x and `ceil(height/40)`
     * for y.
     */
    val tickCount : Option[TickCount] = None,

    val tickDash : Option[AxisBandTickDash] = None,
    val tickDashOffset : Option[GridDashOffsetUnion] = None,

    /**
     * Boolean flag indicating if an extra axis tick should be added for the initial position of
     * the axis. This flag is useful for styling axes for `band` scales such that ticks are
     * placed on band boundaries rather in the middle of a band. Use in conjunction with
     * `"bandPosition": 1` and an axis `"padding"` value of `0`.
     */
    val tickExtra : Option[Boolean] = None,

    /**
     * The minimum desired step between axis ticks, in terms of scale domain values. For
     * example, a value of `1` indicates that ticks should not be less than 1 unit apart. If
     * `tickMinStep` is specified, the `tickCount` value will be adjusted, if necessary, to
     * enforce the minimum step value.
     */
    val tickMinStep : Option[CornerRadius] = None,

    val tickOffset : Option[CornerRadius] = None,
    val tickOpacity : Option[GridDashOffsetUnion] = None,

    /**
     * Boolean flag indicating if pixel position values should be rounded to the nearest
     * integer.
     *
     * __Default value:__ `true`
     */
    val tickRound : Option[Boolean] = None,

    /**
     * Boolean value that determines whether the axis should include ticks.
     *
     * __Default value:__ `true`
     */
    val ticks : Option[Boolean] = None,

    val tickSize : Option[GridWidthUnion] = None,
    val tickWidth : Option[GridWidthUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    val titleAlign : Option[TitleAlignUnion] = None,
    val titleAnchor : Option[TitleAnchorUnion] = None,
    val titleAngle : Option[CornerRadius] = None,
    val titleBaseline : Option[BackgroundUnion] = None,
    val titleColor : Option[Color] = None,
    val titleFont : Option[BackgroundUnion] = None,
    val titleFontSize : Option[FontSize] = None,
    val titleFontStyle : Option[BackgroundUnion] = None,
    val titleFontWeight : Option[FontWeightUnion] = None,
    val titleLimit : Option[FontSize] = None,
    val titleLineHeight : Option[CornerRadius] = None,
    val titleOpacity : Option[CornerRadius] = None,
    val titlePadding : Option[CornerRadius] = None,
    val titleX : Option[CornerRadius] = None,
    val titleY : Option[CornerRadius] = None,
    val translate : Option[CornerRadius] = None,

    /**
     * Explicitly set the visible axis tick values.
     */
    val values : Option[Values] = None,

    /**
     * A non-negative integer indicating the z-index of the axis. If zindex is 0, axes should be
     * drawn behind all chart elements. To put them in front, set `zindex` to `1` or more.
     *
     * __Default value:__ `0` (behind the marks).
     */
    val zindex : Option[Double] = None
) derives Encoder.AsObject, Decoder

type AxisBandGridDash = AmbitiousExprRef | Seq[Double]
given Decoder[AxisBandGridDash] = {
    List[Decoder[AxisBandGridDash]](
        Decoder[AmbitiousExprRef].widen,
        Decoder[Seq[Double]].widen,
    ).reduceLeft(_ or _)
}

given Encoder[AxisBandGridDash] = Encoder.instance {
    case enc0 : AmbitiousExprRef => Encoder.AsObject[AmbitiousExprRef].apply(enc0)
    case enc1 : Seq[Double] => Encoder.encodeSeq[Double].apply(enc1)
}

case class AmbitiousExprRef (
    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None,

    val condition : Option[TentacledConditionalPredicateValueDefNumberNullExprRef] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Seq[Double]] = None
) derives Encoder.AsObject, Decoder

type AxisBandTickDash = CunningExprRef | Seq[Double]
given Decoder[AxisBandTickDash] = {
    List[Decoder[AxisBandTickDash]](
        Decoder[CunningExprRef].widen,
        Decoder[Seq[Double]].widen,
    ).reduceLeft(_ or _)
}

given Encoder[AxisBandTickDash] = Encoder.instance {
    case enc0 : CunningExprRef => Encoder.AsObject[CunningExprRef].apply(enc0)
    case enc1 : Seq[Double] => Encoder.encodeSeq[Double].apply(enc1)
}

case class CunningExprRef (
    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None,

    val condition : Option[TentacledConditionalPredicateValueDefNumberNullExprRef] = None,

    /**
     * A constant value in visual domain (e.g., `"red"` / `"#0099ff"` / [gradient
     * definition](https://vega.github.io/vega-lite/docs/types.html#gradient) for color, values
     * between `0` to `1` for opacity).
     */
    val value : Option[Seq[Double]] = None
) derives Encoder.AsObject, Decoder

/**
 * Bar-Specific Config
 */
case class BarConfig (
    /**
     * The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One
     * of `"left"`, `"right"`, `"center"`.
     *
     * __Note:__ Expression reference is *not* supported for range marks.
     */
    val align : Option[TitleAlignUnion] = None,

    val angle : Option[Angle] = None,
    val aria : Option[Aria] = None,
    val ariaRole : Option[BackgroundUnion] = None,
    val ariaRoleDescription : Option[BackgroundUnion] = None,
    val aspect : Option[Aria] = None,

    /**
     * For text marks, the vertical text baseline. One of `"alphabetic"` (default), `"top"`,
     * `"middle"`, `"bottom"`, `"line-top"`, `"line-bottom"`, or an expression reference that
     * provides one of the valid values. The `"line-top"` and `"line-bottom"` values operate
     * similarly to `"top"` and `"bottom"`, but are calculated relative to the `lineHeight`
     * rather than `fontSize` alone.
     *
     * For range marks, the vertical alignment of the marks. One of `"top"`, `"middle"`,
     * `"bottom"`.
     *
     * __Note:__ Expression reference is *not* supported for range marks.
     */
    val baseline : Option[BackgroundUnion] = None,

    /**
     * Offset between bars for binned field. The ideal value for this is either 0 (preferred by
     * statisticians) or 1 (Vega-Lite default, D3 example style).
     *
     * __Default value:__ `1`
     */
    val binSpacing : Option[Double] = None,

    val blend : Option[BlendUnion] = None,

    /**
     * Default color.
     *
     * __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
     *
     * __Note:__
     * - This property cannot be used in a [style
     * config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
     * - The `fill` and `stroke` properties have higher precedence than `color` and will
     * override `color`.
     */
    val color : Option[MarkConfigColor] = None,

    /**
     * The default size of the bars on continuous scales.
     *
     * __Default value:__ `5`
     */
    val continuousBandSize : Option[Double] = None,

    val cornerRadius : Option[CornerRadius] = None,
    val cornerRadiusBottomLeft : Option[CornerRadius] = None,
    val cornerRadiusBottomRight : Option[CornerRadius] = None,

    /**
     * - For vertical bars, top-left and top-right corner radius.
     *
     * - For horizontal bars, top-right and bottom-right corner radius.
     */
    val cornerRadiusEnd : Option[CornerRadius] = None,

    val cornerRadiusTopLeft : Option[CornerRadius] = None,
    val cornerRadiusTopRight : Option[CornerRadius] = None,
    val cursor : Option[CursorUnion] = None,
    val description : Option[BackgroundUnion] = None,
    val dir : Option[Dir] = None,

    /**
     * The default size of the bars with discrete dimensions. If unspecified, the default size
     * is  `step-2`, which provides 2 pixel offset between bars.
     */
    val discreteBandSize : Option[DiscreteBandSize] = None,

    val dx : Option[CornerRadius] = None,
    val dy : Option[CornerRadius] = None,
    val ellipsis : Option[BackgroundUnion] = None,
    val endAngle : Option[CornerRadius] = None,

    /**
     * Default fill color. This property has higher precedence than `config.color`. Set to
     * `null` to remove fill.
     *
     * __Default value:__ (None)
     */
    val fill : Option[MarkConfigFill] = None,

    /**
     * Whether the mark's color should be used as fill color instead of stroke color.
     *
     * __Default value:__ `false` for all `point`, `line`, and `rule` marks as well as
     * `geoshape` marks for
     * [`graticule`](https://vega.github.io/vega-lite/docs/data.html#graticule) data sources;
     * otherwise, `true`.
     *
     * __Note:__ This property cannot be used in a [style
     * config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
     */
    val filled : Option[Boolean] = None,

    val fillOpacity : Option[Opacity] = None,
    val font : Option[BackgroundUnion] = None,
    val fontSize : Option[FontSize] = None,
    val fontStyle : Option[BackgroundUnion] = None,
    val fontWeight : Option[FontWeightUnion] = None,
    val height : Option[CornerRadius] = None,
    val href : Option[BackgroundUnion] = None,

    /**
     * The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`.
     *
     * __Default value:__ `0`
     */
    val innerRadius : Option[CornerRadius] = None,

    val interpolate : Option[MarkConfigInterpolate] = None,

    /**
     * Defines how Vega-Lite should handle marks for invalid values (`null` and `NaN`).
     * - If set to `"filter"` (default), all data items with null values will be skipped (for
     * line, trail, and area marks) or filtered (for other marks).
     * - If `null`, all data items are included. In this case, invalid values will be
     * interpreted as zeroes.
     */
    val invalid : Option[Invalid] = None,

    val limit : Option[CornerRadius] = None,
    val lineBreak : Option[BackgroundUnion] = None,
    val lineHeight : Option[CornerRadius] = None,

    /**
     * The overall opacity (value between [0,1]).
     *
     * __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or
     * `square` marks or layered `bar` charts and `1` otherwise.
     */
    val opacity : Option[CornerRadius] = None,

    /**
     * For line and trail marks, this `order` property can be set to `null` or `false` to make
     * the lines use the original order in the data sources.
     */
    val order : Option[Boolean] = None,

    /**
     * The orientation of a non-stacked bar, tick, area, and line charts. The value is either
     * horizontal (default) or vertical.
     * - For bar, rule and tick, this determines whether the size of the bar and tick should be
     * applied to x or y dimension.
     * - For area, this property determines the orient property of the Vega output.
     * - For line and trail marks, this property determines the sort order of the points in the
     * line if `config.sortLineBy` is not specified. For stacked charts, this is always
     * determined by the orientation of the stack; therefore explicitly specified value will be
     * ignored.
     */
    val orient : Option[Orientation] = None,

    /**
     * The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`.
     *
     * __Default value:__ `0`
     */
    val outerRadius : Option[CornerRadius] = None,

    val padAngle : Option[CornerRadius] = None,

    /**
     * For arc mark, the primary (outer) radius in pixels.
     *
     * For text marks, polar coordinate radial offset, in pixels, of the text from the origin
     * determined by the `x` and `y` properties.
     *
     * __Default value:__ `min(plot_width, plot_height)/2`
     */
    val radius : Option[CornerRadius] = None,

    /**
     * The secondary (inner) radius in pixels of arc marks.
     *
     * __Default value:__ `0`
     */
    val radius2 : Option[CornerRadius] = None,

    val shape : Option[BackgroundUnion] = None,

    /**
     * Default size for marks.
     * - For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that
     * this value sets the area of the symbol; the side lengths will increase with the square
     * root of this value.
     * - For `bar`, this represents the band size of the bar, in pixels.
     * - For `text`, this represents the font size, in pixels.
     *
     * __Default value:__
     * - `30` for point, circle, square marks; width/height's `step`
     * - `2` for bar marks with discrete dimensions;
     * - `5` for bar marks with continuous dimensions;
     * - `11` for text marks.
     */
    val size : Option[CornerRadius] = None,

    val smooth : Option[Aria] = None,
    val startAngle : Option[CornerRadius] = None,

    /**
     * Default stroke color. This property has higher precedence than `config.color`. Set to
     * `null` to remove stroke.
     *
     * __Default value:__ (None)
     */
    val stroke : Option[MarkConfigFill] = None,

    val strokeCap : Option[Cap] = None,
    val strokeDash : Option[StrokeDash] = None,
    val strokeDashOffset : Option[CornerRadius] = None,
    val strokeJoin : Option[StrokeJoinUnion] = None,
    val strokeMiterLimit : Option[CornerRadius] = None,
    val strokeOffset : Option[CornerRadius] = None,
    val strokeOpacity : Option[Opacity] = None,
    val strokeWidth : Option[FontSize] = None,
    val tension : Option[CornerRadius] = None,
    val text : Option[TextUnion] = None,

    /**
     * - For arc marks, the arc length in radians if theta2 is not specified, otherwise the
     * start arc angle. (A value of 0 indicates up or “north”, increasing values proceed
     * clockwise.)
     *
     * - For text marks, polar coordinate angle in radians.
     */
    val theta : Option[CornerRadius] = None,

    /**
     * The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing
     * values proceed clockwise.
     */
    val theta2 : Option[CornerRadius] = None,

    /**
     * Default relative band position for a time unit. If set to `0`, the marks will be
     * positioned at the beginning of the time unit band step. If set to `0.5`, the marks will
     * be positioned in the middle of the time unit band step.
     */
    val timeUnitBandPosition : Option[Double] = None,

    /**
     * Default relative band size for a time unit. If set to `1`, the bandwidth of the marks
     * will be equal to the time unit band step. If set to `0.5`, bandwidth of the marks will be
     * half of the time unit band step.
     */
    val timeUnitBandSize : Option[Double] = None,

    /**
     * The tooltip text string to show upon mouse hover or an object defining which fields
     * should the tooltip be derived from.
     *
     * - If `tooltip` is `true` or `{"content": "encoding"}`, then all fields from `encoding`
     * will be used.
     * - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted
     * data point will be used.
     * - If set to `null` or `false`, then no tooltip will be used.
     *
     * See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for
     * a detailed discussion about tooltip  in Vega-Lite.
     *
     * __Default value:__ `null`
     */
    val tooltip : Option[OverlayMarkDefTooltip] = None,

    val url : Option[BackgroundUnion] = None,
    val width : Option[CornerRadius] = None,

    /**
     * X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified
     * `x2` or `width`.
     *
     * The `value` of this channel can be a number or a string `"width"` for the width of the
     * plot.
     */
    val x : Option[X] = None,

    /**
     * X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
     *
     * The `value` of this channel can be a number or a string `"width"` for the width of the
     * plot.
     */
    val x2 : Option[X] = None,

    /**
     * Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified
     * `y2` or `height`.
     *
     * The `value` of this channel can be a number or a string `"height"` for the height of the
     * plot.
     */
    val y : Option[X] = None,

    /**
     * Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
     *
     * The `value` of this channel can be a number or a string `"height"` for the height of the
     * plot.
     */
    val y2 : Option[X] = None
) derives Encoder.AsObject, Decoder

/**
 * Box Config
 */
case class BoxPlotConfig (
    val box : Option[AnyMarkConfig] = None,

    /**
     * The extent of the whiskers. Available options include:
     * - `"min-max"`: min and max are the lower and upper whiskers respectively.
     * - A number representing multiple of the interquartile range. This number will be
     * multiplied by the IQR to determine whisker boundary, which spans from the smallest data
     * to the largest data within the range _[Q1 - k * IQR, Q3 + k * IQR]_ where _Q1_ and _Q3_
     * are the first and third quartiles while _IQR_ is the interquartile range (_Q3-Q1_).
     *
     * __Default value:__ `1.5`.
     */
    val extent : Option[BoxPlotDefExtent] = None,

    val median : Option[AnyMarkConfig] = None,
    val outliers : Option[AnyMarkConfig] = None,
    val rule : Option[AnyMarkConfig] = None,

    /**
     * Size of the box and median tick of a box plot
     */
    val size : Option[Double] = None,

    val ticks : Option[AnyMarkConfig] = None
) derives Encoder.AsObject, Decoder

/**
 * Circle-Specific Config
 *
 * Geoshape-Specific Config
 *
 * Mark Config
 *
 * Point-Specific Config
 *
 * Rule-Specific Config
 *
 * Square-Specific Config
 *
 * Default style for chart subtitles
 *
 * Default style for chart titles
 *
 * Default style for axis, legend, and header labels.
 *
 * Default style for axis, legend, and header titles.
 *
 * Text-Specific Config
 */
case class MarkConfig (
    /**
     * The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One
     * of `"left"`, `"right"`, `"center"`.
     *
     * __Note:__ Expression reference is *not* supported for range marks.
     */
    val align : Option[TitleAlignUnion] = None,

    val angle : Option[Angle] = None,
    val aria : Option[Aria] = None,
    val ariaRole : Option[BackgroundUnion] = None,
    val ariaRoleDescription : Option[BackgroundUnion] = None,
    val aspect : Option[Aria] = None,

    /**
     * For text marks, the vertical text baseline. One of `"alphabetic"` (default), `"top"`,
     * `"middle"`, `"bottom"`, `"line-top"`, `"line-bottom"`, or an expression reference that
     * provides one of the valid values. The `"line-top"` and `"line-bottom"` values operate
     * similarly to `"top"` and `"bottom"`, but are calculated relative to the `lineHeight`
     * rather than `fontSize` alone.
     *
     * For range marks, the vertical alignment of the marks. One of `"top"`, `"middle"`,
     * `"bottom"`.
     *
     * __Note:__ Expression reference is *not* supported for range marks.
     */
    val baseline : Option[BackgroundUnion] = None,

    val blend : Option[BlendUnion] = None,

    /**
     * Default color.
     *
     * __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
     *
     * __Note:__
     * - This property cannot be used in a [style
     * config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
     * - The `fill` and `stroke` properties have higher precedence than `color` and will
     * override `color`.
     */
    val color : Option[MarkConfigColor] = None,

    val cornerRadius : Option[CornerRadius] = None,
    val cornerRadiusBottomLeft : Option[CornerRadius] = None,
    val cornerRadiusBottomRight : Option[CornerRadius] = None,
    val cornerRadiusTopLeft : Option[CornerRadius] = None,
    val cornerRadiusTopRight : Option[CornerRadius] = None,
    val cursor : Option[CursorUnion] = None,
    val description : Option[BackgroundUnion] = None,
    val dir : Option[Dir] = None,
    val dx : Option[CornerRadius] = None,
    val dy : Option[CornerRadius] = None,
    val ellipsis : Option[BackgroundUnion] = None,
    val endAngle : Option[CornerRadius] = None,

    /**
     * Default fill color. This property has higher precedence than `config.color`. Set to
     * `null` to remove fill.
     *
     * __Default value:__ (None)
     */
    val fill : Option[MarkConfigFill] = None,

    /**
     * Whether the mark's color should be used as fill color instead of stroke color.
     *
     * __Default value:__ `false` for all `point`, `line`, and `rule` marks as well as
     * `geoshape` marks for
     * [`graticule`](https://vega.github.io/vega-lite/docs/data.html#graticule) data sources;
     * otherwise, `true`.
     *
     * __Note:__ This property cannot be used in a [style
     * config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
     */
    val filled : Option[Boolean] = None,

    val fillOpacity : Option[Opacity] = None,
    val font : Option[BackgroundUnion] = None,
    val fontSize : Option[FontSize] = None,
    val fontStyle : Option[BackgroundUnion] = None,
    val fontWeight : Option[FontWeightUnion] = None,
    val height : Option[CornerRadius] = None,
    val href : Option[BackgroundUnion] = None,

    /**
     * The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`.
     *
     * __Default value:__ `0`
     */
    val innerRadius : Option[CornerRadius] = None,

    val interpolate : Option[MarkConfigInterpolate] = None,

    /**
     * Defines how Vega-Lite should handle marks for invalid values (`null` and `NaN`).
     * - If set to `"filter"` (default), all data items with null values will be skipped (for
     * line, trail, and area marks) or filtered (for other marks).
     * - If `null`, all data items are included. In this case, invalid values will be
     * interpreted as zeroes.
     */
    val invalid : Option[Invalid] = None,

    val limit : Option[CornerRadius] = None,
    val lineBreak : Option[BackgroundUnion] = None,
    val lineHeight : Option[CornerRadius] = None,

    /**
     * The overall opacity (value between [0,1]).
     *
     * __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or
     * `square` marks or layered `bar` charts and `1` otherwise.
     */
    val opacity : Option[CornerRadius] = None,

    /**
     * For line and trail marks, this `order` property can be set to `null` or `false` to make
     * the lines use the original order in the data sources.
     */
    val order : Option[Boolean] = None,

    /**
     * The orientation of a non-stacked bar, tick, area, and line charts. The value is either
     * horizontal (default) or vertical.
     * - For bar, rule and tick, this determines whether the size of the bar and tick should be
     * applied to x or y dimension.
     * - For area, this property determines the orient property of the Vega output.
     * - For line and trail marks, this property determines the sort order of the points in the
     * line if `config.sortLineBy` is not specified. For stacked charts, this is always
     * determined by the orientation of the stack; therefore explicitly specified value will be
     * ignored.
     */
    val orient : Option[Orientation] = None,

    /**
     * The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`.
     *
     * __Default value:__ `0`
     */
    val outerRadius : Option[CornerRadius] = None,

    val padAngle : Option[CornerRadius] = None,

    /**
     * For arc mark, the primary (outer) radius in pixels.
     *
     * For text marks, polar coordinate radial offset, in pixels, of the text from the origin
     * determined by the `x` and `y` properties.
     *
     * __Default value:__ `min(plot_width, plot_height)/2`
     */
    val radius : Option[CornerRadius] = None,

    /**
     * The secondary (inner) radius in pixels of arc marks.
     *
     * __Default value:__ `0`
     */
    val radius2 : Option[CornerRadius] = None,

    val shape : Option[BackgroundUnion] = None,

    /**
     * Default size for marks.
     * - For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that
     * this value sets the area of the symbol; the side lengths will increase with the square
     * root of this value.
     * - For `bar`, this represents the band size of the bar, in pixels.
     * - For `text`, this represents the font size, in pixels.
     *
     * __Default value:__
     * - `30` for point, circle, square marks; width/height's `step`
     * - `2` for bar marks with discrete dimensions;
     * - `5` for bar marks with continuous dimensions;
     * - `11` for text marks.
     */
    val size : Option[CornerRadius] = None,

    val smooth : Option[Aria] = None,
    val startAngle : Option[CornerRadius] = None,

    /**
     * Default stroke color. This property has higher precedence than `config.color`. Set to
     * `null` to remove stroke.
     *
     * __Default value:__ (None)
     */
    val stroke : Option[MarkConfigFill] = None,

    val strokeCap : Option[Cap] = None,
    val strokeDash : Option[StrokeDash] = None,
    val strokeDashOffset : Option[CornerRadius] = None,
    val strokeJoin : Option[StrokeJoinUnion] = None,
    val strokeMiterLimit : Option[CornerRadius] = None,
    val strokeOffset : Option[CornerRadius] = None,
    val strokeOpacity : Option[Opacity] = None,
    val strokeWidth : Option[FontSize] = None,
    val tension : Option[CornerRadius] = None,
    val text : Option[TextUnion] = None,

    /**
     * - For arc marks, the arc length in radians if theta2 is not specified, otherwise the
     * start arc angle. (A value of 0 indicates up or “north”, increasing values proceed
     * clockwise.)
     *
     * - For text marks, polar coordinate angle in radians.
     */
    val theta : Option[CornerRadius] = None,

    /**
     * The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing
     * values proceed clockwise.
     */
    val theta2 : Option[CornerRadius] = None,

    /**
     * Default relative band position for a time unit. If set to `0`, the marks will be
     * positioned at the beginning of the time unit band step. If set to `0.5`, the marks will
     * be positioned in the middle of the time unit band step.
     */
    val timeUnitBandPosition : Option[Double] = None,

    /**
     * Default relative band size for a time unit. If set to `1`, the bandwidth of the marks
     * will be equal to the time unit band step. If set to `0.5`, bandwidth of the marks will be
     * half of the time unit band step.
     */
    val timeUnitBandSize : Option[Double] = None,

    /**
     * The tooltip text string to show upon mouse hover or an object defining which fields
     * should the tooltip be derived from.
     *
     * - If `tooltip` is `true` or `{"content": "encoding"}`, then all fields from `encoding`
     * will be used.
     * - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted
     * data point will be used.
     * - If set to `null` or `false`, then no tooltip will be used.
     *
     * See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for
     * a detailed discussion about tooltip  in Vega-Lite.
     *
     * __Default value:__ `null`
     */
    val tooltip : Option[OverlayMarkDefTooltip] = None,

    val url : Option[BackgroundUnion] = None,
    val width : Option[CornerRadius] = None,

    /**
     * X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified
     * `x2` or `width`.
     *
     * The `value` of this channel can be a number or a string `"width"` for the width of the
     * plot.
     */
    val x : Option[X] = None,

    /**
     * X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
     *
     * The `value` of this channel can be a number or a string `"width"` for the width of the
     * plot.
     */
    val x2 : Option[X] = None,

    /**
     * Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified
     * `y2` or `height`.
     *
     * The `value` of this channel can be a number or a string `"height"` for the height of the
     * plot.
     */
    val y : Option[X] = None,

    /**
     * Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
     *
     * The `value` of this channel can be a number or a string `"height"` for the height of the
     * plot.
     */
    val y2 : Option[X] = None
) derives Encoder.AsObject, Decoder

/**
 * Default configuration for all concatenation and repeat view composition operators
 * (`concat`, `hconcat`, `vconcat`, and `repeat`)
 *
 * Default configuration for the `facet` view composition operator
 */
case class CompositionConfig (
    /**
     * The number of columns to include in the view composition layout.
     *
     * __Default value__: `undefined` -- An infinite number of columns (a single row) will be
     * assumed. This is equivalent to `hconcat` (for `concat`) and to using the `column` channel
     * (for `facet` and `repeat`).
     *
     * __Note__:
     *
     * 1) This property is only for:
     * - the general (wrappable) `concat` operator (not `hconcat`/`vconcat`)
     * - the `facet` and `repeat` operator with one field/repetition definition (without
     * row/column nesting)
     *
     * 2) Setting the `columns` to `1` is equivalent to `vconcat` (for `concat`) and to using
     * the `row` channel (for `facet` and `repeat`).
     */
    val columns : Option[Double] = None,

    /**
     * The default spacing in pixels between composed sub-views.
     *
     * __Default value__: `20`
     */
    val spacing : Option[Double] = None
) derives Encoder.AsObject, Decoder

/**
 * ErrorBand Config
 */
case class ErrorBandConfig (
    val band : Option[AnyMarkConfig] = None,
    val borders : Option[AnyMarkConfig] = None,

    /**
     * The extent of the band. Available options include:
     * - `"ci"`: Extend the band to the confidence interval of the mean.
     * - `"stderr"`: The size of band are set to the value of standard error, extending from the
     * mean.
     * - `"stdev"`: The size of band are set to the value of standard deviation, extending from
     * the mean.
     * - `"iqr"`: Extend the band to the q1 and q3.
     *
     * __Default value:__ `"stderr"`.
     */
    val extent : Option[ErrorBarExtent] = None,

    /**
     * The line interpolation method for the error band. One of the following:
     * - `"linear"`: piecewise linear segments, as in a polyline.
     * - `"linear-closed"`: close the linear segments to form a polygon.
     * - `"step"`: a piecewise constant function (a step function) consisting of alternating
     * horizontal and vertical lines. The y-value changes at the midpoint of each pair of
     * adjacent x-values.
     * - `"step-before"`: a piecewise constant function (a step function) consisting of
     * alternating horizontal and vertical lines. The y-value changes before the x-value.
     * - `"step-after"`: a piecewise constant function (a step function) consisting of
     * alternating horizontal and vertical lines. The y-value changes after the x-value.
     * - `"basis"`: a B-spline, with control point duplication on the ends.
     * - `"basis-open"`: an open B-spline; may not intersect the start or end.
     * - `"basis-closed"`: a closed B-spline, as in a loop.
     * - `"cardinal"`: a Cardinal spline, with control point duplication on the ends.
     * - `"cardinal-open"`: an open Cardinal spline; may not intersect the start or end, but
     * will intersect other control points.
     * - `"cardinal-closed"`: a closed Cardinal spline, as in a loop.
     * - `"bundle"`: equivalent to basis, except the tension parameter is used to straighten the
     * spline.
     * - `"monotone"`: cubic interpolation that preserves monotonicity in y.
     */
    val interpolate : Option[Interpolate] = None,

    /**
     * The tension parameter for the interpolation type of the error band.
     */
    val tension : Option[Double] = None
) derives Encoder.AsObject, Decoder

/**
 * The extent of the band. Available options include:
 * - `"ci"`: Extend the band to the confidence interval of the mean.
 * - `"stderr"`: The size of band are set to the value of standard error, extending from the
 * mean.
 * - `"stdev"`: The size of band are set to the value of standard deviation, extending from
 * the mean.
 * - `"iqr"`: Extend the band to the q1 and q3.
 *
 * __Default value:__ `"stderr"`.
 *
 * The extent of the rule. Available options include:
 * - `"ci"`: Extend the rule to the confidence interval of the mean.
 * - `"stderr"`: The size of rule are set to the value of standard error, extending from the
 * mean.
 * - `"stdev"`: The size of rule are set to the value of standard deviation, extending from
 * the mean.
 * - `"iqr"`: Extend the rule to the q1 and q3.
 *
 * __Default value:__ `"stderr"`.
 */

enum ErrorBarExtent : 
    case ci
    case iqr
    case stderr
    case stdev
given Decoder[ErrorBarExtent] = Decoder.decodeString.emapTry(x => Try(ErrorBarExtent.valueOf(x) )) 
given Encoder[ErrorBarExtent] = Encoder.encodeString.contramap(_.toString())

/**
 * ErrorBar Config
 */
case class ErrorBarConfig (
    /**
     * The extent of the rule. Available options include:
     * - `"ci"`: Extend the rule to the confidence interval of the mean.
     * - `"stderr"`: The size of rule are set to the value of standard error, extending from the
     * mean.
     * - `"stdev"`: The size of rule are set to the value of standard deviation, extending from
     * the mean.
     * - `"iqr"`: Extend the rule to the q1 and q3.
     *
     * __Default value:__ `"stderr"`.
     */
    val extent : Option[ErrorBarExtent] = None,

    val rule : Option[AnyMarkConfig] = None,

    /**
     * Size of the ticks of an error bar
     */
    val size : Option[Double] = None,

    /**
     * Thickness of the ticks and the bar of an error bar
     */
    val thickness : Option[Double] = None,

    val ticks : Option[AnyMarkConfig] = None
) derives Encoder.AsObject, Decoder

/**
 * Defines how Vega-Lite generates title for fields. There are three possible styles:
 * - `"verbal"` (Default) - displays function in a verbal style (e.g., "Sum of field",
 * "Year-month of date", "field (binned)").
 * - `"function"` - displays function using parentheses and capitalized texts (e.g.,
 * "SUM(field)", "YEARMONTH(date)", "BIN(field)").
 * - `"plain"` - displays only the field name without functions (e.g., "field", "date",
 * "field").
 */

enum FieldTitle : 
    case functional
    case plain
    case verbal
given Decoder[FieldTitle] = Decoder.decodeString.emapTry(x => Try(FieldTitle.valueOf(x) )) 
given Encoder[FieldTitle] = Encoder.encodeString.contramap(_.toString())

/**
 * Header configuration, which determines default properties for all
 * [headers](https://vega.github.io/vega-lite/docs/header.html).
 *
 * For a full list of header configuration options, please see the [corresponding section of
 * in the header documentation](https://vega.github.io/vega-lite/docs/header.html#config).
 *
 * Header configuration, which determines default properties for column
 * [headers](https://vega.github.io/vega-lite/docs/header.html).
 *
 * For a full list of header configuration options, please see the [corresponding section of
 * in the header documentation](https://vega.github.io/vega-lite/docs/header.html#config).
 *
 * Header configuration, which determines default properties for non-row/column facet
 * [headers](https://vega.github.io/vega-lite/docs/header.html).
 *
 * For a full list of header configuration options, please see the [corresponding section of
 * in the header documentation](https://vega.github.io/vega-lite/docs/header.html#config).
 *
 * Header configuration, which determines default properties for row
 * [headers](https://vega.github.io/vega-lite/docs/header.html).
 *
 * For a full list of header configuration options, please see the [corresponding section of
 * in the header documentation](https://vega.github.io/vega-lite/docs/header.html#config).
 */
case class HeaderConfig (
    /**
     * When used with the default `"number"` and `"time"` format type, the text formatting
     * pattern for labels of guides (axes, legends, headers) and text marks.
     *
     * - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number
     * format pattern](https://github.com/d3/d3-format#locale_format).
     * - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format
     * pattern](https://github.com/d3/d3-time-format#locale_format).
     *
     * See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for
     * more examples.
     *
     * When used with a [custom
     * `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this
     * value will be passed as `format` alongside `datum.value` to the registered function.
     *
     * __Default value:__  Derived from
     * [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for
     * number format and from
     * [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time
     * format.
     */
    val format : Option[Format] = None,

    /**
     * The format type for labels. One of `"number"`, `"time"`, or a [registered custom format
     * type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).
     *
     * __Default value:__
     * - `"time"` for temporal fields and ordinal and nominal fields with `timeUnit`.
     * - `"number"` for quantitative fields as well as ordinal and nominal fields without
     * `timeUnit`.
     */
    val formatType : Option[String] = None,

    /**
     * Horizontal text alignment of header labels. One of `"left"`, `"center"`, or `"right"`.
     */
    val labelAlign : Option[TitleAlignUnion] = None,

    /**
     * The anchor position for placing the labels. One of `"start"`, `"middle"`, or `"end"`. For
     * example, with a label orientation of top these anchor positions map to a left-, center-,
     * or right-aligned label.
     */
    val labelAnchor : Option[TitleAnchorEnum] = None,

    /**
     * The rotation angle of the header labels.
     *
     * __Default value:__ `0` for column header, `-90` for row header.
     */
    val labelAngle : Option[Double] = None,

    /**
     * The vertical text baseline for the header labels. One of `"alphabetic"` (default),
     * `"top"`, `"middle"`, `"bottom"`, `"line-top"`, or `"line-bottom"`. The `"line-top"` and
     * `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated
     * relative to the `titleLineHeight` rather than `titleFontSize` alone.
     */
    val labelBaseline : Option[BackgroundUnion] = None,

    /**
     * The color of the header label, can be in hex color code or regular color name.
     */
    val labelColor : Option[BackgroundUnion] = None,

    /**
     * [Vega expression](https://vega.github.io/vega/docs/expressions/) for customizing labels.
     *
     * __Note:__ The label text and value can be assessed via the `label` and `value` properties
     * of the header's backing `datum` object.
     */
    val labelExpr : Option[String] = None,

    /**
     * The font of the header label.
     */
    val labelFont : Option[BackgroundUnion] = None,

    /**
     * The font size of the header label, in pixels.
     */
    val labelFontSize : Option[CornerRadius] = None,

    /**
     * The font style of the header label.
     */
    val labelFontStyle : Option[BackgroundUnion] = None,

    /**
     * The font weight of the header label.
     */
    val labelFontWeight : Option[FontWeightUnion] = None,

    /**
     * The maximum length of the header label in pixels. The text value will be automatically
     * truncated if the rendered size exceeds the limit.
     *
     * __Default value:__ `0`, indicating no limit
     */
    val labelLimit : Option[CornerRadius] = None,

    /**
     * Line height in pixels for multi-line header labels or title text with `"line-top"` or
     * `"line-bottom"` baseline.
     */
    val labelLineHeight : Option[CornerRadius] = None,

    /**
     * The orientation of the header label. One of `"top"`, `"bottom"`, `"left"` or `"right"`.
     */
    val labelOrient : Option[Orient] = None,

    /**
     * The padding, in pixel, between facet header's label and the plot.
     *
     * __Default value:__ `10`
     */
    val labelPadding : Option[CornerRadius] = None,

    /**
     * A boolean flag indicating if labels should be included as part of the header.
     *
     * __Default value:__ `true`.
     */
    val labels : Option[Boolean] = None,

    /**
     * Shortcut for setting both labelOrient and titleOrient.
     */
    val orient : Option[Orient] = None,

    /**
     * Set to null to disable title for the axis, legend, or header.
     */
    val title : Option[Json] = None,

    /**
     * Horizontal text alignment (to the anchor) of header titles.
     */
    val titleAlign : Option[TitleAlignUnion] = None,

    /**
     * The anchor position for placing the title. One of `"start"`, `"middle"`, or `"end"`. For
     * example, with an orientation of top these anchor positions map to a left-, center-, or
     * right-aligned title.
     */
    val titleAnchor : Option[TitleAnchorEnum] = None,

    /**
     * The rotation angle of the header title.
     *
     * __Default value:__ `0`.
     */
    val titleAngle : Option[Double] = None,

    /**
     * The vertical text baseline for the header title. One of `"alphabetic"` (default),
     * `"top"`, `"middle"`, `"bottom"`, `"line-top"`, or `"line-bottom"`. The `"line-top"` and
     * `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated
     * relative to the `titleLineHeight` rather than `titleFontSize` alone.
     *
     * __Default value:__ `"middle"`
     */
    val titleBaseline : Option[BackgroundUnion] = None,

    /**
     * Color of the header title, can be in hex color code or regular color name.
     */
    val titleColor : Option[BackgroundUnion] = None,

    /**
     * Font of the header title. (e.g., `"Helvetica Neue"`).
     */
    val titleFont : Option[BackgroundUnion] = None,

    /**
     * Font size of the header title.
     */
    val titleFontSize : Option[CornerRadius] = None,

    /**
     * The font style of the header title.
     */
    val titleFontStyle : Option[BackgroundUnion] = None,

    /**
     * Font weight of the header title. This can be either a string (e.g `"bold"`, `"normal"`)
     * or a number (`100`, `200`, `300`, ..., `900` where `"normal"` = `400` and `"bold"` =
     * `700`).
     */
    val titleFontWeight : Option[FontWeightUnion] = None,

    /**
     * The maximum length of the header title in pixels. The text value will be automatically
     * truncated if the rendered size exceeds the limit.
     *
     * __Default value:__ `0`, indicating no limit
     */
    val titleLimit : Option[CornerRadius] = None,

    /**
     * Line height in pixels for multi-line header title text or title text with `"line-top"` or
     * `"line-bottom"` baseline.
     */
    val titleLineHeight : Option[CornerRadius] = None,

    /**
     * The orientation of the header title. One of `"top"`, `"bottom"`, `"left"` or `"right"`.
     */
    val titleOrient : Option[Orient] = None,

    /**
     * The padding, in pixel, between facet header's title and the label.
     *
     * __Default value:__ `10`
     */
    val titlePadding : Option[CornerRadius] = None
) derives Encoder.AsObject, Decoder

/**
 * Legend configuration, which determines default properties for all
 * [legends](https://vega.github.io/vega-lite/docs/legend.html). For a full list of legend
 * configuration options, please see the [corresponding section of in the legend
 * documentation](https://vega.github.io/vega-lite/docs/legend.html#config).
 */
case class LegendConfig (
    val aria : Option[Aria] = None,
    val clipHeight : Option[CornerRadius] = None,
    val columnPadding : Option[CornerRadius] = None,
    val columns : Option[CornerRadius] = None,
    val cornerRadius : Option[CornerRadius] = None,
    val description : Option[BackgroundUnion] = None,

    /**
     * The direction of the legend, one of `"vertical"` or `"horizontal"`.
     *
     * __Default value:__
     * - For top-/bottom-`orient`ed legends, `"horizontal"`
     * - For left-/right-`orient`ed legends, `"vertical"`
     * - For top/bottom-left/right-`orient`ed legends, `"horizontal"` for gradient legends and
     * `"vertical"` for symbol legends.
     */
    val direction : Option[Orientation] = None,

    /**
     * Disable legend by default
     */
    val disable : Option[Boolean] = None,

    val fillColor : Option[Color] = None,
    val gradientDirection : Option[Direction] = None,

    /**
     * Max legend length for a horizontal gradient when `config.legend.gradientLength` is
     * undefined.
     *
     * __Default value:__ `200`
     */
    val gradientHorizontalMaxLength : Option[Double] = None,

    /**
     * Min legend length for a horizontal gradient when `config.legend.gradientLength` is
     * undefined.
     *
     * __Default value:__ `100`
     */
    val gradientHorizontalMinLength : Option[Double] = None,

    val gradientLabelLimit : Option[CornerRadius] = None,
    val gradientLabelOffset : Option[CornerRadius] = None,
    val gradientLength : Option[FontSize] = None,
    val gradientOpacity : Option[CornerRadius] = None,
    val gradientStrokeColor : Option[Color] = None,
    val gradientStrokeWidth : Option[FontSize] = None,
    val gradientThickness : Option[FontSize] = None,

    /**
     * Max legend length for a vertical gradient when `config.legend.gradientLength` is
     * undefined.
     *
     * __Default value:__ `200`
     */
    val gradientVerticalMaxLength : Option[Double] = None,

    /**
     * Min legend length for a vertical gradient when `config.legend.gradientLength` is
     * undefined.
     *
     * __Default value:__ `100`
     */
    val gradientVerticalMinLength : Option[Double] = None,

    val gridAlign : Option[GridAlign] = None,
    val labelAlign : Option[TitleAlignUnion] = None,
    val labelBaseline : Option[BackgroundUnion] = None,
    val labelColor : Option[Color] = None,
    val labelFont : Option[BackgroundUnion] = None,
    val labelFontSize : Option[FontSize] = None,
    val labelFontStyle : Option[BackgroundUnion] = None,
    val labelFontWeight : Option[FontWeightUnion] = None,
    val labelLimit : Option[CornerRadius] = None,
    val labelOffset : Option[FontSize] = None,
    val labelOpacity : Option[CornerRadius] = None,

    /**
     * The strategy to use for resolving overlap of labels in gradient legends. If `false`, no
     * overlap reduction is attempted. If set to `true` or `"parity"`, a strategy of removing
     * every other label is used. If set to `"greedy"`, a linear scan of the labels is
     * performed, removing any label that overlaps with the last visible label (this often works
     * better for log-scaled axes).
     *
     * __Default value:__ `"greedy"` for `log scales otherwise `true`.
     */
    val labelOverlap : Option[LabelOverlap] = None,

    val labelPadding : Option[CornerRadius] = None,
    val labelSeparation : Option[CornerRadius] = None,
    val layout : Option[BackgroundExprRef] = None,
    val legendX : Option[CornerRadius] = None,
    val legendY : Option[CornerRadius] = None,
    val offset : Option[CornerRadius] = None,

    /**
     * The orientation of the legend, which determines how the legend is positioned within the
     * scene. One of `"left"`, `"right"`, `"top"`, `"bottom"`, `"top-left"`, `"top-right"`,
     * `"bottom-left"`, `"bottom-right"`, `"none"`.
     *
     * __Default value:__ `"right"`
     */
    val orient : Option[LegendOrient] = None,

    val padding : Option[CornerRadius] = None,
    val rowPadding : Option[CornerRadius] = None,
    val strokeColor : Option[Color] = None,
    val strokeDash : Option[StrokeDash] = None,
    val strokeWidth : Option[CornerRadius] = None,
    val symbolBaseFillColor : Option[Color] = None,
    val symbolBaseStrokeColor : Option[Color] = None,
    val symbolDash : Option[StrokeDash] = None,
    val symbolDashOffset : Option[CornerRadius] = None,
    val symbolDirection : Option[Direction] = None,
    val symbolFillColor : Option[Color] = None,
    val symbolLimit : Option[CornerRadius] = None,
    val symbolOffset : Option[CornerRadius] = None,
    val symbolOpacity : Option[CornerRadius] = None,
    val symbolSize : Option[FontSize] = None,
    val symbolStrokeColor : Option[Color] = None,
    val symbolStrokeWidth : Option[FontSize] = None,
    val symbolType : Option[BackgroundUnion] = None,
    val tickCount : Option[TickCount] = None,

    /**
     * Set to null to disable title for the axis, legend, or header.
     */
    val title : Option[Json] = None,

    val titleAlign : Option[TitleAlignUnion] = None,
    val titleAnchor : Option[TitleAnchorUnion] = None,
    val titleBaseline : Option[BackgroundUnion] = None,
    val titleColor : Option[Color] = None,
    val titleFont : Option[BackgroundUnion] = None,
    val titleFontSize : Option[CornerRadius] = None,
    val titleFontStyle : Option[BackgroundUnion] = None,
    val titleFontWeight : Option[FontWeightUnion] = None,
    val titleLimit : Option[FontSize] = None,
    val titleLineHeight : Option[CornerRadius] = None,
    val titleOpacity : Option[CornerRadius] = None,
    val titleOrient : Option[TitleOrientUnion] = None,
    val titlePadding : Option[CornerRadius] = None,

    /**
     * The opacity of unselected legend entries.
     *
     * __Default value:__ 0.35.
     */
    val unselectedOpacity : Option[Double] = None,

    val zindex : Option[FontSize] = None
) derives Encoder.AsObject, Decoder

type Direction = BackgroundExprRef | Orientation
given Decoder[Direction] = {
    List[Decoder[Direction]](
        Decoder[BackgroundExprRef].widen,
        Decoder[Orientation].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Direction] = Encoder.instance {
    case enc0 : BackgroundExprRef => Encoder.AsObject[BackgroundExprRef].apply(enc0)
    case enc1 : Orientation => summon[Encoder[Orientation]].apply(enc1)
}

/**
 * Line-Specific Config
 *
 * Trail-Specific Config
 */
case class LineConfig (
    /**
     * The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One
     * of `"left"`, `"right"`, `"center"`.
     *
     * __Note:__ Expression reference is *not* supported for range marks.
     */
    val align : Option[TitleAlignUnion] = None,

    val angle : Option[Angle] = None,
    val aria : Option[Aria] = None,
    val ariaRole : Option[BackgroundUnion] = None,
    val ariaRoleDescription : Option[BackgroundUnion] = None,
    val aspect : Option[Aria] = None,

    /**
     * For text marks, the vertical text baseline. One of `"alphabetic"` (default), `"top"`,
     * `"middle"`, `"bottom"`, `"line-top"`, `"line-bottom"`, or an expression reference that
     * provides one of the valid values. The `"line-top"` and `"line-bottom"` values operate
     * similarly to `"top"` and `"bottom"`, but are calculated relative to the `lineHeight`
     * rather than `fontSize` alone.
     *
     * For range marks, the vertical alignment of the marks. One of `"top"`, `"middle"`,
     * `"bottom"`.
     *
     * __Note:__ Expression reference is *not* supported for range marks.
     */
    val baseline : Option[BackgroundUnion] = None,

    val blend : Option[BlendUnion] = None,

    /**
     * Default color.
     *
     * __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
     *
     * __Note:__
     * - This property cannot be used in a [style
     * config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
     * - The `fill` and `stroke` properties have higher precedence than `color` and will
     * override `color`.
     */
    val color : Option[MarkConfigColor] = None,

    val cornerRadius : Option[CornerRadius] = None,
    val cornerRadiusBottomLeft : Option[CornerRadius] = None,
    val cornerRadiusBottomRight : Option[CornerRadius] = None,
    val cornerRadiusTopLeft : Option[CornerRadius] = None,
    val cornerRadiusTopRight : Option[CornerRadius] = None,
    val cursor : Option[CursorUnion] = None,
    val description : Option[BackgroundUnion] = None,
    val dir : Option[Dir] = None,
    val dx : Option[CornerRadius] = None,
    val dy : Option[CornerRadius] = None,
    val ellipsis : Option[BackgroundUnion] = None,
    val endAngle : Option[CornerRadius] = None,

    /**
     * Default fill color. This property has higher precedence than `config.color`. Set to
     * `null` to remove fill.
     *
     * __Default value:__ (None)
     */
    val fill : Option[MarkConfigFill] = None,

    /**
     * Whether the mark's color should be used as fill color instead of stroke color.
     *
     * __Default value:__ `false` for all `point`, `line`, and `rule` marks as well as
     * `geoshape` marks for
     * [`graticule`](https://vega.github.io/vega-lite/docs/data.html#graticule) data sources;
     * otherwise, `true`.
     *
     * __Note:__ This property cannot be used in a [style
     * config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
     */
    val filled : Option[Boolean] = None,

    val fillOpacity : Option[Opacity] = None,
    val font : Option[BackgroundUnion] = None,
    val fontSize : Option[FontSize] = None,
    val fontStyle : Option[BackgroundUnion] = None,
    val fontWeight : Option[FontWeightUnion] = None,
    val height : Option[CornerRadius] = None,
    val href : Option[BackgroundUnion] = None,

    /**
     * The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`.
     *
     * __Default value:__ `0`
     */
    val innerRadius : Option[CornerRadius] = None,

    val interpolate : Option[MarkConfigInterpolate] = None,

    /**
     * Defines how Vega-Lite should handle marks for invalid values (`null` and `NaN`).
     * - If set to `"filter"` (default), all data items with null values will be skipped (for
     * line, trail, and area marks) or filtered (for other marks).
     * - If `null`, all data items are included. In this case, invalid values will be
     * interpreted as zeroes.
     */
    val invalid : Option[Invalid] = None,

    val limit : Option[CornerRadius] = None,
    val lineBreak : Option[BackgroundUnion] = None,
    val lineHeight : Option[CornerRadius] = None,

    /**
     * The overall opacity (value between [0,1]).
     *
     * __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or
     * `square` marks or layered `bar` charts and `1` otherwise.
     */
    val opacity : Option[CornerRadius] = None,

    /**
     * For line and trail marks, this `order` property can be set to `null` or `false` to make
     * the lines use the original order in the data sources.
     */
    val order : Option[Boolean] = None,

    /**
     * The orientation of a non-stacked bar, tick, area, and line charts. The value is either
     * horizontal (default) or vertical.
     * - For bar, rule and tick, this determines whether the size of the bar and tick should be
     * applied to x or y dimension.
     * - For area, this property determines the orient property of the Vega output.
     * - For line and trail marks, this property determines the sort order of the points in the
     * line if `config.sortLineBy` is not specified. For stacked charts, this is always
     * determined by the orientation of the stack; therefore explicitly specified value will be
     * ignored.
     */
    val orient : Option[Orientation] = None,

    /**
     * The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`.
     *
     * __Default value:__ `0`
     */
    val outerRadius : Option[CornerRadius] = None,

    val padAngle : Option[CornerRadius] = None,

    /**
     * A flag for overlaying points on top of line or area marks, or an object defining the
     * properties of the overlayed points.
     *
     * - If this property is `"transparent"`, transparent points will be used (for enhancing
     * tooltips and selections).
     *
     * - If this property is an empty object (`{}`) or `true`, filled points with default
     * properties will be used.
     *
     * - If this property is `false`, no points would be automatically added to line or area
     * marks.
     *
     * __Default value:__ `false`.
     */
    val point : Option[Point] = None,

    /**
     * For arc mark, the primary (outer) radius in pixels.
     *
     * For text marks, polar coordinate radial offset, in pixels, of the text from the origin
     * determined by the `x` and `y` properties.
     *
     * __Default value:__ `min(plot_width, plot_height)/2`
     */
    val radius : Option[CornerRadius] = None,

    /**
     * The secondary (inner) radius in pixels of arc marks.
     *
     * __Default value:__ `0`
     */
    val radius2 : Option[CornerRadius] = None,

    val shape : Option[BackgroundUnion] = None,

    /**
     * Default size for marks.
     * - For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that
     * this value sets the area of the symbol; the side lengths will increase with the square
     * root of this value.
     * - For `bar`, this represents the band size of the bar, in pixels.
     * - For `text`, this represents the font size, in pixels.
     *
     * __Default value:__
     * - `30` for point, circle, square marks; width/height's `step`
     * - `2` for bar marks with discrete dimensions;
     * - `5` for bar marks with continuous dimensions;
     * - `11` for text marks.
     */
    val size : Option[CornerRadius] = None,

    val smooth : Option[Aria] = None,
    val startAngle : Option[CornerRadius] = None,

    /**
     * Default stroke color. This property has higher precedence than `config.color`. Set to
     * `null` to remove stroke.
     *
     * __Default value:__ (None)
     */
    val stroke : Option[MarkConfigFill] = None,

    val strokeCap : Option[Cap] = None,
    val strokeDash : Option[StrokeDash] = None,
    val strokeDashOffset : Option[CornerRadius] = None,
    val strokeJoin : Option[StrokeJoinUnion] = None,
    val strokeMiterLimit : Option[CornerRadius] = None,
    val strokeOffset : Option[CornerRadius] = None,
    val strokeOpacity : Option[Opacity] = None,
    val strokeWidth : Option[FontSize] = None,
    val tension : Option[CornerRadius] = None,
    val text : Option[TextUnion] = None,

    /**
     * - For arc marks, the arc length in radians if theta2 is not specified, otherwise the
     * start arc angle. (A value of 0 indicates up or “north”, increasing values proceed
     * clockwise.)
     *
     * - For text marks, polar coordinate angle in radians.
     */
    val theta : Option[CornerRadius] = None,

    /**
     * The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing
     * values proceed clockwise.
     */
    val theta2 : Option[CornerRadius] = None,

    /**
     * Default relative band position for a time unit. If set to `0`, the marks will be
     * positioned at the beginning of the time unit band step. If set to `0.5`, the marks will
     * be positioned in the middle of the time unit band step.
     */
    val timeUnitBandPosition : Option[Double] = None,

    /**
     * Default relative band size for a time unit. If set to `1`, the bandwidth of the marks
     * will be equal to the time unit band step. If set to `0.5`, bandwidth of the marks will be
     * half of the time unit band step.
     */
    val timeUnitBandSize : Option[Double] = None,

    /**
     * The tooltip text string to show upon mouse hover or an object defining which fields
     * should the tooltip be derived from.
     *
     * - If `tooltip` is `true` or `{"content": "encoding"}`, then all fields from `encoding`
     * will be used.
     * - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted
     * data point will be used.
     * - If set to `null` or `false`, then no tooltip will be used.
     *
     * See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for
     * a detailed discussion about tooltip  in Vega-Lite.
     *
     * __Default value:__ `null`
     */
    val tooltip : Option[OverlayMarkDefTooltip] = None,

    val url : Option[BackgroundUnion] = None,
    val width : Option[CornerRadius] = None,

    /**
     * X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified
     * `x2` or `width`.
     *
     * The `value` of this channel can be a number or a string `"width"` for the width of the
     * plot.
     */
    val x : Option[X] = None,

    /**
     * X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
     *
     * The `value` of this channel can be a number or a string `"width"` for the width of the
     * plot.
     */
    val x2 : Option[X] = None,

    /**
     * Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified
     * `y2` or `height`.
     *
     * The `value` of this channel can be a number or a string `"height"` for the height of the
     * plot.
     */
    val y : Option[X] = None,

    /**
     * Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
     *
     * The `value` of this channel can be a number or a string `"height"` for the height of the
     * plot.
     */
    val y2 : Option[X] = None
) derives Encoder.AsObject, Decoder

/**
 * Locale definitions for string parsing and formatting of number and date values. The
 * locale object should contain `number` and/or `time` properties with [locale
 * definitions](https://vega.github.io/vega/docs/api/locale/). Locale definitions provided
 * in the config block may be overridden by the View constructor locale option.
 */
case class Locale (
    val number : Option[NumberLocale] = None,
    val time : Option[TimeLocale] = None
) derives Encoder.AsObject, Decoder

/**
 * Locale definition for formatting numbers.
 */
case class NumberLocale (
    /**
     * The currency prefix and suffix (e.g., ["$", ""]).
     */
    val currency : Seq[String],

    /**
     * The decimal point (e.g., ".").
     */
    val decimal : String,

    /**
     * The array of group sizes (e.g., [3]), cycled as needed.
     */
    val grouping : Seq[Double],

    /**
     * The minus sign (defaults to hyphen-minus, "-").
     */
    val minus : Option[String] = None,

    /**
     * The not-a-number value (defaults to "NaN").
     */
    val nan : Option[String] = None,

    /**
     * An array of ten strings to replace the numerals 0-9.
     */
    val numerals : Option[Seq[String]] = None,

    /**
     * The percent sign (defaults to "%").
     */
    val percent : Option[String] = None,

    /**
     * The group separator (e.g., ",").
     */
    val thousands : String
) derives Encoder.AsObject, Decoder

/**
 * Locale definition for formatting dates and times.
 */
case class TimeLocale (
    /**
     * The date (%x) format specifier (e.g., "%m/%d/%Y").
     */
    val date : String,

    /**
     * The date and time (%c) format specifier (e.g., "%a %b %e %X %Y").
     */
    val dateTime : String,

    /**
     * The full names of the weekdays, starting with Sunday.
     */
    val days : Seq[String],

    /**
     * The full names of the months (starting with January).
     */
    val months : Seq[String],

    /**
     * The A.M. and P.M. equivalents (e.g., ["AM", "PM"]).
     */
    val periods : Seq[String],

    /**
     * The abbreviated names of the weekdays, starting with Sunday.
     */
    val shortDays : Seq[String],

    /**
     * The abbreviated names of the months (starting with January).
     */
    val shortMonths : Seq[String],

    /**
     * The time (%X) format specifier (e.g., "%H:%M:%S").
     */
    val time : String
) derives Encoder.AsObject, Decoder

/**
 * The default visualization padding, in pixels, from the edge of the visualization canvas
 * to the data rectangle. If a number, specifies padding for all sides. If an object, the
 * value should have the format `{"left": 5, "top": 5, "right": 5, "bottom": 5}` to specify
 * padding for each side of the visualization.
 *
 * __Default value__: `5`
 */
type Padding = Double | MagentaExprRef
given Decoder[Padding] = {
    List[Decoder[Padding]](
        Decoder[Double].widen,
        Decoder[MagentaExprRef].widen,
    ).reduceLeft(_ or _)
}

given Encoder[Padding] = Encoder.instance {
    case enc0 : Double => Encoder.encodeDouble(enc0)
    case enc1 : MagentaExprRef => Encoder.AsObject[MagentaExprRef].apply(enc1)
}

case class MagentaExprRef (
    val bottom : Option[Double] = None,
    val left : Option[Double] = None,
    val right : Option[Double] = None,
    val top : Option[Double] = None,

    /**
     * Vega expression (which can refer to Vega-Lite parameters).
     */
    val expr : Option[String] = None
) derives Encoder.AsObject, Decoder

case class TopLevelParameter (
    /**
     * Binds the parameter to an external input element such as a slider, selection list or
     * radio button group.
     *
     * When set, a selection is populated by input elements (also known as dynamic query
     * widgets) or by interacting with the corresponding legend. Direct manipulation interaction
     * is disabled by default; to re-enable it, set the selection's
     * [`on`](https://vega.github.io/vega-lite/docs/selection.html#common-selection-properties)
     * property.
     *
     * Legend bindings are restricted to selections that only specify a single field or
     * encoding.
     *
     * Query widget binding takes the form of Vega's [input element binding
     * definition](https://vega.github.io/vega/docs/signals/#bind) or can be a mapping between
     * projected field/encodings and binding definitions.
     *
     * __See also:__ [`bind`](https://vega.github.io/vega-lite/docs/bind.html) documentation.
     */
    val bind : Option[TopLevelParameterBind] = None,

    /**
     * An expression for the value of the parameter. This expression may include other
     * parameters, in which case the parameter will automatically update in response to upstream
     * parameter changes.
     */
    val expr : Option[String] = None,

    /**
     * A unique name for the variable parameter. Parameter names should be valid JavaScript
     * identifiers: they should contain only alphanumeric characters (or "$", or "_") and may
     * not start with a digit. Reserved keywords that may not be used as parameter names are
     * "datum", "event", "item", and "parent".
     *
     * Required. A unique name for the selection parameter. Selection names should be valid
     * JavaScript identifiers: they should contain only alphanumeric characters (or "$", or "_")
     * and may not start with a digit. Reserved keywords that may not be used as parameter names
     * are "datum", "event", "item", and "parent".
     */
    val name : String,

    /**
     * The [initial value](http://vega.github.io/vega-lite/docs/value.html) of the parameter.
     *
     * __Default value:__ `undefined`
     *
     * Initialize the selection with a mapping between [projected channels or field
     * names](https://vega.github.io/vega-lite/docs/selection.html#project) and initial values.
     *
     * __See also:__ [`init`](https://vega.github.io/vega-lite/docs/value.html) documentation.
     */
    val value : Option[Json] = None,

    /**
     * Determines the default event processing and data query for the selection. Vega-Lite
     * currently supports two selection types:
     *
     * - `"point"` -- to select multiple discrete data values; the first value is selected on
     * `click` and additional values toggled on shift-click.
     * - `"interval"` -- to select a continuous range of data values on `drag`.
     */
    val select : Option[Select] = None,

    /**
     * By default, top-level selections are applied to every view in the visualization. If this
     * property is specified, selections will only be applied to views with the given names.
     */
    val views : Option[Seq[String]] = None
) derives Encoder.AsObject, Decoder

type TopLevelParameterBind = String | Map[String, BindingValue]
given Decoder[TopLevelParameterBind] = {
    List[Decoder[TopLevelParameterBind]](
        Decoder[String].widen,
        Decoder[Map[String, BindingValue]].widen,
    ).reduceLeft(_ or _)
}

given Encoder[TopLevelParameterBind] = Encoder.instance {
    case enc0 : String => Encoder.encodeString(enc0)
    case enc1 : Map[String, BindingValue] => Encoder.encodeMap[String,BindingValue].apply(enc1)
}

type BindingValue = Seq[Option[Json]] | BindingBinding | Double | String
given Decoder[BindingValue] = {
    List[Decoder[BindingValue]](
        Decoder[Seq[Option[Json]]].widen,
        Decoder[BindingBinding].widen,
        Decoder[Double].widen,
        Decoder[String].widen,
    ).reduceLeft(_ or _)
}

given Encoder[BindingValue] = Encoder.instance {
    case enc0 : Seq[Option[Json]] => Encoder.encodeSeq[Option[Json]].apply(enc0)
    case enc1 : BindingBinding => Encoder.AsObject[BindingBinding].apply(enc1)
    case enc2 : Double => Encoder.encodeDouble(enc2)
    case enc3 : String => Encoder.encodeString(enc3)
}

/**
 * Binds the parameter to an external input element such as a slider, selection list or
 * radio button group.
 */
case class BindingBinding (
    /**
     * If defined, delays event handling until the specified milliseconds have elapsed since the
     * last event was fired.
     */
    val debounce : Option[Double] = None,

    /**
     * An optional CSS selector string indicating the parent element to which the input element
     * should be added. By default, all input elements are added within the parent container of
     * the Vega view.
     *
     * An input element that exposes a _value_ property and supports the
     * [EventTarget](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget) interface, or
     * a CSS selector string to such an element. When the element updates and dispatches an
     * event, the _value_ property will be used as the new, bound signal value. When the signal
     * updates independent of the element, the _value_ property will be set to the signal value
     * and a new event will be dispatched on the element.
     */
    val element : Option[ElementUnion] = None,

    /**
     * The type of input element to use. The valid values are `"checkbox"`, `"radio"`,
     * `"range"`, `"select"`, and any other legal [HTML form input
     * type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input).
     */
    val input : Option[String] = None,

    /**
     * By default, the signal name is used to label input elements. This `name` property can be
     * used instead to specify a custom label for the bound signal.
     */
    val name : Option[String] = None,

    /**
     * An array of label strings to represent the `options` values. If unspecified, the
     * `options` value will be coerced to a string and used as the label.
     */
    val labels : Option[Seq[String]] = None,

    /**
     * An array of options to select from.
     */
    val options : Option[Seq[Option[Json]]] = None,

    /**
     * Sets the maximum slider value. Defaults to the larger of the signal value and `100`.
     */
    val max : Option[Double] = None,

    /**
     * Sets the minimum slider value. Defaults to the smaller of the signal value and `0`.
     */
    val min : Option[Double] = None,

    /**
     * Sets the minimum slider increment. If undefined, the step size will be automatically
     * determined based on the `min` and `max` values.
     */
    val step : Option[Double] = None,

    /**
     * A hint for form autofill. See the [HTML autocomplete
     * attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete) for
     * additional information.
     */
    val autocomplete : Option[String] = None,

    /**
     * Text that appears in the form control when it has no value set.
     */
    val placeholder : Option[String] = None,

    /**
     * The event (default `"input"`) to listen for to track changes on the external element.
     */
    val event : Option[String] = None,

    val between : Option[Seq[Stream]] = None,
    val consume : Option[Boolean] = None,
    val filter : Option[Text] = None,
    val markname : Option[String] = None,
    val marktype : Option[MarkType] = None,
    val source : Option[String] = None,
    val throttle : Option[Double] = None,
    val `type` : Option[String] = None,
    val stream : Option[Stream] = None,
    val merge : Option[Seq[Stream]] = None
) derives Encoder.AsObject, Decoder

type RangeValue = Seq[Option[Json]] | RangeEnum | RangeClass
given Decoder[RangeValue] = {
    List[Decoder[RangeValue]](
        Decoder[Seq[Option[Json]]].widen,
        Decoder[RangeEnum].widen,
        Decoder[RangeClass].widen,
    ).reduceLeft(_ or _)
}

given Encoder[RangeValue] = Encoder.instance {
    case enc0 : Seq[Option[Json]] => Encoder.encodeSeq[Option[Json]].apply(enc0)
    case enc1 : RangeEnum => summon[Encoder[RangeEnum]].apply(enc1)
    case enc2 : RangeClass => Encoder.AsObject[RangeClass].apply(enc2)
}

case class RangeClass (
    val count : Option[Double] = None,
    val extent : Option[Seq[Double]] = None,
    val scheme : Text
) derives Encoder.AsObject, Decoder

/**
 * Scale configuration determines default properties for all
 * [scales](https://vega.github.io/vega-lite/docs/scale.html). For a full list of scale
 * configuration options, please see the [corresponding section of the scale
 * documentation](https://vega.github.io/vega-lite/docs/scale.html#config).
 */
case class ScaleConfig (
    /**
     * Default inner padding for `x` and `y` band scales.
     *
     * __Default value:__
     * - `nestedOffsetPaddingInner` for x/y scales with nested x/y offset scales.
     * - `barBandPaddingInner` for bar marks (`0.1` by default)
     * - `rectBandPaddingInner` for rect and other marks (`0` by default)
     */
    val bandPaddingInner : Option[CornerRadius] = None,

    /**
     * Default outer padding for `x` and `y` band scales.
     *
     * __Default value:__ `paddingInner/2` (which makes _width/height = number of unique values
     * * step_)
     */
    val bandPaddingOuter : Option[CornerRadius] = None,

    /**
     * Default inner padding for `x` and `y` band scales with nested `xOffset` and `yOffset`
     * encoding.
     *
     * __Default value:__ `0.2`
     */
    val bandWithNestedOffsetPaddingInner : Option[CornerRadius] = None,

    /**
     * Default outer padding for `x` and `y` band scales with nested `xOffset` and `yOffset`
     * encoding.
     *
     * __Default value:__ `0.2`
     */
    val bandWithNestedOffsetPaddingOuter : Option[CornerRadius] = None,

    /**
     * Default inner padding for `x` and `y` band-ordinal scales of `"bar"` marks.
     *
     * __Default value:__ `0.1`
     */
    val barBandPaddingInner : Option[CornerRadius] = None,

    /**
     * If true, values that exceed the data domain are clamped to either the minimum or maximum
     * range value
     */
    val clamp : Option[Aria] = None,

    /**
     * Default padding for continuous x/y scales.
     *
     * __Default:__ The bar width for continuous x-scale of a vertical bar and continuous
     * y-scale of a horizontal bar.; `0` otherwise.
     */
    val continuousPadding : Option[CornerRadius] = None,

    /**
     * The default max value for mapping quantitative fields to bar's size/bandSize.
     *
     * If undefined (default), we will use the axis's size (width or height) - 1.
     */
    val maxBandSize : Option[Double] = None,

    /**
     * The default max value for mapping quantitative fields to text's size/fontSize.
     *
     * __Default value:__ `40`
     */
    val maxFontSize : Option[Double] = None,

    /**
     * Default max opacity for mapping a field to opacity.
     *
     * __Default value:__ `0.8`
     */
    val maxOpacity : Option[Double] = None,

    /**
     * Default max value for point size scale.
     */
    val maxSize : Option[Double] = None,

    /**
     * Default max strokeWidth for the scale of strokeWidth for rule and line marks and of size
     * for trail marks.
     *
     * __Default value:__ `4`
     */
    val maxStrokeWidth : Option[Double] = None,

    /**
     * The default min value for mapping quantitative fields to bar and tick's size/bandSize
     * scale with zero=false.
     *
     * __Default value:__ `2`
     */
    val minBandSize : Option[Double] = None,

    /**
     * The default min value for mapping quantitative fields to tick's size/fontSize scale with
     * zero=false
     *
     * __Default value:__ `8`
     */
    val minFontSize : Option[Double] = None,

    /**
     * Default minimum opacity for mapping a field to opacity.
     *
     * __Default value:__ `0.3`
     */
    val minOpacity : Option[Double] = None,

    /**
     * Default minimum value for point size scale with zero=false.
     *
     * __Default value:__ `9`
     */
    val minSize : Option[Double] = None,

    /**
     * Default minimum strokeWidth for the scale of strokeWidth for rule and line marks and of
     * size for trail marks with zero=false.
     *
     * __Default value:__ `1`
     */
    val minStrokeWidth : Option[Double] = None,

    /**
     * Default padding inner for xOffset/yOffset's band scales.
     *
     * __Default Value:__ `0`
     */
    val offsetBandPaddingInner : Option[CornerRadius] = None,

    /**
     * Default padding outer for xOffset/yOffset's band scales.
     *
     * __Default Value:__ `0`
     */
    val offsetBandPaddingOuter : Option[CornerRadius] = None,

    /**
     * Default outer padding for `x` and `y` point-ordinal scales.
     *
     * __Default value:__ `0.5` (which makes _width/height = number of unique values * step_)
     */
    val pointPadding : Option[CornerRadius] = None,

    /**
     * Default range cardinality for
     * [`quantile`](https://vega.github.io/vega-lite/docs/scale.html#quantile) scale.
     *
     * __Default value:__ `4`
     */
    val quantileCount : Option[Double] = None,

    /**
     * Default range cardinality for
     * [`quantize`](https://vega.github.io/vega-lite/docs/scale.html#quantize) scale.
     *
     * __Default value:__ `4`
     */
    val quantizeCount : Option[Double] = None,

    /**
     * Default inner padding for `x` and `y` band-ordinal scales of `"rect"` marks.
     *
     * __Default value:__ `0`
     */
    val rectBandPaddingInner : Option[CornerRadius] = None,

    /**
     * If true, rounds numeric output values to integers. This can be helpful for snapping to
     * the pixel grid. (Only available for `x`, `y`, and `size` scales.)
     */
    val round : Option[Aria] = None,

    /**
     * Use the source data range before aggregation as scale domain instead of aggregated data
     * for aggregate axis.
     *
     * This is equivalent to setting `domain` to `"unaggregate"` for aggregated _quantitative_
     * fields by default.
     *
     * This property only works with aggregate functions that produce values within the raw data
     * domain (`"mean"`, `"average"`, `"median"`, `"q1"`, `"q3"`, `"min"`, `"max"`). For other
     * aggregations that produce values outside of the raw data domain (e.g. `"count"`,
     * `"sum"`), this property is ignored.
     *
     * __Default value:__ `false`
     */
    val useUnaggregatedDomain : Option[Boolean] = None,

    /**
     * Reverse x-scale by default (useful for right-to-left charts).
     */
    val xReverse : Option[Aria] = None,

    /**
     * Default `scale.zero` for
     * [`continuous`](https://vega.github.io/vega-lite/docs/scale.html#continuous) scales except
     * for (1) x/y-scales of non-ranged bar or area charts and (2) size scales.
     *
     * __Default value:__ `true`
     */
    val zero : Option[Boolean] = None
) derives Encoder.AsObject, Decoder

/**
 * An object hash for defining default properties for each type of selections.
 */
case class SelectionClass (
    /**
     * The default definition for an
     * [`interval`](https://vega.github.io/vega-lite/docs/parameter.html#select) selection. All
     * properties and transformations for an interval selection definition (except `type`) may
     * be specified here.
     *
     * For instance, setting `interval` to `{"translate": false}` disables the ability to move
     * interval selections by default.
     */
    val interval : Option[IntervalSelectionConfigWithoutType] = None,

    /**
     * The default definition for a
     * [`point`](https://vega.github.io/vega-lite/docs/parameter.html#select) selection. All
     * properties and transformations  for a point selection definition (except `type`) may be
     * specified here.
     *
     * For instance, setting `point` to `{"on": "dblclick"}` populates point selections on
     * double-click by default.
     */
    val point : Option[PointSelectionConfigWithoutType] = None
) derives Encoder.AsObject, Decoder

/**
 * The default definition for an
 * [`interval`](https://vega.github.io/vega-lite/docs/parameter.html#select) selection. All
 * properties and transformations for an interval selection definition (except `type`) may
 * be specified here.
 *
 * For instance, setting `interval` to `{"translate": false}` disables the ability to move
 * interval selections by default.
 */
case class IntervalSelectionConfigWithoutType (
    /**
     * Clears the selection, emptying it of all values. This property can be a [Event
     * Stream](https://vega.github.io/vega/docs/event-streams/) or `false` to disable clear.
     *
     * __Default value:__ `dblclick`.
     *
     * __See also:__ [`clear` examples
     * ](https://vega.github.io/vega-lite/docs/selection.html#clear) in the documentation.
     */
    val clear : Option[ClearUnion] = None,

    /**
     * An array of encoding channels. The corresponding data field values must match for a data
     * tuple to fall within the selection.
     *
     * __See also:__ The [projection with `encodings` and `fields`
     * section](https://vega.github.io/vega-lite/docs/selection.html#project) in the
     * documentation.
     */
    val encodings : Option[Seq[SingleDefUnitChannel]] = None,

    /**
     * An interval selection also adds a rectangle mark to depict the extents of the interval.
     * The `mark` property can be used to customize the appearance of the mark.
     *
     * __See also:__ [`mark`
     * examples](https://vega.github.io/vega-lite/docs/selection.html#mark) in the documentation.
     */
    val mark : Option[BrushConfig] = None,

    /**
     * A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or
     * selector) that triggers the selection. For interval selections, the event stream must
     * specify a [start and
     * end](https://vega.github.io/vega/docs/event-streams/#between-filters).
     *
     * __See also:__ [`on` examples](https://vega.github.io/vega-lite/docs/selection.html#on) in
     * the documentation.
     */
    val on : Option[OnUnion] = None,

    /**
     * With layered and multi-view displays, a strategy that determines how selections' data
     * queries are resolved when applied in a filter transform, conditional encoding rule, or
     * scale domain.
     *
     * One of:
     * - `"global"` -- only one brush exists for the entire SPLOM. When the user begins to drag,
     * any previous brushes are cleared, and a new one is constructed.
     * - `"union"` -- each cell contains its own brush, and points are highlighted if they lie
     * within _any_ of these individual brushes.
     * - `"intersect"` -- each cell contains its own brush, and points are highlighted only if
     * they fall within _all_ of these individual brushes.
     *
     * __Default value:__ `global`.
     *
     * __See also:__ [`resolve`
     * examples](https://vega.github.io/vega-lite/docs/selection.html#resolve) in the
     * documentation.
     */
    val resolve : Option[SelectionResolution] = None,

    /**
     * When truthy, allows a user to interactively move an interval selection back-and-forth.
     * Can be `true`, `false` (to disable panning), or a [Vega event stream
     * definition](https://vega.github.io/vega/docs/event-streams/) which must include a start
     * and end event to trigger continuous panning. Discrete panning (e.g., pressing the
     * left/right arrow keys) will be supported in future versions.
     *
     * __Default value:__ `true`, which corresponds to `[mousedown, window:mouseup] >
     * window:mousemove!`. This default allows users to clicks and drags within an interval
     * selection to reposition it.
     *
     * __See also:__ [`translate`
     * examples](https://vega.github.io/vega-lite/docs/selection.html#translate) in the
     * documentation.
     */
    val translate : Option[Toggle] = None,

    /**
     * When truthy, allows a user to interactively resize an interval selection. Can be `true`,
     * `false` (to disable zooming), or a [Vega event stream
     * definition](https://vega.github.io/vega/docs/event-streams/). Currently, only `wheel`
     * events are supported, but custom event streams can still be used to specify filters,
     * debouncing, and throttling. Future versions will expand the set of events that can
     * trigger this transformation.
     *
     * __Default value:__ `true`, which corresponds to `wheel!`. This default allows users to
     * use the mouse wheel to resize an interval selection.
     *
     * __See also:__ [`zoom`
     * examples](https://vega.github.io/vega-lite/docs/selection.html#zoom) in the documentation.
     */
    val zoom : Option[Toggle] = None
) derives Encoder.AsObject, Decoder

/**
 * The default definition for a
 * [`point`](https://vega.github.io/vega-lite/docs/parameter.html#select) selection. All
 * properties and transformations  for a point selection definition (except `type`) may be
 * specified here.
 *
 * For instance, setting `point` to `{"on": "dblclick"}` populates point selections on
 * double-click by default.
 */
case class PointSelectionConfigWithoutType (
    /**
     * Clears the selection, emptying it of all values. This property can be a [Event
     * Stream](https://vega.github.io/vega/docs/event-streams/) or `false` to disable clear.
     *
     * __Default value:__ `dblclick`.
     *
     * __See also:__ [`clear` examples
     * ](https://vega.github.io/vega-lite/docs/selection.html#clear) in the documentation.
     */
    val clear : Option[ClearUnion] = None,

    /**
     * An array of encoding channels. The corresponding data field values must match for a data
     * tuple to fall within the selection.
     *
     * __See also:__ The [projection with `encodings` and `fields`
     * section](https://vega.github.io/vega-lite/docs/selection.html#project) in the
     * documentation.
     */
    val encodings : Option[Seq[SingleDefUnitChannel]] = None,

    /**
     * An array of field names whose values must match for a data tuple to fall within the
     * selection.
     *
     * __See also:__ The [projection with `encodings` and `fields`
     * section](https://vega.github.io/vega-lite/docs/selection.html#project) in the
     * documentation.
     */
    val fields : Option[Seq[String]] = None,

    /**
     * When true, an invisible voronoi diagram is computed to accelerate discrete selection. The
     * data value _nearest_ the mouse cursor is added to the selection.
     *
     * __Default value:__ `false`, which means that data values must be interacted with directly
     * (e.g., clicked on) to be added to the selection.
     *
     * __See also:__ [`nearest`
     * examples](https://vega.github.io/vega-lite/docs/selection.html#nearest) documentation.
     */
    val nearest : Option[Boolean] = None,

    /**
     * A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or
     * selector) that triggers the selection. For interval selections, the event stream must
     * specify a [start and
     * end](https://vega.github.io/vega/docs/event-streams/#between-filters).
     *
     * __See also:__ [`on` examples](https://vega.github.io/vega-lite/docs/selection.html#on) in
     * the documentation.
     */
    val on : Option[OnUnion] = None,

    /**
     * With layered and multi-view displays, a strategy that determines how selections' data
     * queries are resolved when applied in a filter transform, conditional encoding rule, or
     * scale domain.
     *
     * One of:
     * - `"global"` -- only one brush exists for the entire SPLOM. When the user begins to drag,
     * any previous brushes are cleared, and a new one is constructed.
     * - `"union"` -- each cell contains its own brush, and points are highlighted if they lie
     * within _any_ of these individual brushes.
     * - `"intersect"` -- each cell contains its own brush, and points are highlighted only if
     * they fall within _all_ of these individual brushes.
     *
     * __Default value:__ `global`.
     *
     * __See also:__ [`resolve`
     * examples](https://vega.github.io/vega-lite/docs/selection.html#resolve) in the
     * documentation.
     */
    val resolve : Option[SelectionResolution] = None,

    /**
     * Controls whether data values should be toggled (inserted or removed from a point
     * selection) or only ever inserted into point selections.
     *
     * One of:
     * - `true` -- the default behavior, which corresponds to `"event.shiftKey"`.  As a result,
     * data values are toggled when the user interacts with the shift-key pressed.
     * - `false` -- disables toggling behaviour; the selection will only ever contain a single
     * data value corresponding to the most recent interaction.
     * - A [Vega expression](https://vega.github.io/vega/docs/expressions/) which is
     * re-evaluated as the user interacts. If the expression evaluates to `true`, the data value
     * is toggled into or out of the point selection. If the expression evaluates to `false`,
     * the point selection is first cleared, and the data value is then inserted. For example,
     * setting the value to the Vega expression `"true"` will toggle data values without the
     * user pressing the shift-key.
     *
     * __Default value:__ `true`
     *
     * __See also:__ [`toggle`
     * examples](https://vega.github.io/vega-lite/docs/selection.html#toggle) in the
     * documentation.
     */
    val toggle : Option[Toggle] = None
) derives Encoder.AsObject, Decoder

/**
 * Arc-specific Config
 *
 * Image-specific Config
 *
 * Rect-Specific Config
 *
 * Area-Specific Config
 *
 * Bar-Specific Config
 *
 * Circle-Specific Config
 *
 * Geoshape-Specific Config
 *
 * Mark Config
 *
 * Point-Specific Config
 *
 * Rule-Specific Config
 *
 * Square-Specific Config
 *
 * Default style for chart subtitles
 *
 * Default style for chart titles
 *
 * Default style for axis, legend, and header labels.
 *
 * Default style for axis, legend, and header titles.
 *
 * Text-Specific Config
 *
 * Line-Specific Config
 *
 * Trail-Specific Config
 *
 * Tick-Specific Config
 */
case class StyleValue (
    /**
     * The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One
     * of `"left"`, `"right"`, `"center"`.
     *
     * __Note:__ Expression reference is *not* supported for range marks.
     */
    val align : Option[TitleAlignUnion] = None,

    val angle : Option[Angle] = None,
    val aria : Option[Aria] = None,
    val ariaRole : Option[BackgroundUnion] = None,
    val ariaRoleDescription : Option[BackgroundUnion] = None,
    val aspect : Option[Aria] = None,

    /**
     * For text marks, the vertical text baseline. One of `"alphabetic"` (default), `"top"`,
     * `"middle"`, `"bottom"`, `"line-top"`, `"line-bottom"`, or an expression reference that
     * provides one of the valid values. The `"line-top"` and `"line-bottom"` values operate
     * similarly to `"top"` and `"bottom"`, but are calculated relative to the `lineHeight`
     * rather than `fontSize` alone.
     *
     * For range marks, the vertical alignment of the marks. One of `"top"`, `"middle"`,
     * `"bottom"`.
     *
     * __Note:__ Expression reference is *not* supported for range marks.
     */
    val baseline : Option[BackgroundUnion] = None,

    /**
     * Offset between bars for binned field. The ideal value for this is either 0 (preferred by
     * statisticians) or 1 (Vega-Lite default, D3 example style).
     *
     * __Default value:__ `1`
     */
    val binSpacing : Option[Double] = None,

    val blend : Option[BlendUnion] = None,

    /**
     * Default color.
     *
     * __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
     *
     * __Note:__
     * - This property cannot be used in a [style
     * config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
     * - The `fill` and `stroke` properties have higher precedence than `color` and will
     * override `color`.
     */
    val color : Option[MarkConfigColor] = None,

    /**
     * The default size of the bars on continuous scales.
     *
     * __Default value:__ `5`
     */
    val continuousBandSize : Option[Double] = None,

    val cornerRadius : Option[CornerRadius] = None,
    val cornerRadiusBottomLeft : Option[CornerRadius] = None,
    val cornerRadiusBottomRight : Option[CornerRadius] = None,
    val cornerRadiusTopLeft : Option[CornerRadius] = None,
    val cornerRadiusTopRight : Option[CornerRadius] = None,
    val cursor : Option[CursorUnion] = None,
    val description : Option[BackgroundUnion] = None,
    val dir : Option[Dir] = None,

    /**
     * The default size of the bars with discrete dimensions. If unspecified, the default size
     * is  `step-2`, which provides 2 pixel offset between bars.
     */
    val discreteBandSize : Option[DiscreteBandSize] = None,

    val dx : Option[CornerRadius] = None,
    val dy : Option[CornerRadius] = None,
    val ellipsis : Option[BackgroundUnion] = None,
    val endAngle : Option[CornerRadius] = None,

    /**
     * Default fill color. This property has higher precedence than `config.color`. Set to
     * `null` to remove fill.
     *
     * __Default value:__ (None)
     */
    val fill : Option[MarkConfigFill] = None,

    /**
     * Whether the mark's color should be used as fill color instead of stroke color.
     *
     * __Default value:__ `false` for all `point`, `line`, and `rule` marks as well as
     * `geoshape` marks for
     * [`graticule`](https://vega.github.io/vega-lite/docs/data.html#graticule) data sources;
     * otherwise, `true`.
     *
     * __Note:__ This property cannot be used in a [style
     * config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
     */
    val filled : Option[Boolean] = None,

    val fillOpacity : Option[Opacity] = None,
    val font : Option[BackgroundUnion] = None,
    val fontSize : Option[FontSize] = None,
    val fontStyle : Option[BackgroundUnion] = None,
    val fontWeight : Option[FontWeightUnion] = None,
    val height : Option[CornerRadius] = None,
    val href : Option[BackgroundUnion] = None,

    /**
     * The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`.
     *
     * __Default value:__ `0`
     */
    val innerRadius : Option[CornerRadius] = None,

    val interpolate : Option[MarkConfigInterpolate] = None,

    /**
     * Defines how Vega-Lite should handle marks for invalid values (`null` and `NaN`).
     * - If set to `"filter"` (default), all data items with null values will be skipped (for
     * line, trail, and area marks) or filtered (for other marks).
     * - If `null`, all data items are included. In this case, invalid values will be
     * interpreted as zeroes.
     */
    val invalid : Option[Invalid] = None,

    val limit : Option[CornerRadius] = None,
    val lineBreak : Option[BackgroundUnion] = None,
    val lineHeight : Option[CornerRadius] = None,

    /**
     * The overall opacity (value between [0,1]).
     *
     * __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or
     * `square` marks or layered `bar` charts and `1` otherwise.
     */
    val opacity : Option[CornerRadius] = None,

    /**
     * For line and trail marks, this `order` property can be set to `null` or `false` to make
     * the lines use the original order in the data sources.
     */
    val order : Option[Boolean] = None,

    /**
     * The orientation of a non-stacked bar, tick, area, and line charts. The value is either
     * horizontal (default) or vertical.
     * - For bar, rule and tick, this determines whether the size of the bar and tick should be
     * applied to x or y dimension.
     * - For area, this property determines the orient property of the Vega output.
     * - For line and trail marks, this property determines the sort order of the points in the
     * line if `config.sortLineBy` is not specified. For stacked charts, this is always
     * determined by the orientation of the stack; therefore explicitly specified value will be
     * ignored.
     *
     * The orientation of the axis. One of `"top"`, `"bottom"`, `"left"` or `"right"`. The
     * orientation can be used to further specialize the axis type (e.g., a y-axis oriented
     * towards the right edge of the chart).
     *
     * __Default value:__ `"bottom"` for x-axes and `"left"` for y-axes.
     */
    val orient : Option[StyleOrient] = None,

    /**
     * The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`.
     *
     * __Default value:__ `0`
     */
    val outerRadius : Option[CornerRadius] = None,

    val padAngle : Option[CornerRadius] = None,

    /**
     * For arc mark, the primary (outer) radius in pixels.
     *
     * For text marks, polar coordinate radial offset, in pixels, of the text from the origin
     * determined by the `x` and `y` properties.
     *
     * __Default value:__ `min(plot_width, plot_height)/2`
     */
    val radius : Option[CornerRadius] = None,

    /**
     * The secondary (inner) radius in pixels of arc marks.
     *
     * __Default value:__ `0`
     */
    val radius2 : Option[CornerRadius] = None,

    val shape : Option[BackgroundUnion] = None,

    /**
     * Default size for marks.
     * - For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that
     * this value sets the area of the symbol; the side lengths will increase with the square
     * root of this value.
     * - For `bar`, this represents the band size of the bar, in pixels.
     * - For `text`, this represents the font size, in pixels.
     *
     * __Default value:__
     * - `30` for point, circle, square marks; width/height's `step`
     * - `2` for bar marks with discrete dimensions;
     * - `5` for bar marks with continuous dimensions;
     * - `11` for text marks.
     */
    val size : Option[CornerRadius] = None,

    val smooth : Option[Aria] = None,
    val startAngle : Option[CornerRadius] = None,

    /**
     * Default stroke color. This property has higher precedence than `config.color`. Set to
     * `null` to remove stroke.
     *
     * __Default value:__ (None)
     */
    val stroke : Option[MarkConfigFill] = None,

    val strokeCap : Option[Cap] = None,
    val strokeDash : Option[StrokeDash] = None,
    val strokeDashOffset : Option[CornerRadius] = None,
    val strokeJoin : Option[StrokeJoinUnion] = None,
    val strokeMiterLimit : Option[CornerRadius] = None,
    val strokeOffset : Option[CornerRadius] = None,
    val strokeOpacity : Option[Opacity] = None,
    val strokeWidth : Option[FontSize] = None,
    val tension : Option[CornerRadius] = None,

    /**
     * Text-Specific Config
     */
    val text : Option[TextUnion] = None,

    /**
     * - For arc marks, the arc length in radians if theta2 is not specified, otherwise the
     * start arc angle. (A value of 0 indicates up or “north”, increasing values proceed
     * clockwise.)
     *
     * - For text marks, polar coordinate angle in radians.
     */
    val theta : Option[CornerRadius] = None,

    /**
     * The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing
     * values proceed clockwise.
     */
    val theta2 : Option[CornerRadius] = None,

    /**
     * Default relative band position for a time unit. If set to `0`, the marks will be
     * positioned at the beginning of the time unit band step. If set to `0.5`, the marks will
     * be positioned in the middle of the time unit band step.
     */
    val timeUnitBandPosition : Option[Double] = None,

    /**
     * Default relative band size for a time unit. If set to `1`, the bandwidth of the marks
     * will be equal to the time unit band step. If set to `0.5`, bandwidth of the marks will be
     * half of the time unit band step.
     */
    val timeUnitBandSize : Option[Double] = None,

    /**
     * The tooltip text string to show upon mouse hover or an object defining which fields
     * should the tooltip be derived from.
     *
     * - If `tooltip` is `true` or `{"content": "encoding"}`, then all fields from `encoding`
     * will be used.
     * - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted
     * data point will be used.
     * - If set to `null` or `false`, then no tooltip will be used.
     *
     * See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for
     * a detailed discussion about tooltip  in Vega-Lite.
     *
     * __Default value:__ `null`
     */
    val tooltip : Option[OverlayMarkDefTooltip] = None,

    val url : Option[BackgroundUnion] = None,
    val width : Option[CornerRadius] = None,

    /**
     * X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified
     * `x2` or `width`.
     *
     * The `value` of this channel can be a number or a string `"width"` for the width of the
     * plot.
     */
    val x : Option[X] = None,

    /**
     * X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
     *
     * The `value` of this channel can be a number or a string `"width"` for the width of the
     * plot.
     */
    val x2 : Option[X] = None,

    /**
     * Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified
     * `y2` or `height`.
     *
     * The `value` of this channel can be a number or a string `"height"` for the height of the
     * plot.
     */
    val y : Option[X] = None,

    /**
     * Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
     *
     * The `value` of this channel can be a number or a string `"height"` for the height of the
     * plot.
     */
    val y2 : Option[X] = None,

    /**
     * A flag for overlaying line on top of area marks, or an object defining the properties of
     * the overlayed lines.
     *
     * - If this value is an empty object (`{}`) or `true`, lines with default properties will
     * be used.
     *
     * - If this value is `false`, no lines would be automatically added to area marks.
     *
     * __Default value:__ `false`.
     *
     * Line-Specific Config
     */
    val line : Option[Line] = None,

    /**
     * A flag for overlaying points on top of line or area marks, or an object defining the
     * properties of the overlayed points.
     *
     * - If this property is `"transparent"`, transparent points will be used (for enhancing
     * tooltips and selections).
     *
     * - If this property is an empty object (`{}`) or `true`, filled points with default
     * properties will be used.
     *
     * - If this property is `false`, no points would be automatically added to line or area
     * marks.
     *
     * __Default value:__ `false`.
     *
     * Point-Specific Config
     */
    val point : Option[Point] = None,

    /**
     * - For vertical bars, top-left and top-right corner radius.
     *
     * - For horizontal bars, top-right and bottom-right corner radius.
     */
    val cornerRadiusEnd : Option[CornerRadius] = None,

    /**
     * The width of the ticks.
     *
     * __Default value:__  3/4 of step (width step for horizontal ticks and height step for
     * vertical ticks).
     */
    val bandSize : Option[Double] = None,

    /**
     * Thickness of the tick mark.
     *
     * __Default value:__  `1`
     */
    val thickness : Option[Double] = None,

    val bandPosition : Option[CornerRadius] = None,

    /**
     * A boolean flag indicating if the domain (the axis baseline) should be included as part of
     * the axis.
     *
     * __Default value:__ `true`
     */
    val domain : Option[Boolean] = None,

    val domainCap : Option[Cap] = None,
    val domainColor : Option[Color] = None,
    val domainDash : Option[StrokeDash] = None,
    val domainDashOffset : Option[CornerRadius] = None,
    val domainOpacity : Option[CornerRadius] = None,
    val domainWidth : Option[CornerRadius] = None,

    /**
     * When used with the default `"number"` and `"time"` format type, the text formatting
     * pattern for labels of guides (axes, legends, headers) and text marks.
     *
     * - If the format type is `"number"` (e.g., for quantitative fields), this is D3's [number
     * format pattern](https://github.com/d3/d3-format#locale_format).
     * - If the format type is `"time"` (e.g., for temporal fields), this is D3's [time format
     * pattern](https://github.com/d3/d3-time-format#locale_format).
     *
     * See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for
     * more examples.
     *
     * When used with a [custom
     * `formatType`](https://vega.github.io/vega-lite/docs/config.html#custom-format-type), this
     * value will be passed as `format` alongside `datum.value` to the registered function.
     *
     * __Default value:__  Derived from
     * [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for
     * number format and from
     * [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for time
     * format.
     */
    val format : Option[Format] = None,

    /**
     * The format type for labels. One of `"number"`, `"time"`, or a [registered custom format
     * type](https://vega.github.io/vega-lite/docs/config.html#custom-format-type).
     *
     * __Default value:__
     * - `"time"` for temporal fields and ordinal and nominal fields with `timeUnit`.
     * - `"number"` for quantitative fields as well as ordinal and nominal fields without
     * `timeUnit`.
     */
    val formatType : Option[String] = None,

    /**
     * A boolean flag indicating if grid lines should be included as part of the axis
     *
     * __Default value:__ `true` for [continuous
     * scales](https://vega.github.io/vega-lite/docs/scale.html#continuous) that are not binned;
     * otherwise, `false`.
     */
    val grid : Option[Boolean] = None,

    val gridCap : Option[Cap] = None,
    val gridColor : Option[GridColorUnion] = None,
    val gridDash : Option[AxisGridDash] = None,
    val gridDashOffset : Option[GridDashOffsetUnion] = None,
    val gridOpacity : Option[GridOpacityUnion] = None,
    val gridWidth : Option[GridWidthUnion] = None,
    val labelAlign : Option[ConditionalAxisPropertyAlignNull] = None,
    val labelAngle : Option[LabelAngle] = None,
    val labelBaseline : Option[TextBaseline] = None,
    val labelBound : Option[Label] = None,
    val labelColor : Option[GridColorUnion] = None,

    /**
     * [Vega expression](https://vega.github.io/vega/docs/expressions/) for customizing labels.
     *
     * __Note:__ The label text and value can be assessed via the `label` and `value` properties
     * of the axis's backing `datum` object.
     */
    val labelExpr : Option[String] = None,

    /**
     * Indicates if the first and last axis labels should be aligned flush with the scale range.
     * Flush alignment for a horizontal axis will left-align the first label and right-align the
     * last label. For vertical axes, bottom and top text baselines are applied instead. If this
     * property is a number, it also indicates the number of pixels by which to offset the first
     * and last labels; for example, a value of 2 will flush-align the first and last labels and
     * also push them 2 pixels outward from the center of the axis. The additional adjustment
     * can sometimes help the labels better visually group with corresponding axis ticks.
     *
     * __Default value:__ `true` for axis of a continuous x-scale. Otherwise, `false`.
     */
    val labelFlush : Option[LabelFlush] = None,

    val labelFlushOffset : Option[CornerRadius] = None,
    val labelFont : Option[ConditionalAxisPropertyStringNull] = None,
    val labelFontSize : Option[GridWidthUnion] = None,
    val labelFontStyle : Option[ConditionalAxisPropertyFontStyleNull] = None,
    val labelFontWeight : Option[FontWeight] = None,
    val labelLimit : Option[CornerRadius] = None,
    val labelLineHeight : Option[CornerRadius] = None,
    val labelOffset : Option[GridDashOffsetUnion] = None,
    val labelOpacity : Option[GridDashOffsetUnion] = None,

    /**
     * The strategy to use for resolving overlap of axis labels. If `false` (the default), no
     * overlap reduction is attempted. If set to `true` or `"parity"`, a strategy of removing
     * every other label is used (this works well for standard linear axes). If set to
     * `"greedy"`, a linear scan of the labels is performed, removing any labels that overlaps
     * with the last visible label (this often works better for log-scaled axes).
     *
     * __Default value:__ `true` for non-nominal fields with non-log scales; `"greedy"` for log
     * scales; otherwise `false`.
     */
    val labelOverlap : Option[LabelOverlap] = None,

    val labelPadding : Option[GridDashOffsetUnion] = None,

    /**
     * A boolean flag indicating if labels should be included as part of the axis.
     *
     * __Default value:__ `true`.
     */
    val labels : Option[Boolean] = None,

    val labelSeparation : Option[CornerRadius] = None,
    val maxExtent : Option[CornerRadius] = None,
    val minExtent : Option[CornerRadius] = None,

    /**
     * The offset, in pixels, by which to displace the axis from the edge of the enclosing group
     * or data rectangle.
     *
     * __Default value:__ derived from the [axis
     * config](https://vega.github.io/vega-lite/docs/config.html#facet-scale-config)'s `offset`
     * (`0` by default)
     */
    val offset : Option[CornerRadius] = None,

    /**
     * The anchor position of the axis in pixels. For x-axes with top or bottom orientation,
     * this sets the axis group x coordinate. For y-axes with left or right orientation, this
     * sets the axis group y coordinate.
     *
     * __Default value__: `0`
     */
    val position : Option[CornerRadius] = None,

    /**
     * A string or array of strings indicating the name of custom styles to apply to the axis. A
     * style is a named collection of axis property defined within the [style
     * configuration](https://vega.github.io/vega-lite/docs/mark.html#style-config). If style is
     * an array, later styles will override earlier styles.
     *
     * __Default value:__ (none) __Note:__ Any specified style will augment the default style.
     * For example, an x-axis mark with `"style": "foo"` will use `config.axisX` and
     * `config.style.foo` (the specified style `"foo"` has higher precedence).
     */
    val style : Option[Text] = None,

    val tickBand : Option[TickBandUnion] = None,
    val tickCap : Option[Cap] = None,
    val tickColor : Option[GridColorUnion] = None,

    /**
     * A desired number of ticks, for axes visualizing quantitative scales. The resulting number
     * may be different so that values are "nice" (multiples of 2, 5, 10) and lie within the
     * underlying scale's range.
     *
     * For scales of type `"time"` or `"utc"`, the tick count can instead be a time interval
     * specifier. Legal string values are `"millisecond"`, `"second"`, `"minute"`, `"hour"`,
     * `"day"`, `"week"`, `"month"`, and `"year"`. Alternatively, an object-valued interval
     * specifier of the form `{"interval": "month", "step": 3}` includes a desired number of
     * interval steps. Here, ticks are generated for each quarter (Jan, Apr, Jul, Oct)
     * boundary.
     *
     * __Default value__: Determine using a formula `ceil(width/40)` for x and `ceil(height/40)`
     * for y.
     */
    val tickCount : Option[TickCount] = None,

    val tickDash : Option[AxisTickDash] = None,
    val tickDashOffset : Option[GridDashOffsetUnion] = None,

    /**
     * Boolean flag indicating if an extra axis tick should be added for the initial position of
     * the axis. This flag is useful for styling axes for `band` scales such that ticks are
     * placed on band boundaries rather in the middle of a band. Use in conjunction with
     * `"bandPosition": 1` and an axis `"padding"` value of `0`.
     */
    val tickExtra : Option[Boolean] = None,

    /**
     * The minimum desired step between axis ticks, in terms of scale domain values. For
     * example, a value of `1` indicates that ticks should not be less than 1 unit apart. If
     * `tickMinStep` is specified, the `tickCount` value will be adjusted, if necessary, to
     * enforce the minimum step value.
     */
    val tickMinStep : Option[CornerRadius] = None,

    val tickOffset : Option[CornerRadius] = None,
    val tickOpacity : Option[GridDashOffsetUnion] = None,

    /**
     * Boolean flag indicating if pixel position values should be rounded to the nearest
     * integer.
     *
     * __Default value:__ `true`
     */
    val tickRound : Option[Boolean] = None,

    /**
     * Boolean value that determines whether the axis should include ticks.
     *
     * __Default value:__ `true`
     */
    val ticks : Option[Boolean] = None,

    val tickSize : Option[GridWidthUnion] = None,
    val tickWidth : Option[GridWidthUnion] = None,

    /**
     * A title for the field. If `null`, the title will be removed.
     *
     * __Default value:__  derived from the field's name and transformation function
     * (`aggregate`, `bin` and `timeUnit`). If the field has an aggregate function, the function
     * is displayed as part of the title (e.g., `"Sum of Profit"`). If the field is binned or
     * has a time unit applied, the applied function is shown in parentheses (e.g., `"Profit
     * (binned)"`, `"Transaction Date (year-month)"`). Otherwise, the title is simply the field
     * name.
     *
     * __Notes__:
     *
     * 1) You can customize the default field title format by providing the
     * [`fieldTitle`](https://vega.github.io/vega-lite/docs/config.html#top-level-config)
     * property in the [config](https://vega.github.io/vega-lite/docs/config.html) or
     * [`fieldTitle` function via the `compile` function's
     * options](https://vega.github.io/vega-lite/usage/compile.html#field-title).
     *
     * 2) If both field definition's `title` and axis, header, or legend `title` are defined,
     * axis/header/legend title will be used.
     */
    val title : Option[LegendTitle] = None,

    val titleAlign : Option[TitleAlignUnion] = None,
    val titleAnchor : Option[TitleAnchorUnion] = None,
    val titleAngle : Option[CornerRadius] = None,
    val titleBaseline : Option[BackgroundUnion] = None,
    val titleColor : Option[Color] = None,
    val titleFont : Option[BackgroundUnion] = None,
    val titleFontSize : Option[FontSize] = None,
    val titleFontStyle : Option[BackgroundUnion] = None,
    val titleFontWeight : Option[FontWeightUnion] = None,
    val titleLimit : Option[FontSize] = None,
    val titleLineHeight : Option[CornerRadius] = None,
    val titleOpacity : Option[CornerRadius] = None,
    val titlePadding : Option[CornerRadius] = None,
    val titleX : Option[CornerRadius] = None,
    val titleY : Option[CornerRadius] = None,
    val translate : Option[CornerRadius] = None,

    /**
     * Explicitly set the visible axis tick values.
     */
    val values : Option[Values] = None,

    /**
     * A non-negative integer indicating the z-index of the axis. If zindex is 0, axes should be
     * drawn behind all chart elements. To put them in front, set `zindex` to `1` or more.
     *
     * __Default value:__ `0` (behind the marks).
     */
    val zindex : Option[Double] = None
) derives Encoder.AsObject, Decoder

type StyleOrient = BackgroundExprRef | AxisOrient
given Decoder[StyleOrient] = {
    List[Decoder[StyleOrient]](
        Decoder[BackgroundExprRef].widen,
        Decoder[AxisOrient].widen,
    ).reduceLeft(_ or _)
}

given Encoder[StyleOrient] = Encoder.instance {
    case enc0 : BackgroundExprRef => Encoder.AsObject[BackgroundExprRef].apply(enc0)
    case enc1 : AxisOrient => summon[Encoder[AxisOrient]].apply(enc1)
}

/**
 * The orientation of a non-stacked bar, tick, area, and line charts. The value is either
 * horizontal (default) or vertical.
 * - For bar, rule and tick, this determines whether the size of the bar and tick should be
 * applied to x or y dimension.
 * - For area, this property determines the orient property of the Vega output.
 * - For line and trail marks, this property determines the sort order of the points in the
 * line if `config.sortLineBy` is not specified. For stacked charts, this is always
 * determined by the orientation of the stack; therefore explicitly specified value will be
 * ignored.
 *
 * The direction of the legend, one of `"vertical"` or `"horizontal"`.
 *
 * __Default value:__
 * - For top-/bottom-`orient`ed legends, `"horizontal"`
 * - For left-/right-`orient`ed legends, `"vertical"`
 * - For top/bottom-left/right-`orient`ed legends, `"horizontal"` for gradient legends and
 * `"vertical"` for symbol legends.
 *
 * The default direction (`"horizontal"` or `"vertical"`) for gradient legends.
 *
 * __Default value:__ `"vertical"`.
 *
 * The default direction (`"horizontal"` or `"vertical"`) for symbol legends.
 *
 * __Default value:__ `"vertical"`.
 *
 * Orientation of the box plot. This is normally automatically determined based on types of
 * fields on x and y channels. However, an explicit `orient` be specified when the
 * orientation is ambiguous.
 *
 * __Default value:__ `"vertical"`.
 *
 * Orientation of the error bar. This is normally automatically determined, but can be
 * specified when the orientation is ambiguous and cannot be automatically determined.
 *
 * Orientation of the error band. This is normally automatically determined, but can be
 * specified when the orientation is ambiguous and cannot be automatically determined.
 */

enum AxisOrient : 
    case bottom
    case horizontal
    case left
    case right
    case top
    case vertical
given Decoder[AxisOrient] = Decoder.decodeString.emapTry(x => Try(AxisOrient.valueOf(x) )) 
given Encoder[AxisOrient] = Encoder.encodeString.contramap(_.toString())

/**
 * Tick-Specific Config
 */
case class TickConfig (
    /**
     * The horizontal alignment of the text or ranged marks (area, bar, image, rect, rule). One
     * of `"left"`, `"right"`, `"center"`.
     *
     * __Note:__ Expression reference is *not* supported for range marks.
     */
    val align : Option[TitleAlignUnion] = None,

    val angle : Option[Angle] = None,
    val aria : Option[Aria] = None,
    val ariaRole : Option[BackgroundUnion] = None,
    val ariaRoleDescription : Option[BackgroundUnion] = None,
    val aspect : Option[Aria] = None,

    /**
     * The width of the ticks.
     *
     * __Default value:__  3/4 of step (width step for horizontal ticks and height step for
     * vertical ticks).
     */
    val bandSize : Option[Double] = None,

    /**
     * For text marks, the vertical text baseline. One of `"alphabetic"` (default), `"top"`,
     * `"middle"`, `"bottom"`, `"line-top"`, `"line-bottom"`, or an expression reference that
     * provides one of the valid values. The `"line-top"` and `"line-bottom"` values operate
     * similarly to `"top"` and `"bottom"`, but are calculated relative to the `lineHeight`
     * rather than `fontSize` alone.
     *
     * For range marks, the vertical alignment of the marks. One of `"top"`, `"middle"`,
     * `"bottom"`.
     *
     * __Note:__ Expression reference is *not* supported for range marks.
     */
    val baseline : Option[BackgroundUnion] = None,

    val blend : Option[BlendUnion] = None,

    /**
     * Default color.
     *
     * __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
     *
     * __Note:__
     * - This property cannot be used in a [style
     * config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
     * - The `fill` and `stroke` properties have higher precedence than `color` and will
     * override `color`.
     */
    val color : Option[MarkConfigColor] = None,

    val cornerRadius : Option[CornerRadius] = None,
    val cornerRadiusBottomLeft : Option[CornerRadius] = None,
    val cornerRadiusBottomRight : Option[CornerRadius] = None,
    val cornerRadiusTopLeft : Option[CornerRadius] = None,
    val cornerRadiusTopRight : Option[CornerRadius] = None,
    val cursor : Option[CursorUnion] = None,
    val description : Option[BackgroundUnion] = None,
    val dir : Option[Dir] = None,
    val dx : Option[CornerRadius] = None,
    val dy : Option[CornerRadius] = None,
    val ellipsis : Option[BackgroundUnion] = None,
    val endAngle : Option[CornerRadius] = None,

    /**
     * Default fill color. This property has higher precedence than `config.color`. Set to
     * `null` to remove fill.
     *
     * __Default value:__ (None)
     */
    val fill : Option[MarkConfigFill] = None,

    /**
     * Whether the mark's color should be used as fill color instead of stroke color.
     *
     * __Default value:__ `false` for all `point`, `line`, and `rule` marks as well as
     * `geoshape` marks for
     * [`graticule`](https://vega.github.io/vega-lite/docs/data.html#graticule) data sources;
     * otherwise, `true`.
     *
     * __Note:__ This property cannot be used in a [style
     * config](https://vega.github.io/vega-lite/docs/mark.html#style-config).
     */
    val filled : Option[Boolean] = None,

    val fillOpacity : Option[Opacity] = None,
    val font : Option[BackgroundUnion] = None,
    val fontSize : Option[FontSize] = None,
    val fontStyle : Option[BackgroundUnion] = None,
    val fontWeight : Option[FontWeightUnion] = None,
    val height : Option[CornerRadius] = None,
    val href : Option[BackgroundUnion] = None,

    /**
     * The inner radius in pixels of arc marks. `innerRadius` is an alias for `radius2`.
     *
     * __Default value:__ `0`
     */
    val innerRadius : Option[CornerRadius] = None,

    val interpolate : Option[MarkConfigInterpolate] = None,

    /**
     * Defines how Vega-Lite should handle marks for invalid values (`null` and `NaN`).
     * - If set to `"filter"` (default), all data items with null values will be skipped (for
     * line, trail, and area marks) or filtered (for other marks).
     * - If `null`, all data items are included. In this case, invalid values will be
     * interpreted as zeroes.
     */
    val invalid : Option[Invalid] = None,

    val limit : Option[CornerRadius] = None,
    val lineBreak : Option[BackgroundUnion] = None,
    val lineHeight : Option[CornerRadius] = None,

    /**
     * The overall opacity (value between [0,1]).
     *
     * __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or
     * `square` marks or layered `bar` charts and `1` otherwise.
     */
    val opacity : Option[CornerRadius] = None,

    /**
     * For line and trail marks, this `order` property can be set to `null` or `false` to make
     * the lines use the original order in the data sources.
     */
    val order : Option[Boolean] = None,

    /**
     * The orientation of a non-stacked bar, tick, area, and line charts. The value is either
     * horizontal (default) or vertical.
     * - For bar, rule and tick, this determines whether the size of the bar and tick should be
     * applied to x or y dimension.
     * - For area, this property determines the orient property of the Vega output.
     * - For line and trail marks, this property determines the sort order of the points in the
     * line if `config.sortLineBy` is not specified. For stacked charts, this is always
     * determined by the orientation of the stack; therefore explicitly specified value will be
     * ignored.
     */
    val orient : Option[Orientation] = None,

    /**
     * The outer radius in pixels of arc marks. `outerRadius` is an alias for `radius`.
     *
     * __Default value:__ `0`
     */
    val outerRadius : Option[CornerRadius] = None,

    val padAngle : Option[CornerRadius] = None,

    /**
     * For arc mark, the primary (outer) radius in pixels.
     *
     * For text marks, polar coordinate radial offset, in pixels, of the text from the origin
     * determined by the `x` and `y` properties.
     *
     * __Default value:__ `min(plot_width, plot_height)/2`
     */
    val radius : Option[CornerRadius] = None,

    /**
     * The secondary (inner) radius in pixels of arc marks.
     *
     * __Default value:__ `0`
     */
    val radius2 : Option[CornerRadius] = None,

    val shape : Option[BackgroundUnion] = None,

    /**
     * Default size for marks.
     * - For `point`/`circle`/`square`, this represents the pixel area of the marks. Note that
     * this value sets the area of the symbol; the side lengths will increase with the square
     * root of this value.
     * - For `bar`, this represents the band size of the bar, in pixels.
     * - For `text`, this represents the font size, in pixels.
     *
     * __Default value:__
     * - `30` for point, circle, square marks; width/height's `step`
     * - `2` for bar marks with discrete dimensions;
     * - `5` for bar marks with continuous dimensions;
     * - `11` for text marks.
     */
    val size : Option[CornerRadius] = None,

    val smooth : Option[Aria] = None,
    val startAngle : Option[CornerRadius] = None,

    /**
     * Default stroke color. This property has higher precedence than `config.color`. Set to
     * `null` to remove stroke.
     *
     * __Default value:__ (None)
     */
    val stroke : Option[MarkConfigFill] = None,

    val strokeCap : Option[Cap] = None,
    val strokeDash : Option[StrokeDash] = None,
    val strokeDashOffset : Option[CornerRadius] = None,
    val strokeJoin : Option[StrokeJoinUnion] = None,
    val strokeMiterLimit : Option[CornerRadius] = None,
    val strokeOffset : Option[CornerRadius] = None,
    val strokeOpacity : Option[Opacity] = None,
    val strokeWidth : Option[FontSize] = None,
    val tension : Option[CornerRadius] = None,
    val text : Option[TextUnion] = None,

    /**
     * - For arc marks, the arc length in radians if theta2 is not specified, otherwise the
     * start arc angle. (A value of 0 indicates up or “north”, increasing values proceed
     * clockwise.)
     *
     * - For text marks, polar coordinate angle in radians.
     */
    val theta : Option[CornerRadius] = None,

    /**
     * The end angle of arc marks in radians. A value of 0 indicates up or “north”, increasing
     * values proceed clockwise.
     */
    val theta2 : Option[CornerRadius] = None,

    /**
     * Thickness of the tick mark.
     *
     * __Default value:__  `1`
     */
    val thickness : Option[Double] = None,

    /**
     * Default relative band position for a time unit. If set to `0`, the marks will be
     * positioned at the beginning of the time unit band step. If set to `0.5`, the marks will
     * be positioned in the middle of the time unit band step.
     */
    val timeUnitBandPosition : Option[Double] = None,

    /**
     * Default relative band size for a time unit. If set to `1`, the bandwidth of the marks
     * will be equal to the time unit band step. If set to `0.5`, bandwidth of the marks will be
     * half of the time unit band step.
     */
    val timeUnitBandSize : Option[Double] = None,

    /**
     * The tooltip text string to show upon mouse hover or an object defining which fields
     * should the tooltip be derived from.
     *
     * - If `tooltip` is `true` or `{"content": "encoding"}`, then all fields from `encoding`
     * will be used.
     * - If `tooltip` is `{"content": "data"}`, then all fields that appear in the highlighted
     * data point will be used.
     * - If set to `null` or `false`, then no tooltip will be used.
     *
     * See the [`tooltip`](https://vega.github.io/vega-lite/docs/tooltip.html) documentation for
     * a detailed discussion about tooltip  in Vega-Lite.
     *
     * __Default value:__ `null`
     */
    val tooltip : Option[OverlayMarkDefTooltip] = None,

    val url : Option[BackgroundUnion] = None,
    val width : Option[CornerRadius] = None,

    /**
     * X coordinates of the marks, or width of horizontal `"bar"` and `"area"` without specified
     * `x2` or `width`.
     *
     * The `value` of this channel can be a number or a string `"width"` for the width of the
     * plot.
     */
    val x : Option[X] = None,

    /**
     * X2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
     *
     * The `value` of this channel can be a number or a string `"width"` for the width of the
     * plot.
     */
    val x2 : Option[X] = None,

    /**
     * Y coordinates of the marks, or height of vertical `"bar"` and `"area"` without specified
     * `y2` or `height`.
     *
     * The `value` of this channel can be a number or a string `"height"` for the height of the
     * plot.
     */
    val y : Option[X] = None,

    /**
     * Y2 coordinates for ranged `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
     *
     * The `value` of this channel can be a number or a string `"height"` for the height of the
     * plot.
     */
    val y2 : Option[X] = None
) derives Encoder.AsObject, Decoder

/**
 * Title configuration, which determines default properties for all
 * [titles](https://vega.github.io/vega-lite/docs/title.html). For a full list of title
 * configuration options, please see the [corresponding section of the title
 * documentation](https://vega.github.io/vega-lite/docs/title.html#config).
 */
case class BaseTitleNoValueRefs (
    /**
     * Horizontal text alignment for title text. One of `"left"`, `"center"`, or `"right"`.
     */
    val align : Option[Align] = None,

    val anchor : Option[TitleAnchorUnion] = None,
    val angle : Option[CornerRadius] = None,
    val aria : Option[Aria] = None,

    /**
     * Vertical text baseline for title and subtitle text. One of `"alphabetic"` (default),
     * `"top"`, `"middle"`, `"bottom"`, `"line-top"`, or `"line-bottom"`. The `"line-top"` and
     * `"line-bottom"` values operate similarly to `"top"` and `"bottom"`, but are calculated
     * relative to the *lineHeight* rather than *fontSize* alone.
     */
    val baseline : Option[String] = None,

    val color : Option[Color] = None,
    val dx : Option[CornerRadius] = None,
    val dy : Option[CornerRadius] = None,
    val font : Option[BackgroundUnion] = None,
    val fontSize : Option[FontSize] = None,
    val fontStyle : Option[BackgroundUnion] = None,
    val fontWeight : Option[FontWeightUnion] = None,
    val frame : Option[BackgroundUnion] = None,
    val limit : Option[FontSize] = None,
    val lineHeight : Option[CornerRadius] = None,
    val offset : Option[CornerRadius] = None,
    val orient : Option[TitleParamsOrient] = None,
    val subtitleColor : Option[Color] = None,
    val subtitleFont : Option[BackgroundUnion] = None,
    val subtitleFontSize : Option[FontSize] = None,
    val subtitleFontStyle : Option[BackgroundUnion] = None,
    val subtitleFontWeight : Option[FontWeightUnion] = None,
    val subtitleLineHeight : Option[CornerRadius] = None,
    val subtitlePadding : Option[CornerRadius] = None,
    val zindex : Option[FontSize] = None
) derives Encoder.AsObject, Decoder

/**
 * Default properties for [single view
 * plots](https://vega.github.io/vega-lite/docs/spec.html#single).
 */
case class ViewConfig (
    /**
     * Whether the view should be clipped.
     */
    val clip : Option[Boolean] = None,

    /**
     * The default height when the plot has a continuous y-field for x or latitude, or has arc
     * marks.
     *
     * __Default value:__ `200`
     */
    val continuousHeight : Option[Double] = None,

    /**
     * The default width when the plot has a continuous field for x or longitude, or has arc
     * marks.
     *
     * __Default value:__ `200`
     */
    val continuousWidth : Option[Double] = None,

    val cornerRadius : Option[CornerRadius] = None,

    /**
     * The mouse cursor used over the view. Any valid [CSS cursor
     * type](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Values) can be used.
     */
    val cursor : Option[Cursor] = None,

    /**
     * The default height when the plot has non arc marks and either a discrete y-field or no
     * y-field. The height can be either a number indicating a fixed height or an object in the
     * form of `{step: number}` defining the height per discrete step.
     *
     * __Default value:__ a step size based on `config.view.step`.
     */
    val discreteHeight : Option[DiscreteHeightUnion] = None,

    /**
     * The default width when the plot has non-arc marks and either a discrete x-field or no
     * x-field. The width can be either a number indicating a fixed width or an object in the
     * form of `{step: number}` defining the width per discrete step.
     *
     * __Default value:__ a step size based on `config.view.step`.
     */
    val discreteWidth : Option[DiscreteWidthUnion] = None,

    /**
     * The fill color.
     *
     * __Default value:__ `undefined`
     */
    val fill : Option[Color] = None,

    val fillOpacity : Option[Opacity] = None,

    /**
     * The overall opacity (value between [0,1]).
     *
     * __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or
     * `square` marks or layered `bar` charts and `1` otherwise.
     */
    val opacity : Option[CornerRadius] = None,

    /**
     * Default step size for x-/y- discrete fields.
     */
    val step : Option[Double] = None,

    /**
     * The stroke color.
     *
     * __Default value:__ `"#ddd"`
     */
    val stroke : Option[Color] = None,

    val strokeCap : Option[Cap] = None,
    val strokeDash : Option[StrokeDash] = None,
    val strokeDashOffset : Option[CornerRadius] = None,
    val strokeJoin : Option[StrokeJoinUnion] = None,
    val strokeMiterLimit : Option[CornerRadius] = None,
    val strokeOpacity : Option[Opacity] = None,
    val strokeWidth : Option[FontSize] = None
) derives Encoder.AsObject, Decoder

/**
 * The default height when the plot has non arc marks and either a discrete y-field or no
 * y-field. The height can be either a number indicating a fixed height or an object in the
 * form of `{step: number}` defining the height per discrete step.
 *
 * __Default value:__ a step size based on `config.view.step`.
 */
type DiscreteHeightUnion = DiscreteHeightClass | Double
given Decoder[DiscreteHeightUnion] = {
    List[Decoder[DiscreteHeightUnion]](
        Decoder[DiscreteHeightClass].widen,
        Decoder[Double].widen,
    ).reduceLeft(_ or _)
}

given Encoder[DiscreteHeightUnion] = Encoder.instance {
    case enc0 : DiscreteHeightClass => Encoder.AsObject[DiscreteHeightClass].apply(enc0)
    case enc1 : Double => Encoder.encodeDouble(enc1)
}

case class DiscreteHeightClass (
    val step : Double
) derives Encoder.AsObject, Decoder

/**
 * The default width when the plot has non-arc marks and either a discrete x-field or no
 * x-field. The width can be either a number indicating a fixed width or an object in the
 * form of `{step: number}` defining the width per discrete step.
 *
 * __Default value:__ a step size based on `config.view.step`.
 */
type DiscreteWidthUnion = DiscreteWidthClass | Double
given Decoder[DiscreteWidthUnion] = {
    List[Decoder[DiscreteWidthUnion]](
        Decoder[DiscreteWidthClass].widen,
        Decoder[Double].widen,
    ).reduceLeft(_ or _)
}

given Encoder[DiscreteWidthUnion] = Encoder.instance {
    case enc0 : DiscreteWidthClass => Encoder.AsObject[DiscreteWidthClass].apply(enc0)
    case enc1 : Double => Encoder.encodeDouble(enc1)
}

case class DiscreteWidthClass (
    val step : Double
) derives Encoder.AsObject, Decoder

/**
 * A specification of the view that gets faceted.
 *
 * A specification of the view that gets repeated.
 *
 * A full layered plot specification, which may contains `encoding` and `projection`
 * properties that will be applied to underlying unit (single-view) specifications.
 *
 * Any specification in Vega-Lite.
 *
 * Unit spec that can have a composite mark and row or column channels (shorthand for a
 * facet spec).
 *
 * Base interface for a repeat specification.
 *
 * Base interface for a facet specification.
 *
 * Base interface for a generalized concatenation specification.
 *
 * Base interface for a vertical concatenation specification.
 *
 * Base interface for a horizontal concatenation specification.
 */
case class VegaLiteDSLSpec (
    /**
     * An object describing the data source. Set to `null` to ignore the parent's data source.
     * If no data is set, it is derived from the parent.
     */
    val data : Option[URLData] = None,

    /**
     * Description of this mark for commenting purpose.
     */
    val description : Option[String] = None,

    /**
     * A shared key-value mapping between encoding channels and definition of fields in the
     * underlying layers.
     *
     * A key-value mapping between encoding channels and definition of fields.
     */
    val encoding : Option[SpecEncoding] = None,

    /**
     * The height of a visualization.
     *
     * - For a plot with a continuous y-field, height should be a number.
     * - For a plot with either a discrete y-field or no y-field, height can be either a number
     * indicating a fixed height or an object in the form of `{step: number}` defining the
     * height per discrete step. (No y-field is equivalent to having one discrete step.)
     * - To enable responsive sizing on height, it should be set to `"container"`.
     *
     * __Default value:__ Based on `config.view.continuousHeight` for a plot with a continuous
     * y-field and `config.view.discreteHeight` otherwise.
     *
     * __Note:__ For plots with [`row` and `column`
     * channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the
     * height of a single view and the `"container"` option cannot be used.
     *
     * __See also:__ [`height`](https://vega.github.io/vega-lite/docs/size.html) documentation.
     */
    val height : Option[SpecHeight] = None,

    /**
     * Layer or single view specifications to be layered.
     *
     * __Note__: Specifications inside `layer` cannot use `row` and `column` channels as
     * layering facet specifications is not allowed. Instead, use the [facet
     * operator](https://vega.github.io/vega-lite/docs/facet.html) and place a layer inside a
     * facet.
     */
    val layer : Option[Seq[LayerSpec]] = None,

    /**
     * Name of the visualization for later reference.
     */
    val name : Option[String] = None,

    /**
     * An object defining properties of the geographic projection shared by underlying layers.
     *
     * An object defining properties of geographic projection, which will be applied to `shape`
     * path for `"geoshape"` marks and to `latitude` and `"longitude"` channels for other marks.
     */
    val projection : Option[Projection] = None,

    /**
     * Scale, axis, and legend resolutions for view composition specifications.
     */
    val resolve : Option[Resolve] = None,

    /**
     * Title for the plot.
     */
    val title : Option[LayerTitle] = None,

    /**
     * An array of data transformations such as filter and new field calculation.
     */
    val transform : Option[Seq[Transform]] = None,

    /**
     * An object defining the view background's fill and stroke.
     *
     * __Default value:__ none (transparent)
     */
    val view : Option[ViewBackground] = None,

    /**
     * The width of a visualization.
     *
     * - For a plot with a continuous x-field, width should be a number.
     * - For a plot with either a discrete x-field or no x-field, width can be either a number
     * indicating a fixed width or an object in the form of `{step: number}` defining the width
     * per discrete step. (No x-field is equivalent to having one discrete step.)
     * - To enable responsive sizing on width, it should be set to `"container"`.
     *
     * __Default value:__ Based on `config.view.continuousWidth` for a plot with a continuous
     * x-field and `config.view.discreteWidth` otherwise.
     *
     * __Note:__ For plots with [`row` and `column`
     * channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the
     * width of a single view and the `"container"` option cannot be used.
     *
     * __See also:__ [`width`](https://vega.github.io/vega-lite/docs/size.html) documentation.
     */
    val width : Option[SpecHeight] = None,

    /**
     * A string describing the mark type (one of `"bar"`, `"circle"`, `"square"`, `"tick"`,
     * `"line"`, `"area"`, `"point"`, `"rule"`, `"geoshape"`, and `"text"`) or a [mark
     * definition object](https://vega.github.io/vega-lite/docs/mark.html#mark-def).
     */
    val mark : Option[AnyMark] = None,

    /**
     * An array of parameters that may either be simple variables, or more complex selections
     * that map user input to data queries.
     */
    val params : Option[Seq[SelectionParameter]] = None,

    /**
     * The alignment to apply to grid rows and columns. The supported string values are `"all"`,
     * `"each"`, and `"none"`.
     *
     * - For `"none"`, a flow layout will be used, in which adjacent subviews are simply placed
     * one after the other.
     * - For `"each"`, subviews will be aligned into a clean grid structure, but each row or
     * column may be of variable size.
     * - For `"all"`, subviews will be aligned and each row or column will be sized identically
     * based on the maximum observed size. String values for this property will be applied to
     * both grid rows and columns.
     *
     * Alternatively, an object value of the form `{"row": string, "column": string}` can be
     * used to supply different alignments for rows and columns.
     *
     * __Default value:__ `"all"`.
     */
    val align : Option[VegaLiteDSLAlign] = None,

    /**
     * The bounds calculation method to use for determining the extent of a sub-plot. One of
     * `full` (the default) or `flush`.
     *
     * - If set to `full`, the entire calculated bounds (including axes, title, and legend) will
     * be used.
     * - If set to `flush`, only the specified width and height values for the sub-view will be
     * used. The `flush` setting can be useful when attempting to place sub-plots without axes
     * or legends into a uniform grid structure.
     *
     * __Default value:__ `"full"`
     */
    val bounds : Option[Bounds] = None,

    /**
     * Boolean flag indicating if subviews should be centered relative to their respective rows
     * or columns.
     *
     * An object value of the form `{"row": boolean, "column": boolean}` can be used to supply
     * different centering values for rows and columns.
     *
     * __Default value:__ `false`
     *
     * Boolean flag indicating if subviews should be centered relative to their respective rows
     * or columns.
     *
     * __Default value:__ `false`
     */
    val center : Option[Center] = None,

    /**
     * The spacing in pixels between sub-views of the composition operator. An object of the
     * form `{"row": number, "column": number}` can be used to set different spacing values for
     * rows and columns.
     *
     * __Default value__: Depends on `"spacing"` property of [the view composition
     * configuration](https://vega.github.io/vega-lite/docs/config.html#view-config) (`20` by
     * default)
     *
     * The spacing in pixels between sub-views of the concat operator.
     *
     * __Default value__: `10`
     */
    val spacing : Option[Spacing] = None,

    /**
     * The number of columns to include in the view composition layout.
     *
     * __Default value__: `undefined` -- An infinite number of columns (a single row) will be
     * assumed. This is equivalent to `hconcat` (for `concat`) and to using the `column` channel
     * (for `facet` and `repeat`).
     *
     * __Note__:
     *
     * 1) This property is only for:
     * - the general (wrappable) `concat` operator (not `hconcat`/`vconcat`)
     * - the `facet` and `repeat` operator with one field/repetition definition (without
     * row/column nesting)
     *
     * 2) Setting the `columns` to `1` is equivalent to `vconcat` (for `concat`) and to using
     * the `row` channel (for `facet` and `repeat`).
     */
    val columns : Option[Double] = None,

    /**
     * Definition for fields to be repeated. One of: 1) An array of fields to be repeated. If
     * `"repeat"` is an array, the field can be referred to as `{"repeat": "repeat"}`. The
     * repeated views are laid out in a wrapped row. You can set the number of columns to
     * control the wrapping. 2) An object that maps `"row"` and/or `"column"` to the listed
     * fields to be repeated along the particular orientations. The objects `{"repeat": "row"}`
     * and `{"repeat": "column"}` can be used to refer to the repeated field respectively.
     */
    val repeat : Option[RepeatUnion] = None,

    /**
     * A specification of the view that gets repeated.
     *
     * A specification of the view that gets faceted.
     */
    val spec : Option[SpecSpec] = None,

    /**
     * Definition for how to facet the data. One of: 1) [a field definition for faceting the
     * plot by one field](https://vega.github.io/vega-lite/docs/facet.html#field-def) 2) [An
     * object that maps `row` and `column` channels to their field
     * definitions](https://vega.github.io/vega-lite/docs/facet.html#mapping)
     */
    val facet : Option[Facet] = None,

    /**
     * A list of views to be concatenated.
     */
    val concat : Option[Seq[Spec]] = None,

    /**
     * A list of views to be concatenated and put into a column.
     */
    val vconcat : Option[Seq[Spec]] = None,

    /**
     * A list of views to be concatenated and put into a row.
     */
    val hconcat : Option[Seq[Spec]] = None
) derives Encoder.AsObject, Decoder
